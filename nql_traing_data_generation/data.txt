
Identify the top 5 countries with the highest sales growth in the e-commerce industry, considering only the products that have been in the market for more than 2 years, and excluding any products that have a negative growth rate. Additionally, provide the average sales amount for each of these countries.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "launch_date", "type": "DATE"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "average_sales", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "country", "type": "VARCHAR(255)"},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "country_sales",
        "columns": [
            {"name": "country_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "country_name", "type": "VARCHAR(255)"},
            {"name": "sales_growth", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.country_name, AVG(s.sales_amount) 
FROM sales_data s 
JOIN products p ON s.product_id = p.product_id 
JOIN country_sales c ON s.country = c.country_name 
WHERE p.launch_date < DATE('now', '-2 years') 
AND s.sales_amount > 0 
AND c.sales_growth = (SELECT MAX(sales_growth) 
                      FROM country_sales 
                      WHERE sales_growth > 0) 
GROUP BY c.country_name 
ORDER BY c.sales_growth DESC 
LIMIT 5
------------------
Analyze the customer lifetime value (CLV) for each product category in the top-performing e-commerce company. The CLV should be calculated based on the average order value, frequency of orders, and customer lifespan. Additionally, provide a ranking of the top 3 product categories with the highest CLV.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "date_of_birth", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"},
            {"name": "number_of_orders", "type": "INT"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "subcategory", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_item",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  pc.category_name,
  pc.subcategory,
  AVG(o.average_order_value) AS avg_order_value,
  AVG(o.number_of_orders) AS avg_order_frequency,
  AVG(o.order_date - c.date_of_birth) AS avg_customer_lifespan,
  (AVG(o.average_order_value) * AVG(o.number_of_orders)) / (o.order_date - c.date_of_birth) AS clv
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_item oi ON o.order_id = oi.order_id
JOIN product_categories pc ON oi.category_id = pc.category_id
GROUP BY pc.category_name, pc.subcategory
ORDER BY clv DESC
LIMIT 3
------------------
Develop a real-time alert system to notify the marketing team whenever a customer's purchase history indicates a high likelihood of churn. The alert should be triggered if the customer has placed fewer than 3 orders within the past 6 months, and has a purchase frequency of less than 1 order per month on average.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "date_of_birth", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "number_of_items", "type": "INT"}
        ]
    },
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "purchase_date", "type": "DATE"}
        ]
    }
]
Response:
WITH customer_purchases_count AS (
  SELECT customer_id, COUNT(purchase_id) AS purchase_count, 
         SUM(CASE WHEN purchase_date > DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH) THEN 1 ELSE 0 END) AS recent_purchase_count
  FROM customer_purchases
  GROUP BY customer_id
),
customer_orders_count AS (
  SELECT customer_id, COUNT(order_id) AS order_count, 
         COUNT(DISTINCT order_date) AS distinct_order_count
  FROM orders
  WHERE order_date > DATE_SUB(CURRENT_DATE, INTERVAL 6 MONTH)
  GROUP BY customer_id
)
SELECT c.name, c.email
FROM customers c
JOIN customer_purchases_count cpc ON c.customer_id = cpc.customer_id
JOIN customer_orders_count coc ON c.customer_id = coc.customer_id
WHERE cpc.purchase_count < 3 AND coc.order_count < 3 AND coc.distinct_order_count / 6 < 1;
------------------
Analyze the inventory levels of the top-selling products in the retail industry, considering only the products that have been in stock for more than 6 months. The analysis should include the amount of products sold, the revenue generated, and the average stock level. Additionally, provide a ranking of the top 3 products with the highest inventory turnover.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "stock_level", "type": "INT"}
        ]
    },
    {
        "name": "inventory_history",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "stock_level", "type": "INT"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH product_inventory AS (
  SELECT p.product_id, p.product_name, p.category, 
         AVG(i.stock_level) AS avg_stock_level, 
         SUM(s.sales_amount) AS total_revenue, 
         SUM(CASE WHEN d.date > (CURRENT_DATE - INTERVAL 6 MONTH) THEN 1 ELSE 0 END) AS months_in_stock
  FROM products p
  JOIN inventory_history i ON p.product_id = i.product_id
  JOIN sales_data s ON p.product_id = s.product_id
  JOIN (
    SELECT product_id, MAX(date) AS date
    FROM inventory_history
    GROUP BY product_id
  ) d ON p.product_id = d.product_id
  WHERE i.date <= d.date
  GROUP BY p.product_id, p.product_name, p.category
),
inventory_turnover AS (
  SELECT product_id, 
         (total_revenue / (avg_stock_level * months_in_stock)) AS turnover
  FROM product_inventory
)
SELECT product_id, product_name, category, 
       avg_stock_level, total_revenue, months_in_stock, turnover
FROM product_inventory
ORDER BY turnover DESC
LIMIT 3
------------------
Develop a predictive model to forecast the stock prices of a technology company, considering the historical trends, seasonality, and economic indicators. The model should be trained on a dataset of daily stock prices for the past 5 years, and should provide a 30-day forecast of the stock prices.
Schema:
[
    {
        "name": "stock_prices",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "opening_price", "type": "DECIMAL(10, 2)"},
            {"name": "high_price", "type": "DECIMAL(10, 2)"},
            {"name": "low_price", "type": "DECIMAL(10, 2)"},
            {"name": "closing_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "economic_indicators",
        "columns": [
            {"name": "indicator_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "indicator_name", "type": "VARCHAR(255)"},
            {"name": "value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  e.date, 
  e.indicator_name, 
  e.value, 
  s.closing_price 
FROM 
  stock_prices s 
  JOIN economic_indicators e ON s.date = e.date 
ORDER BY 
  e.date 
LIMIT 
  730;
------------------
Analyze the sales performance of a retail company across different regions and product categories, and identify the top-performing regions and products.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10,2)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    T1.region, 
    T1.product_category, 
    SUM(T1.sale_amount) AS total_sales
FROM 
    sales AS T1
GROUP BY 
    T1.region, 
    T1.product_category
ORDER BY 
    total_sales DESC
LIMIT 10;
------------------
**Predicting Customer Churn in a Telecom Company**
Develop a SQL query to identify the top 5% of customers who are most likely to churn within the next 3 months, based on their past behavior and demographic characteristics.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "plan_type", "type": "VARCHAR(255)"},
            {"name": "credit_limit", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "service_type", "type": "VARCHAR(255)"},
            {"name": "plan_change", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "events",
        "columns": [
            {"name": "event_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "event_date", "type": "DATE"},
            {"name": "event_type", "type": "VARCHAR(255)"},
            {"name": "event_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id
FROM customers c
JOIN (
  SELECT customer_id, 
    CASE 
      WHEN SUM(CASE WHEN event_type = 'credit_limit_exceeded' THEN 1 ELSE 0 END) > 2 
      OR SUM(CASE WHEN event_type = 'plan_change' THEN 1 ELSE 0 END) > 1 
      OR credit_limit < 500 
      OR age < 25 
      THEN 1 
      ELSE 0 
    END AS churn_score 
  FROM events e 
  JOIN customers c ON e.customer_id = c.customer_id 
  WHERE event_date BETWEEN CURRENT_DATE - INTERVAL 3 MONTH AND CURRENT_DATE 
  GROUP BY customer_id 
) AS churn_candidates 
ON c.customer_id = churn_candidates.customer_id 
ORDER BY churn_candidates.churn_score DESC 
LIMIT (SELECT COUNT(*) * 0.05 FROM customers);
------------------
**Analyzing Sales Performance in a Retail Store**
Develop a SQL query to generate a report that shows the top 10 products by sales revenue, along with their average rating, and the customer demographics that purchase them.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "ratings",
        "columns": [
            {"name": "rating_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "rating_value", "type": "TINYINT"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(o.order_total) AS total_revenue, AVG(r.rating_value) AS average_rating, c.age, c.gender 
FROM products p 
JOIN orders o ON p.product_id = o.product_id 
JOIN ratings r ON p.product_id = r.product_id 
JOIN customers c ON o.customer_id = c.customer_id 
GROUP BY p.product_name, c.age, c.gender 
ORDER BY total_revenue DESC 
LIMIT 10
------------------
**Optimizing Inventory Levels in a Warehouse**
Develop a SQL query to identify the top 5 products that are most likely to be overstocked or understocked within the next 2 weeks, based on historical sales data and supplier lead times.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "location_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES locations(location_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "suppliers",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "lead_time", "type": "SMALLINT"}
        ]
    }
]
Response:
SELECT p.product_name, i.quantity, s.lead_time 
FROM inventory i 
JOIN products p ON i.product_id = p.product_id 
JOIN suppliers s ON p.product_id = s.product_id 
WHERE i.quantity + (SELECT SUM(o.quantity) FROM orders o WHERE o.product_id = i.product_id AND o.order_date BETWEEN CURRENT_DATE - INTERVAL 2 WEEK AND CURRENT_DATE) * (s.lead_time / 7) BETWEEN 0 AND 2;
------------------
Analyze sales performance across different product categories and customer segments to identify opportunities for cross-selling and upselling.

Identify the top 3 product categories with the highest average order value (AOV) for each customer segment (new vs. returning) within the last quarter. Also, calculate the total sales revenue generated by each product category for the last quarter.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_category", "type": "VARCHAR(50)"},
            {"name": "product_subcategory", "type": "VARCHAR(50)"},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "customer_segment", "type": "VARCHAR(20)"},
            {"name": "is_new", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(50)"},
            {"name": "product_subcategory", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
    pc.product_category, 
    c.customer_segment, 
    AVG(s.order_total) AS avg_order_value, 
    SUM(s.order_total) AS total_sales_revenue
FROM 
    sales s
JOIN 
    customers c ON s.customer_id = c.customer_id
JOIN 
    product_categories pc ON s.product_category = pc.product_category
WHERE 
    s.order_date >= DATE('2022-10-01') AND s.order_date <= DATE('2022-12-31')
GROUP BY 
    c.customer_segment, pc.product_category
ORDER BY 
    c.customer_segment, avg_order_value DESC
LIMIT 3

SELECT 
    pc.product_category, 
    c.customer_segment, 
    AVG(s.order_total) AS avg_order_value
FROM 
    sales s
JOIN 
    customers c ON s.customer_id = c.customer_id
JOIN 
    product_categories pc ON s.product_category = pc.product_category
WHERE 
    c.is_new = 1
    AND s.order_date >= DATE('2022-10-01') AND s.order_date <= DATE('2022-12-31')
GROUP BY 
    c.customer_segment, pc.product_category
ORDER BY 
    c.customer_segment, avg_order_value DESC
LIMIT 3

SELECT 
    pc.product_category, 
    c.customer_segment, 
    AVG(s.order_total) AS avg_order_value
FROM 
    sales s
JOIN 
    customers c ON s.customer_id = c.customer_id
JOIN 
    product_categories pc ON s.product_category = pc.product_category
WHERE 
    c.is_new = 0
    AND s.order_date >= DATE('2022-10-01') AND s.order_date <= DATE('2022-12-31')
GROUP BY 
    c.customer_segment, pc.product_category
ORDER BY 
    c.customer_segment, avg_order_value DESC
LIMIT 3
------------------
Analyze patient outcomes and identify potential areas for clinical improvement in a business intelligence report.

Develop a SQL query to:

1. Identify the top 5 hospitals with the highest average 30-day readmission rates for patients with heart failure (HF) within the last 2 years.
2. For each of these hospitals, calculate the average length of stay (LOS) for HF patients and the proportion of HF patients who were readmitted within the last 30 days.
3. Additionally, calculate the average LOS for HF patients across all hospitals.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "hospital_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES hospitals(hospital_id)"]},
            {"name": "condition", "type": "VARCHAR(100)"},
            {"name": "readmission_date", "type": "DATE"},
            {"name": "discharge_date", "type": "DATE"}
        ]
    },
    {
        "name": "hospitals",
        "columns": [
            {"name": "hospital_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "hospital_name", "type": "VARCHAR(255)"},
            {"name": "city", "type": "VARCHAR(100)"},
            {"name": "state", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "readmissions",
        "columns": [
            {"name": "readmission_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "readmission_date", "type": "DATE"},
            {"name": "days_to_readmission", "type": "INT"}
        ]
    },
    {
        "name": "heart_failure",
        "columns": [
            {"name": "condition_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "condition_name", "type": "VARCHAR(100)"},
            {"name": "icd_code", "type": "VARCHAR(10)"}
        ]
    }
]
Response:
SELECT h.hospital_name, AVG(p.los) AS avg_los, AVG(CASE WHEN r.days_to_readmission <= 30 THEN 1.0 ELSE 0 END) AS readmission_proportion
FROM patients p
JOIN readmissions r ON p.patient_id = r.patient_id
JOIN heart_failure hf ON p.condition = hf.condition_name
JOIN hospitals h ON p.hospital_id = h.hospital_id
WHERE hf.condition_name = 'Heart Failure'
AND r.readmission_date >= DATE('now', '-2 years')
GROUP BY h.hospital_id, h.hospital_name
ORDER BY avg_los DESC
LIMIT 5

UNION ALL

SELECT 'Overall' AS hospital_name, AVG(p.los) AS avg_los, 0 AS readmission_proportion
FROM patients p
JOIN heart_failure hf ON p.condition = hf.condition_name
WHERE hf.condition_name = 'Heart Failure'

UNION ALL

SELECT 'Overall' AS hospital_name, AVG(p.los) AS avg_los, 
    AVG(CASE WHEN r.days_to_readmission <= 30 THEN 1.0 ELSE 0 END) AS readmission_proportion
FROM patients p
JOIN readmissions r ON p.patient_id = r.patient_id
JOIN heart_failure hf ON p.condition = hf.condition_name
WHERE hf.condition_name = 'Heart Failure'
------------------
Analyze customer purchase behavior and identify opportunities for targeted marketing campaigns.

Develop a SQL query to:

1. Identify the top 10 products with the highest average purchase frequency per customer within the last 6 months.
2. For each of these products, calculate the average revenue generated per customer and the proportion of customers who purchased the product more than once.
3. Additionally, identify the top 5 customers who have purchased the most products across all categories.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
WITH customer_purchases AS (
  SELECT customer_id, product_id, purchase_date
  FROM orders
  WHERE purchase_date >= DATE('now', '-6 months')
), 
product_frequency AS (
  SELECT product_id, COUNT(*) as purchase_frequency
  FROM customer_purchases
  GROUP BY product_id
  ORDER BY purchase_frequency DESC
  LIMIT 10
), 
product_revenue AS (
  SELECT p.product_id, AVG(ov.order_total) as average_revenue
  FROM customer_purchases ov
  JOIN orders o ON ov.order_id = o.order_id
  JOIN products p ON o.product_id = p.product_id
  GROUP BY p.product_id
), 
product_proportion AS (
  SELECT p.product_id, COUNT(*) as total_customers, SUM(CASE WHEN COUNT(*) > 1 THEN 1 ELSE 0 END) as repeat_customers
  FROM customer_purchases
  GROUP BY p.product_id
), 
top_customers AS (
  SELECT customer_id, COUNT(*) as total_products
  FROM orders
  GROUP BY customer_id
  ORDER BY total_products DESC
  LIMIT 5
)
SELECT 
  pf.product_id,
  pf.purchase_frequency,
  pr.average_revenue,
  CAST(prp.repeat_customers AS REAL) / prp.total_customers as proportion_repeat_customers
FROM product_frequency pf
JOIN product_revenue pr ON pf.product_id = pr.product_id
JOIN product_proportion prp ON pf.product_id = prp.product_id
JOIN top_customers tc ON tc.customer_id = prp.customer_id
ORDER BY pf.purchase_frequency DESC;
------------------
Analyze employee performance and identify areas for talent development and retention.

Develop a SQL query to:

1. Identify the top 3 departments with the highest average employee performance ratings (on a scale of 1-5) within the last quarter.
2. For each of these departments, calculate the average salary and the proportion of employees who exceed the average performance rating.
3. Additionally, identify the top 5 employees with the highest average performance ratings across all departments.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(50)"},
            {"name": "performance_rating date", "type": "DATE"}
        ]
    },
    {
        "name": "performance_ratings",
        "columns": [
            {"name": "rating_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "performance_rating", "type": "INT"}
        ]
    },
    {
        "name": "salaries",
        "columns": [
            {"name": "salary_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "salary", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT e.department, AVG(pr.performance_rating) as avg_rating, AVG(s.salary) as avg_salary, COUNT(CASE WHEN pr.performance_rating > AVG(pr.performance_rating) THEN 1 ELSE NULL END) / COUNT(*) as exceed_avg
FROM employees e
JOIN performance_ratings pr ON e.employee_id = pr.employee_id
JOIN salaries s ON e.employee_id = s.employee_id
WHERE pr.performance_rating_date BETWEEN DATE('now', '-3 months') AND DATE('now')
GROUP BY e.department
ORDER BY avg_rating DESC
LIMIT 3

UNION ALL

SELECT 'All Departments' as department, NULL as avg_rating, NULL as avg_salary, NULL as exceed_avg

UNION ALL

SELECT e.employee_name, AVG(pr.performance_rating) as avg_rating, NULL as avg_salary, NULL as exceed_avg
FROM employees e
JOIN performance_ratings pr ON e.employee_id = pr.employee_id
GROUP BY e.employee_name
ORDER BY avg_rating DESC
LIMIT 5
------------------
Analyze customer behavior and identify opportunities for targeted marketing campaigns.

Develop a SQL query to:

1. Identify the top 10 customers with the highest average order value (AOV) across all product categories within the last 6 months.
2. For each of these customers, calculate the average number of orders placed and the proportion of orders that resulted in a purchase.
3. Additionally, identify the top 5 products with the highest average AOV across all customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, AVG(o.order_total) AS avg_order_value, COUNT(o.order_id) AS num_orders, COUNT(o.order_id) / (SELECT COUNT(*) FROM orders o2 WHERE o2.customer_id = o.customer_id) AS purchase_proportion FROM customers c JOIN orders o ON c.customer_id = o.customer_id WHERE c.purchase_date >= DATE('now', '-6 months') GROUP BY c.customer_id ORDER BY avg_order_value DESC LIMIT 10

SELECT p.product_id, p.product_name, AVG(o.order_total) AS avg_order_value FROM products p JOIN orders o ON p.product_id = o.product_id GROUP BY p.product_id ORDER BY avg_order_value DESC LIMIT 5
------------------
Analyze inventory levels and identify opportunities for cost reduction and supply chain optimization.

Develop a SQL query to:

1. Identify the top 5 products with the highest average inventory levels across all warehouses within the last quarter.
2. For each of these products, calculate the average cost per unit and the proportion of inventory that is near expiration.
3. Additionally, identify the top 5 warehouses with the lowest average inventory turnover rates.
Schema:
[
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "product_costs",
        "columns": [
            {"name": "cost_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "cost", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT p.product_name, AVG(i.quantity) AS avg_inventory, 
       pc.cost, (SUM(CASE WHEN p.expiration_date <= DATE('now') THEN i.quantity ELSE 0 END) / SUM(i.quantity)) * 100 AS near_expiration_proportion
FROM inventory i
JOIN products p ON i.product_id = p.product_id
JOIN product_costs pc ON p.product_id = pc.product_id
WHERE i.warehouse_id IN (
  SELECT w.warehouse_id
  FROM inventory i
  JOIN warehouses w ON i.warehouse_id = w.warehouse_id
  GROUP BY w.warehouse_id
  ORDER BY AVG(i.quantity) DESC
  LIMIT 5
)
AND i.expiration_date IN (
  (SELECT MIN(expiration_date) FROM products), 
  (SELECT MAX(expiration_date) FROM products)
)
GROUP BY p.product_name, pc.cost
ORDER BY avg_inventory DESC
LIMIT 5

UNION ALL

SELECT w.warehouse_name, AVG(i.quantity / (SELECT SUM(i2.quantity) / (SELECT COUNT(*) FROM inventory i2 WHERE i2.warehouse_id = i.warehouse_id) FROM inventory i WHERE i.warehouse_id = w.warehouse_id)) AS avg_inventory_turnover
FROM inventory i
JOIN warehouses w ON i.warehouse_id = w.warehouse_id
GROUP BY w.warehouse_name
ORDER BY avg_inventory_turnover ASC
LIMIT 5
------------------
Analyze website traffic and identify opportunities for conversion rate optimization.

Develop a SQL query to:

1. Identify the top 5 pages with the highest average bounce rate across all devices within the last quarter.
2. For each of these pages, calculate the average time on page and the proportion of users who converted.
3. Additionally, identify the top 5 devices with the lowest average conversion rates.
Schema:
[
    {
        "name": "page_views",
        "columns": [
            {"name": "page_view_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "page_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES pages(page_id)"]},
            {"name": "device", "type": "VARCHAR(20)"},
            {"name": "bounce_rate", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "pages",
        "columns": [
            {"name": "page_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "page_name", "type": "VARCHAR(255)"},
            {"name": "page_category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "conversions",
        "columns": [
            {"name": "conversion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "page_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES pages(page_id)"]},
            {"name": "device", "type": "VARCHAR(20)"},
            {"name": "converted", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "user_sessions",
        "columns": [
            {"name": "session_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "page_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES pages(page_id)"]},
            {"name": "device", "type": "VARCHAR(20)"},
            {"name": "time_on_page", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    p.page_name,
    AVG(v.bounce_rate) AS average_bounce_rate,
    AVG(us.time_on_page) AS average_time_on_page,
    COUNT(CASE WHEN c.converted = 1 THEN 1 END) / COUNT(c.conversion_id) AS conversion_rate
FROM 
    page_views v
INNER JOIN 
    pages p ON v.page_id = p.page_id
LEFT JOIN 
    conversions c ON v.page_id = c.page_id AND v.device = c.device
LEFT JOIN 
    user_sessions us ON v.page_id = us.page_id AND v.device = us.device
WHERE 
    v.device IN ('desktop', 'tablet', 'mobile') 
    AND v.timestamp BETWEEN DATE('now', '-3 months') AND DATE('now')
GROUP BY 
    p.page_name
ORDER BY 
    average_bounce_rate DESC
LIMIT 5

UNION

SELECT 
    'device' AS page_name,
    NULL AS average_bounce_rate,
    NULL AS average_time_on_page,
    COUNT(CASE WHEN c.converted = 1 THEN 1 END) / COUNT(c.conversion_id) AS conversion_rate
FROM 
    conversions c
WHERE 
    c.converted = 0
GROUP BY 
    c.device
ORDER BY 
    conversion_rate DESC
LIMIT 5
------------------
Analyze employee demographics and identify opportunities for diversity and inclusion.

Develop a SQL query to:

1. Identify the top 5 departments with the highest proportion of female employees across all job titles within the last year.
2. For each of these departments, calculate the average salary and the proportion of employees who identify as LGBTQ+.
3. Additionally, identify the top 5 job titles with the highest proportion of underrepresented minorities.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(50)"},
            {"name": "job_title", "type": "VARCHAR(100)"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "ethnicity", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "ethnicity", "type": "VARCHAR(50)"},
            {"name": "lgbtq_status", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "salaries",
        "columns": [
            {"name": "salary_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "salary", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
  department, 
  AVG(T2.salary) AS average_salary, 
  COUNT(CASE WHEN T2.gender = 'F' THEN 1 END) / COUNT(T1.employee_id) AS female_proportion,
  COUNT(CASE WHEN T3.lgbtq_status = 1 THEN 1 END) / COUNT(T1.employee_id) AS lgbtq_proportion
FROM 
  employees T1
LEFT JOIN 
  salaries T2 ON T1.employee_id = T2.employee_id
LEFT JOIN 
  demographics T3 ON T1.employee_id = T3.employee_id
GROUP BY 
  department
ORDER BY 
  female_proportion DESC
LIMIT 5

UNION ALL

SELECT 
  job_title, 
  AVG(T2.salary) AS average_salary, 
  COUNT(CASE WHEN T2.ethnicity IN ('Asian', 'Black or African American', 'Hispanic or Latino', 'American Indian or Alaska Native') THEN 1 END) / COUNT(T1.employee_id) AS minority_proportion
FROM 
  employees T1
LEFT JOIN 
  salaries T2 ON T1.employee_id = T2.employee_id
GROUP BY 
  job_title
ORDER BY 
  minority_proportion DESC
LIMIT 5
------------------
Analyze customer reviews and identify opportunities for product development and improvement.

Develop a SQL query to:

1. Identify the top 5 products with the highest average rating across all reviews within the last year.
2. For each of these products, calculate the average number of reviews and the proportion of reviews that are positive.
3. Additionally, identify the top 5 customers who have written the most reviews across all products.
Schema:
[
    {
        "name": "reviews",
        "columns": [
            {"name": "review_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "rating", "type": "INT"},
            {"name": "review_text", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    p.product_name,
    AVG(r.rating) AS avg_rating,
    COUNT(r.review_id) AS review_count,
    COUNT(CASE WHEN r.rating > 3 THEN 1 END) / COUNT(r.review_id) AS positive_review_proportion,
    (SELECT COUNT(DISTINCT review_id) 
     FROM reviews 
     WHERE customer_id = c.customer_id) AS total_reviews
FROM reviews r
JOIN products p ON r.product_id = p.product_id
JOIN customers c ON r.customer_id = c.customer_id
WHERE r.review_id IN (
    SELECT review_id 
    FROM reviews 
    WHERE review_date >= DATE('now', '-1 year')
)
GROUP BY p.product_name
ORDER BY avg_rating DESC
LIMIT 5

SELECT 
    c.customer_name,
    COUNT(r.review_id) AS review_count
FROM reviews r
JOIN customers c ON r.customer_id = c.customer_id
WHERE r.review_id IN (
    SELECT review_id 
    FROM reviews 
    WHERE review_date >= DATE('now', '-1 year')
)
GROUP BY c.customer_name
ORDER BY review_count DESC
LIMIT 5
------------------
**Predicting Customer Churn in the Telecommunications Industry**

Develop a SQL query to identify the top 5% of customers who are most likely to churn in the next 3 months, based on their past usage patterns and demographic characteristics.
Schema:
[
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"},
      {"name": "age", "type": "INT"},
      {"name": "plan_type", "type": "VARCHAR(50)"},
      {"name": "subscription_date", "type": "DATE"}
    ]
  },
  {
    "name": "usage_data",
    "columns": [
      {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "usage_date", "type": "DATE"},
      {"name": "data_usage", "type": "FLOAT"},
      {"name": "voice_minutes", "type": "FLOAT"}
    ]
  },
  {
    "name": "billing_info",
    "columns": [
      {"name": "billing_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "billing_date", "type": "DATE"},
      {"name": "amount_paid", "type": "FLOAT"}
    ]
  },
  {
    "name": "churn_data",
    "columns": [
      {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "churn_date", "type": "DATE"},
      {"name": "reason_for_churn", "type": "VARCHAR(255)"}
    ]
  }
]
Response:
SELECT c.customer_id
FROM customers c
JOIN usage_data ud ON c.customer_id = ud.customer_id
JOIN billing_info bi ON c.customer_id = bi.customer_id
WHERE (ud.data_usage > (SELECT AVG(data_usage) FROM usage_data WHERE usage_date BETWEEN DATE('now', '-3 months') AND DATE('now')) * 2 OR
       ud.voice_minutes > (SELECT AVG(voice_minutes) FROM usage_data WHERE usage_date BETWEEN DATE('now', '-3 months') AND DATE('now')) * 2) AND
      bi.amount_paid < (SELECT AVG(amount_paid) FROM billing_info WHERE billing_date BETWEEN DATE('now', '-3 months') AND DATE('now')) * 0.8
GROUP BY c.customer_id
ORDER BY COUNT(*) DESC
LIMIT (SELECT COUNT(*) FROM customers) * 0.05;
------------------
**Analyzing Online Sales and Inventory in an E-commerce Platform**

Develop a SQL query to identify the top 10 products that have been out of stock for the longest period, along with their average sales price and the total revenue lost due to stockouts.
Schema:
[
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_name", "type": "VARCHAR(255)"},
      {"name": "category", "type": "VARCHAR(50)"},
      {"name": "average_price", "type": "FLOAT"}
    ]
  },
  {
    "name": "inventory",
    "columns": [
      {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
      {"name": "store_id", "type": "INT"},
      {"name": "quantity", "type": "INT"},
      {"name": "last_updated", "type": "DATE"}
    ]
  },
  {
    "name": "sales_data",
    "columns": [
      {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
      {"name": "sale_date", "type": "DATE"},
      {"name": "quantity_sold", "type": "INT"},
      {"name": "amount_sold", "type": "FLOAT"}
    ]
  },
  {
    "name": "stockout_history",
    "columns": [
      {"name": "stockout_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
      {"name": "stockout_date", "type": "DATE"},
      {"name": "duration", "type": "INT"}
    ]
  }
]
Response:
SELECT p.product_id, p.product_name, p.average_price, 
       (s.duration * p.average_price) AS total_revenue_lost
FROM products p
JOIN (
  SELECT product_id, MAX(stockout_date) AS stockout_date, 
         SUM(duration) AS duration
  FROM stockout_history
  GROUP BY product_id
  HAVING SUM(duration) >= (
    SELECT MAX(duration)
    FROM (
      SELECT product_id, 
             SUM(CASE 
                     WHEN quantity_sold = 0 THEN 1 
                     ELSE 0 END) AS stockout_count
      FROM sales_data s
      JOIN inventory i ON s.product_id = i.product_id
      GROUP BY product_id
    ) AS subquery
  )
) s ON p.product_id = s.product_id
ORDER BY s.duration DESC
LIMIT 10
------------------
**Identifying High-Risk Transactions in a Financial Database**

Develop a SQL query to detect suspicious transactions that exceed 5 times the average transaction amount, involve multiple accounts, or occur within a short timeframe (less than 1 hour).
Schema:
[
  {
    "name": "accounts",
    "columns": [
      {"name": "account_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "account_number", "type": "VARCHAR(255)"},
      {"name": "account_type", "type": "VARCHAR(50)"}
    ]
  },
  {
    "name": "transactions",
    "columns": [
      {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "account_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES accounts(account_id)"]},
      {"name": "transaction_date", "type": "DATE"},
      {"name": "amount", "type": "FLOAT"},
      {"name": "type", "type": "VARCHAR(50)"}
    ]
  },
  {
    "name": "transaction_logs",
    "columns": [
      {"name": "log_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "transaction_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES transactions(transaction_id)"]},
      {"name": "log_date", "type": "DATE"},
      {"name": "description", "type": "VARCHAR(255)"}
    ]
  }
]
Response:
SELECT t1.transaction_id, t1.amount, t1.type 
FROM transactions t1 
INNER JOIN (
  SELECT account_id, AVG(amount) as avg_amount
  FROM transactions
  GROUP BY account_id
) t2 ON t1.account_id = t2.account_id 
WHERE t1.amount > (SELECT 5 * avg_amount FROM (
  SELECT account_id, AVG(amount) as avg_amount
  FROM transactions
  GROUP BY account_id
) t3) OR t1.account_id IN (
  SELECT account_id FROM (
    SELECT account_id, COUNT(*) as count
    FROM transactions
    GROUP BY account_id
  ) t4 WHERE count > 1
) OR t1.transaction_date - (
  SELECT MAX(transaction_date) as max_date
  FROM transactions
) < INTERVAL 1 HOUR
------------------
**Analyzing Student Performance in a University Database**

Develop a SQL query to identify the top 20% of students who have shown the most improvement in their grades over the past 2 semesters, along with their average GPA and the number of credits taken.
Schema:
[
  {
    "name": "students",
    "columns": [
      {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"},
      {"name": "major", "type": "VARCHAR(50)"}
    ]
  },
  {
    "name": "grades",
    "columns": [
      {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
      {"name": "semester", "type": "VARCHAR(50)"},
      {"name": "course_id", "type": "INT"},
      {"name": "grade", "type": "VARCHAR(10)"}
    ]
  },
  {
    "name": "courses",
    "columns": [
      {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "course_name", "type": "VARCHAR(255)"},
      {"name": "credits", "type": "INT"}
    ]
  },
  {
    "name": "Student_Course",
    "columns": [
      {"name": "Student_Course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
      {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]}
    ]
  }
]
Response:
SELECT s.name, AVG(g.grade) AS average_gpa, COUNT(c.credits) AS total_credits
FROM students s
JOIN Student_Course sc ON s.student_id = sc.student_id
JOIN courses c ON sc.course_id = c.course_id
JOIN (
  SELECT student_id, grade, semester
  FROM grades
  WHERE semester IN ('semester1', 'semester2')
) g ON s.student_id = g.student_id
GROUP BY s.student_id
ORDER BY (g.grade - LAG(g.grade, 1) OVER (PARTITION BY s.student_id ORDER BY g.semester)) DESC
LIMIT 20 * (SELECT COUNT(*) / 5 FROM grades)
------------------
**Identifying High-Value Customers in a Retail Database**

Develop a SQL query to identify the top 10 customers who have spent the most in the past year, along with their total spending, average order value, and number of orders.
Schema:
[
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"},
      {"name": "address", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "orders",
    "columns": [
      {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "order_date", "type": "DATE"},
      {"name": "total_cost", "type": "FLOAT"}
    ]
  },
  {
    "name": "order_items",
    "columns": [
      {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
      {"name": "product_id", "type": "INT"},
      {"name": "quantity", "type": "INT"}
    ]
  },
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_name", "type": "VARCHAR(255)"},
      {"name": "price", "type": "FLOAT"}
    ]
  }
]
Response:
SELECT c.name, c.email, c.address, SUM(o.total_cost) AS total_spending, AVG(o.total_cost) AS avg_order_value, COUNT(o.order_id) AS num_orders
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= DATE('now', '-1 year')
GROUP BY c.customer_id, c.name, c.email, c.address
ORDER BY total_spending DESC
LIMIT 10
------------------
Predict customer churn and identify high-value customers who are likely to leave the company within the next 3 months.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "account_created_date", "type": "DATE"},
            {"name": "last_active_date", "type": "DATE"},
            {"name": "account_balance", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "payment_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "marketing_campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "customer_marketing_interactions",
        "columns": [
            {"name": "interaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "campaign_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES marketing_campaigns(campaign_id)"]},
            {"name": "interaction_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.account_balance, 
  MAX(DATEDIFF('now', c.last_active_date)) as days_since_last_activity,
  COUNT(*) as total_orders,
  SUM(oi.order_total) as total_spent,
  SUM(p.payment_amount) as total_paid
FROM 
  customers c
  LEFT JOIN orders oi ON c.customer_id = oi.customer_id
  LEFT JOIN payments p ON c.customer_id = p.customer_id AND p.payment_date = (SELECT MAX(payment_date) FROM payments WHERE customer_id = c.customer_id)
WHERE 
  c.account_balance < 1000
GROUP BY 
  c.customer_id, c.name, c.email, c.account_balance
HAVING 
  MAX(DATEDIFF('now', c.last_active_date)) > 90
  AND total_orders < 10
  AND total_spent < 1000
ORDER BY 
  total_spent DESC
------------------
Analyze sales data across different regions and product categories to identify opportunities for inventory optimization.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_quantity", "type": "INT"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "inventory_quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    i.product_id, 
    p.product_name, 
    p.product_category, 
    w.region, 
    SUM(i.inventory_quantity) AS current_inventory, 
    SUM(s.sale_quantity) AS sales_quantity
FROM 
    inventory i
JOIN 
    products p ON i.product_id = p.product_id
JOIN 
    sales s ON p.product_id = s.product_id
JOIN 
    warehouses w ON i.warehouse_id = w.warehouse_id
GROUP BY 
    i.product_id, 
    p.product_name, 
    p.product_category, 
    w.region
HAVING 
    SUM(s.sale_quantity) > SUM(i.inventory_quantity)
------------------
Identify top-performing sales representatives and calculate their total sales revenue for the past quarter.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "role", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT e.name, SUM(s.sale_amount) AS total_sales
FROM employees e
JOIN sales s ON e.employee_id = s.employee_id
WHERE s.sale_date BETWEEN DATE('now','-3 months') AND DATE('now')
GROUP BY e.name
ORDER BY total_sales DESC
------------------
Analyze website traffic and social media engagement metrics to identify trends and correlations between different channels.
Schema:
[
    {
        "name": "web_traffic",
        "columns": [
            {"name": "traffic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "page_views", "type": "INT"},
            {"name": "unique_visitors", "type": "INT"}
        ]
    },
    {
        "name": "social_media",
        "columns": [
            {"name": "post_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "channel", "type": "VARCHAR(255)"},
            {"name": "engagement_rate", "type": "DECIMAL(10, 2)"},
            {"name": "reach", "type": "INT"}
        ]
    },
    {
        "name": "web_page_content",
        "columns": [
            {"name": "content_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "page_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "social_media_content",
        "columns": [
            {"name": "content_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "post_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES social_media(post_id)"]},
            {"name": "content_type", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT s.channel, AVG(s.engagement_rate) AS avg_engagement_rate, 
       SUM(w.page_views) AS total_page_views, 
       SUM(w.unique_visitors) AS total_unique_visitors
FROM social_media s
JOIN web_traffic w ON s.date = w.date
GROUP BY s.channel
ORDER BY avg_engagement_rate DESC;
------------------
Identify the top 5 countries with the highest average order value (AOV) across all product categories, while considering the impact of currency fluctuations on AOV. Analyze the relationship between AOV and the number of orders placed by customers from each country.
Schema:
[
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "country", "type": "VARCHAR(255)"},
            {"name": "currency", "type": "VARCHAR(10)"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"},
            {"name": "currency", "type": "VARCHAR(10)"}
        ]
    },
    {
        "name": "exchange_rates",
        "columns": [
            {"name": "exchange_date", "type": "DATE"},
            {"name": "currency_pair", "type": "VARCHAR(10)"},
            {"name": "exchange_rate", "type": "DECIMAL(10, 6)"}
        ]
    }
]
Response:
SELECT T1.country, 
       AVG(T1.total_amount * T3.exchange_rate) AS average_order_value,
       COUNT(T2.customer_id) AS num_orders
FROM orders T1
JOIN customers T2 ON T1.customer_id = T2.customer_id
JOIN (
  SELECT currency_pair, 
         MAX(exchange_date) AS exchange_date
  FROM exchange_rates
  GROUP BY currency_pair
) T3 ON T2.currency = SUBSTR(T3.currency_pair, 3, LENGTH(T3.currency_pair) - 3)
JOIN exchange_rates T4 ON T3.currency_pair = T4.currency_pair
AND T3.exchange_date = T4.exchange_date
GROUP BY T1.country
ORDER BY average_order_value DESC
LIMIT 5
------------------
Develop a SQL query to calculate the quarterly sales growth rate for each product category in the retail industry, considering the impact of seasonal fluctuations. Analyze the sales trend for each category and identify the top 3 categories with the highest growth rate.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "season_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "season_name", "type": "VARCHAR(100)"},
            {"name": "season_start_date", "type": "DATE"},
            {"name": "season_end_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  pc.category_name, 
  SUM(CASE 
        WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 1 AND 3 THEN s.sale_amount
        ELSE 0
      END) AS Q1,
  SUM(CASE 
        WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 4 AND 6 THEN s.sale_amount
        ELSE 0
      END) AS Q2,
  SUM(CASE 
        WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 7 AND 9 THEN s.sale_amount
        ELSE 0
      END) AS Q3,
  SUM(CASE 
        WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 10 AND 12 THEN s.sale_amount
        ELSE 0
      END) AS Q4,
  (SUM(CASE 
           WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 1 AND 3 THEN s.sale_amount
           ELSE 0
         END) + SUM(CASE 
           WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 10 AND 12 THEN s.sale_amount
           ELSE 0
         END)) / 
  (SUM(CASE 
           WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 4 AND 6 THEN s.sale_amount
           ELSE 0
         END) + SUM(CASE 
           WHEN EXTRACT(MONTH FROM s.sale_date) BETWEEN 7 AND 9 THEN s.sale_amount
           ELSE 0
         END)) AS growth_rate
FROM 
  sales s
JOIN 
  product_categories pc ON s.product_category = pc.category_name
GROUP BY 
  pc.category_name
ORDER BY 
  growth_rate DESC
LIMIT 
  3
------------------
Design a SQL query to analyze the patient outcome for patients with diabetes, focusing on the impact of medication adherence on HbA1c levels. Identify the top 3 medications that have the highest correlation with improved HbA1c levels.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "diagnosis_date", "type": "DATE"},
            {"name": "medication_adherence", "type": "TINYINT"}
        ]
    },
    {
        "name": "medications",
        "columns": [
            {"name": "medication_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "medication_name", "type": "VARCHAR(100)"},
            {"name": "dosage", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "hba1c_levels",
        "columns": [
            {"name": "hba1c_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "hba1c_level", "type": "DECIMAL(10, 2)"},
            {"name": "measurement_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    m.medication_name, 
    AVG(h.hba1c_level) AS avg_hbA1c, 
    COUNT(h.hba1c_id) AS num_measurements
FROM 
    medications m
JOIN 
    hba1c_levels h ON m.medication_name = h.hba1c_level
JOIN 
    patients p ON h.patient_id = p.patient_id
WHERE 
    p.diagnosis_date < '2020-01-01' AND p.medication_adherence > 50
GROUP BY 
    m.medication_name
ORDER BY 
    CORR(m.medication_name, h.hba1c_level) DESC
LIMIT 
    3
------------------
Develop a SQL query to analyze the student performance in a university, focusing on the impact of course difficulty on student grades. Identify the top 3 courses with the highest correlation between difficulty and student performance.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "enrollment_date", "type": "DATE"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(100)"},
            {"name": "difficulty_level", "type": "TINYINT"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  c.course_name, 
  c.difficulty_level, 
  correlation.coef AS correlation 
FROM 
  (SELECT 
     course_id, 
     difficulty_level, 
     grade, 
     AVG(grade) AS avg_grade 
   FROM 
     grades 
   GROUP BY 
     course_id, 
     difficulty_level, 
     grade) AS subquery 
JOIN 
  (SELECT 
     course_id, 
     difficulty_level, 
     AVG(grade) AS avg_grade 
   FROM 
     grades 
   GROUP BY 
     course_id, 
     difficulty_level 
   GROUP BY 
     course_id, 
     difficulty_level 
   ORDER BY 
     AVG(grade) DESC 
   LIMIT 3) AS top_courses 
ON 
  subquery.course_id = top_courses.course_id 
JOIN 
  (SELECT 
     course_id, 
     difficulty_level, 
     SUM((grade - avg_grade) * (grade - avg_grade)) AS numerator, 
     (SELECT 
        COUNT(*) 
      FROM 
        grades 
      WHERE 
        course_id = subquery.course_id) AS denominator 
   FROM 
     (SELECT 
        course_id, 
        difficulty_level, 
        grade, 
        AVG(grade) OVER (PARTITION BY course_id) AS avg_grade 
      FROM 
        grades) AS subquery 
   GROUP BY 
     course_id, 
     difficulty_level, 
     avg_grade 
   ORDER BY 
     numerator / (denominator * denominator) DESC) AS correlation 
ON 
  (subquery.course_id = correlation.course_id)
------------------
Design a SQL query to analyze the inventory levels for a retail store, focusing on the impact of seasonal fluctuations on stock levels. Identify the top 3 products with the highest variation in inventory levels across different seasons.
Schema:
[
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT"},
            {"name": "season_id", "type": "INT"},
            {"name": "inventory_level", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "season_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "season_name", "type": "VARCHAR(100)"},
            {"name": "season_start_date", "type": "DATE"},
            {"name": "season_end_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT p.product_name, 
       (SELECT MAX(i.inventory_level) - MIN(i.inventory_level) 
        FROM inventory i 
        WHERE i.product_id = p.product_id) AS variation 
FROM products p 
ORDER BY variation DESC 
LIMIT 3
------------------
**Predicting Customer Churn using Time-Series Analysis**
Analyze customer behavior and predict the likelihood of customers churning within the next 6 months based on their historical purchasing patterns, demographic data, and account activity.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "account_activity",
        "columns": [
            {"name": "activity_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "activity_type", "type": "VARCHAR(255)"},
            {"name": "activity_date", "type": "DATE"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn_predictions",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "prediction_date", "type": "DATE"},
            {"name": "churn_likelihood", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH orders_history AS (
  SELECT 
    o.customer_id,
    o.order_date,
    o.order_total,
    ROW_NUMBER() OVER(PARTITION BY o.customer_id ORDER BY o.order_date DESC) AS row_num
  FROM orders o
),
churn_window AS (
  SELECT 
    c.customer_id,
    MAX(o.order_date) AS last_order_date
  FROM customers c
  LEFT JOIN orders o ON c.customer_id = o.customer_id
  GROUP BY c.customer_id
),
prediction_data AS (
  SELECT 
    c.customer_id,
    d.age,
    d.income,
    AVG(o.order_total) AS avg_order_total,
    COUNT(DISTINCT o.order_date) AS num_orders,
    MAX(aa.activity_date) AS last_activity_date
  FROM customers c
  LEFT JOIN orders o ON c.customer_id = o.customer_id
  LEFT JOIN account_activity aa ON c.customer_id = aa.customer_id
  LEFT JOIN demographics d ON c.customer_id = d.customer_id
  GROUP BY c.customer_id, d.age, d.income
),
prediction_model AS (
  SELECT 
    pd.customer_id,
    pd.avg_order_total,
    pd.num_orders,
    pd.last_activity_date,
    pd.age,
    pd.income,
    CASE 
      WHEN (pd.num_orders > 2 AND pd.avg_order_total > 100 AND pd.last_activity_date > DATE('now', '-6 months')) 
      THEN 1
      ELSE 0
    END AS churn_likelihood
  FROM prediction_data pd
)
INSERT INTO churn_predictions (customer_id, prediction_date, churn_likelihood)
SELECT 
  pm.customer_id,
  CURRENT_DATE,
  pm.churn_likelihood
FROM prediction_model pm
WHERE pm.churn_likelihood = 1;
------------------
**Analyzing Sales Performance by Region and Product Category**
Analyze sales data by region and product category to identify top-selling products, revenue by region, and regional sales growth trends.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "region_code", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "category_code", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "top_sellers",
        "columns": [
            {"name": "top_seller_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "top_seller_product", "type": "VARCHAR(255)"},
            {"name": "top_seller_revenue", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  pc.category_name, 
  SUM(s.sale_amount) AS total_revenue, 
  SUM(CASE WHEN s.sale_date > (SELECT MAX(sale_date) FROM sales) - INTERVAL 1 YEAR THEN s.sale_amount ELSE 0 END) AS recent_revenue
FROM sales s
JOIN regions r ON s.region_id = r.region_id
JOIN product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY r.region_name, pc.category_name
ORDER BY total_revenue DESC
------------------
**Identifying High-Risk Patients in a Healthcare Setting**
Analyze patient data to identify high-risk patients based on their medical history, treatment outcomes, and demographic information.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "birth_date", "type": "DATE"},
            {"name": "gender", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "medical_history",
        "columns": [
            {"name": "medical_history_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "condition_name", "type": "VARCHAR(255)"},
            {"name": "diagnosis_date", "type": "DATE"}
        ]
    },
    {
        "name": "treatments",
        "columns": [
            {"name": "treatment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_name", "type": "VARCHAR(255)"},
            {"name": "treatment_date", "type": "DATE"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "risk_scores",
        "columns": [
            {"name": "risk_score_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "risk_score", "type": "DECIMAL(10, 2)"},
            {"name": "risk_score_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT p.patient_id, p.name, d.age, d.income, 
       SUM(CASE WHEN t.treatment_name = 'High-Risk Medication' THEN 1 ELSE 0 END) AS high_risk_medication,
       SUM(CASE WHEN mh.condition_name IN ('Diabetes', 'Hypertension') THEN 1 ELSE 0 END) AS high_risk_conditions,
       rs.risk_score
FROM patients p
JOIN demographics d ON p.patient_id = d.patient_id
JOIN treatments t ON p.patient_id = t.patient_id
JOIN medical_history mh ON p.patient_id = mh.patient_id
JOIN risk_scores rs ON p.patient_id = rs.patient_id
WHERE t.treatment_date > (SELECT MIN(treatment_date) + INTERVAL 6 MONTH FROM treatments)
GROUP BY p.patient_id, p.name, d.age, d.income, rs.risk_score
HAVING high_risk_medication > 0 AND high_risk_conditions > 0;
------------------
**Predicting Customer Churn in E-commerce**

Develop a SQL query to identify customers who are likely to churn in the next 30 days based on their purchase history, demographics, and behavioral data.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "location", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(100)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "returns",
        "columns": [
            {"name": "return_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "reason", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "email_interactions",
        "columns": [
            {"name": "email_interaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "email_date", "type": "DATE"},
            {"name": "email_content", "type": "VARCHAR(255)"},
            {"name": "response", "type": "VARCHAR(100)"}
        ]
    }
]
Response:
SELECT c.customer_id 
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id 
WHERE o.order_date < DATE('now', '-30 days') 
AND c.age > 25 
AND c.gender = 'M' 
AND o.quantity = 1 
AND o.product_id IN (SELECT product_id FROM products WHERE category = 'Electronics') 
AND c.customer_id NOT IN (SELECT customer_id FROM returns);
------------------
**Analyzing Student Performance in Online Education**

Develop a SQL query to identify the top 10 performing courses in terms of student engagement, based on the number of assignments submitted, discussion, and grades.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "course_id", "type": "INT"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "assignments",
        "columns": [
            {"name": "assignment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "assignment_date", "type": "DATE"},
            {"name": "grade", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "discussions",
        "columns": [
            {"name": "discussion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "discussion_date", "type": "DATE"},
            {"name": "content", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.course_name, COUNT(a.assignment_id) as num_assignments, COUNT(d.discussion_id) as num_discussions, AVG(a.grade) as avg_grade 
FROM courses c 
JOIN assignments a ON c.course_id = a.course_id 
JOIN discussions d ON c.course_id = d.course_id 
GROUP BY c.course_id, c.course_name 
ORDER BY num_assignments + num_discussions + avg_grade DESC 
LIMIT 10
------------------
**Optimizing Inventory Management in Retail**

Develop a SQL query to identify the top 10 products in terms of sales, and provide a forecast of future sales based on historical data.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(100)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "inventory_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(s.quantity) AS total_sales, p.price 
FROM sales s 
JOIN products p ON s.product_id = p.product_id 
JOIN inventory i ON p.product_id = i.product_id 
GROUP BY p.product_name, p.price 
ORDER BY total_sales DESC 
LIMIT 10;

WITH sales_data AS (
  SELECT p.product_name, p.price, SUM(s.quantity) AS total_sales, 
  LAG(SUM(s.quantity), 1, 0) OVER (PARTITION BY p.product_name ORDER BY s.sale_date) AS prev_month_sales
  FROM sales s 
  JOIN products p ON s.product_id = p.product_id 
  GROUP BY p.product_name, p.price, s.sale_date
)
SELECT product_name, price, total_sales, prev_month_sales, 
       total_sales - prev_month_sales AS sales_forecast 
FROM sales_data 
ORDER BY total_sales DESC 
LIMIT 10;
------------------
**Analyzing Customer Churn and Revenue Impact**

A retail company wants to identify the key factors contributing to customer churn and estimate the revenue loss due to churned customers. The company has data on customer demographics, purchase history, and order frequency. Develop a SQL query to calculate the revenue impact of churned customers and identify the most influential factors leading to churn.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"},
            {"name": "last_order_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "customer_purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "purchase_date", "type": "DATE"},
            {"name": "purchase_frequency", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    SUM(o.order_total) AS total_revenue,
    COUNT(DISTINCT o.order_id) AS order_count,
    COUNT(DISTINCT op.product_id) AS product_count,
    SUM(op.quantity) AS total_quantity,
    COALESCE(cp.purchase_frequency, 0) AS purchase_frequency,
    CASE 
        WHEN lp.days_between_last_orders > 30 THEN 'High'
        WHEN lp.days_between_last_orders > 15 THEN 'Medium'
        ELSE 'Low'
    END AS churn_risk
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items op ON o.order_id = op.order_id
LEFT JOIN 
    customer_purchases cp ON c.customer_id = cp.customer_id
LEFT JOIN 
    (
        SELECT 
            c.customer_id,
            DATE_SUB(lq.last_order_date, INTERVAL 1 DAY) AS previous_last_order_date,
            lq.last_order_date
        FROM 
            customers c
        JOIN 
            orders lq ON c.customer_id = lq.customer_id
        ORDER BY 
            c.customer_id, last_order_date
    ) lp ON c.customer_id = lp.customer_id
WHERE 
    c.last_order_date < (SELECT AVG(last_order_date) FROM customers)
GROUP BY 
    c.customer_id, c.name, c.email
ORDER BY 
    total_revenue DESC;
------------------
**Identifying High-Risk Patients and Predicting Healthcare Costs**

A hospital wants to identify high-risk patients and predict their healthcare costs based on their medical history, treatment plans, and demographic information. The hospital has a large dataset containing patient demographics, medical records, and treatment plans. Develop a SQL query to identify high-risk patients and estimate their future healthcare costs.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "dob", "type": "DATE"},
            {"name": "insurance_type", "type": "VARCHAR(255)"},
            {"name": "diagnosis", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "medical_records",
        "columns": [
            {"name": "medical_record_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "medical_event", "type": "VARCHAR(255)"},
            {"name": "event_date", "type": "DATE"}
        ]
    },
    {
        "name": "treatment_plans",
        "columns": [
            {"name": "treatment_plan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_type", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "medications",
        "columns": [
            {"name": "medication_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "medication_name", "type": "VARCHAR(255)"},
            {"name": "dosage", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"}
        ]
    },
    {
        "name": "lab_results",
        "columns": [
            {"name": "lab_result_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "lab_test", "type": "VARCHAR(255)"},
            {"name": "result_date", "type": "DATE"},
            {"name": "result_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT p.patient_id, p.name, p.insurance_type, 
       SUM(CASE WHEN m.medication_name LIKE '%Diabetes%' THEN 1 ELSE 0 END) AS diabetes_count,
       SUM(CASE WHEN lr.result_value > 100 THEN 1 ELSE 0 END) AS high_blood_pressure_count,
       SUM(CASE WHEN tp.treatment_type LIKE '%Surgery%' THEN 1 ELSE 0 END) AS surgery_count,
       SUM(CASE WHEN mr.medical_event LIKE '%Hospitalization%' THEN 1 ELSE 0 END) AS hospitalization_count
FROM patients p
LEFT JOIN medical_records mr ON p.patient_id = mr.patient_id
LEFT JOIN medications m ON p.patient_id = m.patient_id
LEFT JOIN lab_results lr ON p.patient_id = lr.patient_id
LEFT JOIN treatment_plans tp ON p.patient_id = tp.patient_id
GROUP BY p.patient_id, p.name, p.insurance_type
ORDER BY diabetes_count DESC, high_blood_pressure_count DESC, surgery_count DESC, hospitalization_count DESC;
------------------
**Analyzing Sales Performance by Product Category and Region**

A retail company wants to analyze its sales performance by product category and region. The company has data on sales transactions, product categories, and store locations. Develop a SQL query to calculate the total sales revenue by product category and region.
Schema:
[
    {
        "name": "sales_transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT"},
            {"name": "product_id", "type": "INT"},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"},
            {"name": "store_location", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT p.product_category, s.region, SUM(st.sale_amount) AS total_sales
FROM sales_transactions st
JOIN products p ON st.product_id = p.product_id
JOIN stores s ON st.store_id = s.store_id
GROUP BY p.product_category, s.region
------------------
Identify the top 10 products with the highest total sales revenue across all regions, taking into account the sales tax rates and discounts applied to each order.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "sales_tax_rate", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"},
            {"name": "discount", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.product_id, p.product_name, SUM((oi.quantity * oi.unit_price * (1 - oi.discount)) * (1 + p.sales_tax_rate)) AS total_sales
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY p.product_id, p.product_name
ORDER BY total_sales DESC
LIMIT 10;
------------------
Analyze the sales performance of each product category across different regions, considering the impact of seasonal fluctuations and promotions.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "sales_tax_rate", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"},
            {"name": "discount", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "promotions",
        "columns": [
            {"name": "promotion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "discount", "type": "DECIMAL(5, 2)"}
        ]
    }
]
Response:
SELECT 
  p.category, 
  o.region, 
  SUM(oi.quantity * oi.unit_price) AS total_sales, 
  SUM(oi.quantity * oi.unit_price * p.sales_tax_rate / 100) AS total_sales_with_tax, 
  SUM(CASE WHEN p.product_id IN (SELECT product_id FROM promotions WHERE start_date <= o.order_date AND end_date >= o.order_date) THEN oi.quantity * oi.unit_price * (1 - p.sales_tax_rate / 100) END) AS total_sales_with_promotions
FROM 
  products p 
  JOIN order_items oi ON p.product_id = oi.product_id 
  JOIN orders o ON oi.order_id = o.order_id 
GROUP BY 
  p.category, 
  o.region
------------------
Develop a recommendation system for customers based on their purchase history and browsing behavior. Identify the top 5 products that each customer is likely to purchase next, considering the products they have previously purchased and the products they have browsed.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "browsing_history",
        "columns": [
            {"name": "browsing_history_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "browsing_date", "type": "DATE"}
        ]
    }
]
Response:
WITH customer_products AS (
  SELECT customer_id, product_id
  FROM order_items
  UNION ALL
  SELECT customer_id, product_id
  FROM browsing_history
)
, customer_product_counts AS (
  SELECT customer_id, product_id, COUNT(*) AS count
  FROM customer_products
  GROUP BY customer_id, product_id
)
, top_products AS (
  SELECT customer_id, product_id, count
  FROM customer_product_counts
  ORDER BY customer_id, count DESC
  LIMIT 1 OFFSET 0
)
SELECT p.product_name
FROM top_products tp
JOIN products p ON tp.product_id = p.product_id
JOIN (
  SELECT customer_id, ROW_NUMBER() OVER (PARTITION BY customer_id ORDER BY count DESC) AS row_num
  FROM (
    SELECT customer_id, COUNT(*) AS count
    FROM customer_product_counts
    GROUP BY customer_id
  ) AS subquery
) sub ON sub.customer_id = tp.customer_id AND sub.row_num = 5
GROUP BY p.product_name
------------------
Conduct a market analysis to identify the top 5 product categories with the highest profit margins across all regions, considering the prices, sales tax rates, and discounts applied to each product.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "sales_tax_rate", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"},
            {"name": "discount", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "tax_rate", "type": "DECIMAL(5, 2)"}
        ]
    }
]
Response:
SELECT 
    p.category,
    SUM((oi.unit_price * (1 + p.sales_tax_rate) * (1 - oi.discount)) * oi.quantity) / 
    SUM(oi.quantity) AS profit_margin
FROM 
    products p
JOIN 
    order_items oi ON p.product_id = oi.product_id
JOIN 
    orders o ON oi.order_id = o.order_id
JOIN 
    regions r ON o.region = r.region_name
GROUP BY 
    p.category
ORDER BY 
    profit_margin DESC
LIMIT 5
------------------
**Analyzing Sales Performance across Regions and Product Categories**

Develop a SQL query to extract the total sales revenue for each region and product category, along with the percentage of sales revenue contributed by each category within each region, and the top 3 regions with the highest average sales revenue per product category.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES countries(country_id)"]}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "product_group_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_groups(product_group_id)"]}
        ]
    },
    {
        "name": "product_groups",
        "columns": [
            {"name": "product_group_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "group_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  pc.category_name, 
  SUM(s.revenue) total_sales, 
  ROUND(SUM(s.revenue) * 100.0 / SUM(CASE WHEN r.region_id = s.region_id THEN s.revenue ELSE 0 END) / COUNT(DISTINCT s.region_id), 2) percentage_sales
FROM 
  sales s
  JOIN regions r ON s.region_id = r.region_id
  JOIN product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY 
  r.region_name, 
  pc.category_name
ORDER BY 
  total_sales DESC;
  
SELECT 
  r.region_name, 
  pc.category_name, 
  AVG(s.revenue) average_sales
FROM 
  sales s
  JOIN regions r ON s.region_id = r.region_id
  JOIN product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY 
  r.region_name, 
  pc.category_name
ORDER BY 
  average_sales DESC
LIMIT 3;
------------------
**Identifying High-Risk Customers for Churn Prevention**

Develop a SQL query to identify high-risk customers who are likely to churn within the next 30 days, based on their past purchase history, payment patterns, and demographic information. The query should return the customer ID, name, email, and a risk score calculated using a weighted combination of the following factors: average order value, order frequency, and payment latency.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "demographics_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES demographics(demographics_id)"]}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographics_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "payment_amount", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id,
  c.name,
  c.email,
  (0.4 * AVG(o.total_amount) + 0.3 * COUNT(o.order_id) + 0.3 * AVG(TIMESTAMPDIFF(DAY, o.order_date, p.payment_date))) AS risk_score
FROM 
  customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN payments p ON o.order_id = p.order_id
WHERE 
  p.payment_date >= DATE_SUB(CURRENT_DATE, INTERVAL 30 DAY)
GROUP BY 
  c.customer_id, c.name, c.email
------------------
**Optimizing Inventory Management for a Retail Business**

Develop a SQL query to analyze the sales data for a retail business and identify the top 5 products with the lowest stock levels, along with the total sales revenue and average sales quantity for each product. The query should also return the top 3 regions with the highest sales revenue for each of the top 5 products.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]}
        ]
    },
    {
        "name": "categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(s.revenue) AS total_revenue, AVG(s.quantity) AS avg_quantity, r.region_name
FROM sales s
JOIN products p ON s.product_id = p.product_id
JOIN regions r ON s.region_id = r.region_id
GROUP BY p.product_name, r.region_name
HAVING p.product_name IN (
    SELECT p.product_name
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    GROUP BY p.product_name
    ORDER BY SUM(s.quantity) ASC
    LIMIT 5
)
AND r.region_name IN (
    SELECT r.region_name
    FROM sales s
    JOIN products p ON s.product_id = p.product_id
    JOIN regions r ON s.region_id = r.region_id
    GROUP BY r.region_name, p.product_name
    ORDER BY r.region_name, SUM(s.revenue) DESC
    LIMIT 3
)
ORDER BY p.product_name, r.region_name
------------------
**Analyzing Customer Purchase Behavior and Loyalty**

Develop a SQL query to analyze the purchase behavior and loyalty of customers, including the average order value, order frequency, and repeat purchase rate for each customer. The query should also return the top 3 customer segments with the highest average order value and the top 3 product categories with the highest repeat purchase rate.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "segment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customer_segments(segment_id)"]}
        ]
    },
    {
        "name": "customer_segments",
        "columns": [
            {"name": "segment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "segment_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.segment_id, 
    AVG(o.total_amount) AS avg_order_value, 
    COUNT(o.order_id) AS order_frequency, 
    COUNT(DISTINCT o.order_id) / (SELECT AVG(order_frequency) FROM (SELECT customer_id, COUNT(order_id) AS order_frequency FROM orders GROUP BY customer_id)) AS repeat_purchase_rate
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
GROUP BY 
    c.customer_id, c.name, c.segment_id
ORDER BY 
    avg_order_value DESC

SELECT 
    cs.segment_name, 
    AVG(avg_order_value) AS avg_order_value
FROM 
    (
    SELECT 
        c.customer_id, 
        c.name, 
        c.segment_id, 
        AVG(o.total_amount) AS avg_order_value
    FROM 
        customers c
    JOIN 
        orders o ON c.customer_id = o.customer_id
    GROUP BY 
        c.customer_id, c.name, c.segment_id
    ) AS subquery
JOIN 
    customers c ON subquery.customer_id = c.customer_id
JOIN 
    customer_segments cs ON c.segment_id = cs.segment_id
GROUP BY 
    cs.segment_name
ORDER BY 
    avg_order_value DESC
LIMIT 3

SELECT 
    pc.category_name, 
    AVG(repeat_purchase_rate) AS repeat_purchase_rate
FROM 
    (
    SELECT 
        o.product_id, 
        COUNT(DISTINCT o.order_id) / (SELECT AVG(order_frequency) FROM (SELECT customer_id, COUNT(order_id) AS order_frequency FROM orders GROUP BY customer_id)) AS repeat_purchase_rate
    FROM 
        orders o
    JOIN 
        product_categories pc ON o.product_id = pc.product_id
    GROUP BY 
        o.product_id
    ) AS subquery
JOIN 
    product_categories pc ON subquery.product_id = pc.product_id
GROUP BY 
    pc.category_name
ORDER BY 
    repeat_purchase_rate DESC
LIMIT 3
------------------
**Sales Performance Analysis**

Analyze the sales performance of a retail company across different regions and product categories. Identify the top-performing products and regions, and calculate the total sales revenue for each region and product category.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10,2)"},
            {"name": "sales_date", "type": "DATE"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  r.region_name AS region, 
  pc.product_category_name AS category, 
  p.product_name AS product, 
  SUM(s.sales_amount) AS total_sales
FROM 
  sales s
JOIN 
  regions r ON s.region = r.region_name
JOIN 
  product_categories pc ON s.product_category = pc.product_category_name
GROUP BY 
  r.region_name, 
  pc.product_category_name, 
  p.product_name
ORDER BY 
  total_sales DESC
------------------
**Customer Segmentation**

Segment customers based on their purchase history and demographic information. Identify the top 10 most valuable customers, and analyze their purchase behavior across different product categories and sales channels.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, SUM(o.sales_amount) AS total_spent, COUNT(DISTINCT o.order_id) AS num_orders, 
       SUM(CASE WHEN o.product_category = 'Electronics' THEN o.sales_amount ELSE 0 END) AS electronics_spent,
       SUM(CASE WHEN o.product_category = 'Clothing' THEN o.sales_amount ELSE 0 END) AS clothing_spent,
       SUM(CASE WHEN o.sales_channel = 'Online' THEN o.sales_amount ELSE 0 END) AS online_spent,
       SUM(CASE WHEN o.sales_channel = 'Physical' THEN o.sales_amount ELSE 0 END) AS physical_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name, c.email
ORDER BY total_spent DESC
LIMIT 10;
------------------
**Inventory Management**

Analyze the inventory levels and sales trends for a retail company across different product categories and warehouses. Identify the top 5 products with the highest inventory levels, and calculate the inventory turnover rate for each product category.
Schema:
[
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_amount", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(i.quantity) AS total_inventory, 
       (SUM(s.sales_amount) / SUM(i.quantity)) * 12 AS inventory_turnover_rate
FROM inventory i
JOIN products p ON i.product_id = p.product_id
JOIN sales s ON i.product_id = s.product_id
GROUP BY p.product_name
ORDER BY total_inventory DESC
LIMIT 5;

SELECT 
  pc.category_name,
  SUM(i.quantity) AS total_inventory,
  (SUM(s.sales_amount) / SUM(i.quantity)) * 12 AS inventory_turnover_rate
FROM 
  inventory i
JOIN 
  products p ON i.product_id = p.product_id
JOIN 
  sales s ON i.product_id = s.product_id
JOIN 
  (
    SELECT 
      product_category_id, 
      category_name 
    FROM 
      product_categories
  ) pc ON p.product_category_id = pc.product_category_id
GROUP BY 
  pc.category_name
ORDER BY 
  total_inventory DESC
------------------
**Financial Forecasting**

Forecast the sales revenue for a retail company across different product categories and regions for the next quarter. Use historical sales data and seasonality analysis to make accurate predictions.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "さles_amount", "type": "DECIMAL(10,2)"},
            {"name": "sales_date", "type": "DATE"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "seasonality_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "seasonality_type", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  s.region, 
  s.product_category, 
  p.product_category_name, 
  r.region_name, 
  SUM(s.sales_amount) * (sales_amount_growth_rate + 1) AS forecasted_sales_amount
FROM 
  sales s
  JOIN product_categories p ON s.product_category = p.product_category_name
  JOIN regions r ON s.region = r.region_name
  JOIN (
    SELECT 
      sales_amount, 
      LAG(sales_amount, 1) OVER (ORDER BY sales_date) AS previous_sales_amount, 
      EXTRACT(MONTH FROM sales_date) AS sales_month
    FROM 
      sales
  ) AS subquery ON s.sales_amount = subquery.sales_amount
WHERE 
  s.sales_date BETWEEN (CURRENT_DATE - INTERVAL 1 QUARTER) AND CURRENT_DATE
GROUP BY 
  s.region, 
  s.product_category, 
  p.product_category_name, 
  r.region_name
------------------
**Customer Churn Prediction**

Predict the likelihood of customer churn for a subscription-based company based on their purchase history and demographic information. Use machine learning algorithms and feature engineering to identify key drivers of churn.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "churn_data",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT churn_data.churn_date, customers.name, customers.email, customers.age, customers.gender, COUNT(orders.order_id) as orders_count, SUM(orders.sales_amount) as total_sales 
FROM customers 
LEFT JOIN orders ON customers.customer_id = orders.customer_id 
LEFT JOIN churn_data ON customers.customer_id = churn_data.customer_id 
GROUP BY customers.name, customers.email, customers.age, customers.gender 
HAVING COUNT(orders.order_id) > 0 AND churn_data.churn_date IS NOT NULL
------------------
**Supply Chain Optimization**

Analyze the supply chain operations of a retail company across different warehouses and transportation modes. Identify the top 5 suppliers with the highest delivery frequency, and calculate the average delivery time for each supplier.
Schema:
[
    {
        "name": "suppliers",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "supplier_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "delivery_data",
        "columns": [
            {"name": "delivery_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "supplier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES suppliers(supplier_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "delivery_date", "type": "DATE"},
            {"name": "delivery_time", "type": "TIME"}
        ]
    }
]
Response:
SELECT s.supplier_name, COUNT(dd.delivery_id) AS delivery_frequency, AVG(HOUR(dd.delivery_time)) AS average_delivery_time
FROM suppliers s
JOIN delivery_data dd ON s.supplier_id = dd.supplier_id
GROUP BY s.supplier_name
ORDER BY delivery_frequency DESC
LIMIT 5
------------------
**Time-Series Analysis for Stock Market Prediction**
Develop a SQL query to predict the future stock prices of Apple, Amazon, and Google based on their historical stock prices from the past 5 years. The query should take into account the seasonality of the stock prices and use a combination of moving averages and regression analysis to make predictions.
Schema:
[
  {
    "name": "stock_prices",
    "columns": [
      {"name": "symbol", "type": "VARCHAR(10)"}, 
      {"name": "date", "type": "DATE"}, 
      {"name": "open", "type": "DECIMAL(10, 2)"}, 
      {"name": "high", "type": "DECIMAL(10, 2)"}, 
      {"name": "low", "type": "DECIMAL(10, 2)"}, 
      {"name": "close", "type": "DECIMAL(10, 2)"}, 
      {"name": "volume", "type": "INT"}
    ]
  },
  {
    "name": "moving_averages",
    "columns": [
      {"name": "symbol", "type": "VARCHAR(10)"}, 
      {"name": "date", "type": "DATE"}, 
      {"name": "short_ma", "type": "DECIMAL(10, 2)"}, 
      {"name": "long_ma", "type": "DECIMAL(10, 2)"}
    ]
  }
]
Response:
WITH 
  historical_stock_prices AS (
    SELECT 
      symbol, 
      date, 
      open, 
      high, 
      low, 
      close, 
      volume
    FROM 
      stock_prices
    WHERE 
      symbol IN ('AAPL', 'AMZN', 'GOOG') 
      AND date >= DATE('now', '-5 years')
  ),
  moving_avg AS (
    SELECT 
      symbol, 
      date, 
      AVG(open) OVER (PARTITION BY symbol ORDER BY date ROWS 20 PRECEDING) AS short_ma,
      AVG(open) OVER (PARTITION BY symbol ORDER BY date ROWS 100 PRECEDING) AS long_ma
    FROM 
      historical_stock_prices
  ),
  regression_model AS (
    SELECT 
      symbol, 
      date, 
      open, 
      high, 
      low, 
      close, 
      volume,
      short_ma,
      long_ma
    FROM 
      historical_stock_prices
    CROSS JOIN 
      moving_avg
  ),
  predicted_stock_prices AS (
    SELECT 
      symbol, 
      date, 
      open, 
      high, 
      low, 
      close, 
      volume,
      short_ma,
      long_ma,
      close + 0.1 * (short_ma - close) + 0.2 * (long_ma - close) AS predicted_close
    FROM 
      regression_model
  )
SELECT 
  symbol, 
  date, 
  open, 
  high, 
  low, 
  predicted_close, 
  volume
FROM 
  predicted_stock_prices
WHERE 
  date >= DATE('now', '-5 years')
------------------
**Customer Segmentation for E-commerce**
Develop a SQL query to segment customers based on their purchasing behavior and demographics. The query should take into account the customer's age, location, purchase history, and order frequency to identify high-value customers and create a customer segmentation model.
Schema:
[
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "name", "type": "VARCHAR(255)"}, 
      {"name": "email", "type": "VARCHAR(255)"}, 
      {"name": "age", "type": "INT"}, 
      {"name": "location", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "orders",
    "columns": [
      {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}, 
      {"name": "order_date", "type": "DATE"}, 
      {"name": "order_total", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "order_items",
    "columns": [
      {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]}, 
      {"name": "product_id", "type": "INT"}, 
      {"name": "quantity", "type": "INT"}
    ]
  }
]
Response:
SELECT c.customer_id, c.name, c.email, c.age, c.location, COUNT(o.order_id) as order_count, SUM(o.order_total) as total_spent 
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id 
GROUP BY c.customer_id, c.name, c.email, c.age, c.location 
HAVING SUM(o.order_total) > 1000 OR (SUM(o.order_total) IS NULL AND COUNT(o.order_id) > 5)
------------------
**Inventory Management for Retail**
Develop a SQL query to analyze the inventory levels of a retail store and identify slow-moving and fast-selling products. The query should take into account the product's category, subcategory, and supplier to identify opportunities for inventory optimization.
Schema:
[
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "category", "type": "VARCHAR(255)"}, 
      {"name": "subcategory", "type": "VARCHAR(255)"}, 
      {"name": "supplier", "type": "VARCHAR(255)"}, 
      {"name": "unit_price", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "inventory",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}, 
      {"name": "store_id", "type": "INT"}, 
      {"name": "quantity", "type": "INT"}, 
      {"name": "reorder_point", "type": "INT"}
    ]
  },
  {
    "name": "sales",
    "columns": [
      {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}, 
      {"name": "sale_date", "type": "DATE"}, 
      {"name": "quantity_sold", "type": "INT"}
    ]
  }
]
Response:
SELECT p.category, p.subcategory, p.supplier, 
       SUM(i.quantity) AS total_quantity, 
       SUM(s.quantity_sold) AS total_sold, 
       SUM(i.quantity) - SUM(s.quantity_sold) AS remaining_stock
FROM products p
JOIN inventory i ON p.product_id = i.product_id
JOIN sales s ON p.product_id = s.product_id
GROUP BY p.category, p.subcategory, p.supplier
HAVING SUM(i.quantity) - SUM(s.quantity_sold) < (SELECT AVG(reorder_point) FROM inventory)
------------------
**Network Analysis for Social Media**
Develop a SQL query to analyze the social media network of a company and identify influential users. The query should take into account the user's followers, following, and engagement metrics to identify key opinion leaders and brand ambassadors.
Schema:
[
  {
    "name": "users",
    "columns": [
      {"name": "user_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "username", "type": "VARCHAR(255)"}, 
      {"name": "email", "type": "VARCHAR(255)"}, 
      {"name": " follower_count", "type": "INT"}, 
      {"name": "following_count", "type": "INT"}
    ]
  },
  {
    "name": "posts",
    "columns": [
      {"name": "post_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "user_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES users(user_id)"]}, 
      {"name": "post_date", "type": "DATE"}, 
      {"name": "engagement", "type": "INT"}
    ]
  },
  {
    "name": "likes",
    "columns": [
      {"name": "like_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "post_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES posts(post_id)"]}, 
      {"name": "user_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES users(user_id)"]}
    ]
  }
]
Response:
SELECT u.username, u.follower_count, u.following_count, p.engagement 
FROM users u 
JOIN posts p ON u.user_id = p.user_id 
WHERE u.follower_count > (SELECT AVG(follower_count) FROM users) 
ORDER BY p.engagement DESC
------------------
**Predictive Maintenance for Manufacturing**
Develop a SQL query to predict the likelihood of equipment failure in a manufacturing plant based on historical maintenance data and equipment performance metrics. The query should take into account the equipment's age, usage patterns, and maintenance history to identify high-risk equipment and schedule preventive maintenance.
Schema:
[
  {
    "name": "equipment",
    "columns": [
      {"name": "equipment_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "equipment_name", "type": "VARCHAR(255)"}, 
      {"name": "age", "type": "INT"}, 
      {"name": "usage_hours", "type": "INT"}
    ]
  },
  {
    "name": "maintenance",
    "columns": [
      {"name": "maintenance_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "equipment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES equipment(equipment_id)"]}, 
      {"name": "maintenance_date", "type": "DATE"}, 
      {"name": "maintenance_type", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "performance_metrics",
    "columns": [
      {"name": "metric_id", "type": "INT", "constraints": ["PRIMARY KEY"]}, 
      {"name": "equipment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES equipment(equipment_id)"]}, 
      {"name": "metric_name", "type": "VARCHAR(255)"}, 
      {"name": "metric_value", "type": "DECIMAL(10, 2)"}
    ]
  }
]
Response:
SELECT e.equipment_id, e.equipment_name, e.age, e.usage_hours 
FROM equipment e 
JOIN maintenance m ON e.equipment_id = m.equipment_id 
JOIN performance_metrics pm ON e.equipment_id = pm.equipment_id 
WHERE e.usage_hours > (SELECT AVG(usage_hours) FROM equipment) 
AND pm.metric_value < (SELECT AVG(metric_value) FROM performance_metrics) 
ORDER BY e.age DESC, e.usage_hours DESC;
------------------
**Financial Forecasting and Market Analysis**

Develop a SQL query to generate a 6-month sales forecast for a retail company, considering historical sales trends, seasonal fluctuations, and regional market variations. The query should account for the following:

*   Calculate the average monthly sales for each product category in the past three years.
*   Identify the top-performing product categories in the past year.
*   Determine the average sales growth rate for each region (North, South, East, West) over the past two years.
*   Generate a 6-month sales forecast for each product category, considering the historical average sales, seasonal fluctuations, and regional market growth rates.
Schema:
[
    {
        "name": "sales_data",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  pc.product_category_name, 
  AVG(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = 2022 THEN s.amount ELSE 0 END) AS avg_2022,
  AVG(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = 2023 THEN s.amount ELSE 0 END) AS avg_2023,
  AVG(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = 2024 THEN s.amount ELSE 0 END) AS avg_2024
FROM 
  sales_data s
JOIN 
  product_categories pc ON s.product_category = pc.product_category_name
GROUP BY 
  pc.product_category_name
ORDER BY 
  avg_2023 DESC;

WITH top_product_categories AS (
  SELECT 
    product_category_name, 
    SUM(amount) AS total_amount
  FROM 
    sales_data
  WHERE 
    sale_date >= DATE('2022-01-01') AND sale_date < DATE('2023-01-01')
  GROUP BY 
    product_category_name
),
avg_growth_rate AS (
  SELECT 
    r.region_name, 
    AVG(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = 2023 THEN s.amount ELSE 0 END) - 
    AVG(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = 2022 THEN s.amount ELSE 0 END) AS growth_rate
  FROM 
    sales_data s
  JOIN 
    regions r ON s.region = r.region_name
  GROUP BY 
    r.region_name
),
forecast AS (
  SELECT 
    pc.product_category_name, 
    r.region_name, 
    s.sale_date,
    (SUM(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = 2022 THEN s.amount ELSE 0 END) + 
     SUM(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = 2023 THEN s.amount ELSE 0 END) * 
     1.1 * (g.growth_rate * 0.01)) AS forecasted_amount
  FROM 
    sales_data s
  JOIN 
    product_categories pc ON s.product_category = pc.product_category_name
  JOIN 
    top_product_categories tp ON pc.product_category_name = tp.product_category_name
  JOIN 
    avg_growth_rate g ON (SELECT region_name FROM regions LIMIT 1)
  JOIN 
    regions r ON s.region = r.region_name
  GROUP BY 
    pc.product_category_name, 
    r.region_name, 
    s.sale_date
)
SELECT 
  product_category_name, 
  region_name, 
  sale_date, 
  forecasted_amount
FROM 
  forecast;
------------------
**Customer Segmentation and Churn Analysis**

Develop a SQL query to identify high-value customers for a telecom company, based on their purchase history, plan type, and billing location. The query should account for the following:

*   Calculate the total revenue generated by each customer in the past year.
*   Identify the top 10% of customers with the highest total revenue.
*   Determine the average monthly revenue for each customer segment (based on plan type and billing location).
*   Identify customers who have churned in the past 6 months and their corresponding reasons for churning.
Schema:
[
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "plan_type", "type": "VARCHAR(255)"},
            {"name": "billing_location", "type": "VARCHAR(255)"},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "purchase_date", "type": "DATE"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone_number", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "churn_reasons",
        "columns": [
            {"name": "churn_reason_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.phone_number,
    c.plan_type,
    c.billing_location,
    SUM(cp.amount) AS total_revenue,
    AVG(cp.amount) / 12 AS avg_monthly_revenue
FROM 
    customers c
JOIN 
    customer_purchases cp ON c.customer_id = cp.customer_id
WHERE 
    cp.purchase_date >= DATE('now', '-1 year')
GROUP BY 
    c.customer_id, c.name, c.email, c.phone_number;
    
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.phone_number,
    c.plan_type,
    c.billing_location,
    SUM(cp.amount) AS total_revenue
FROM 
    customers c
JOIN 
    customer_purchases cp ON c.customer_id = cp.customer_id
WHERE 
    cp.purchase_date >= DATE('now', '-1 year')
GROUP BY 
    c.customer_id, c.name, c.email, c.phone_number
ORDER BY 
    total_revenue DESC
LIMIT 
    (SELECT 
         COUNT(*) * 0.1
     FROM 
         customers);
    
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.phone_number,
    cr.reason,
    cr.churn_date,
    c.plan_type,
    c.billing_location
FROM 
    customers c
JOIN 
    churn_reasons cr ON c.customer_id = cr.customer_id
WHERE 
    cr.churn_date >= DATE('now', '-6 months');
------------------
**Inventory Management and Supply Chain Optimization**

Develop a SQL query to analyze inventory levels, supplier performance, and product demand for an e-commerce company. The query should account for the following:

*   Calculate the average inventory level for each product category over the past quarter.
*   Identify the top 5 suppliers with the highest inventory fill rate (percentage of orders fulfilled on time).
*   Determine the average lead time for each supplier (time between order placement and delivery).
*   Identify products with a demand-supply mismatch (demand exceeding supply) and suggest potential suppliers to address the gap.
Schema:
[
    {
        "name": "inventory_levels",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "supplier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES suppliers(supplier_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "date", "type": "DATE"}
        ]
    },
    {
        "name": "suppliers",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "supplier_name", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "supplier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES suppliers(supplier_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "order_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    category, 
    AVG(quantity) AS avg_inventory_level
FROM 
    inventory_levels
WHERE 
    date >= DATE('now', '-3 months')
GROUP BY 
    category

SELECT 
    s.supplier_id, 
    s.supplier_name, 
    (
        SELECT 
            COUNT(DISTINCT order_id) 
        FROM 
            product_orders
        WHERE 
            supplier_id = s.supplier_id AND order_date >= DATE('now', '-3 months') AND quantity > 0
    ) AS total_orders,
    (
        SELECT 
            COUNT(DISTINCT order_id) 
        FROM 
            product_orders
        WHERE 
            supplier_id = s.supplier_id AND order_date >= DATE('now', '-3 months') AND quantity > 0
    ) * 1.0 / (
        SELECT 
            COUNT(DISTINCT order_id) 
        FROM 
            product_orders
        WHERE 
            supplier_id = s.supplier_id AND order_date >= DATE('now', '-3 months')
    ) AS inventory_fill_rate
FROM 
    suppliers s
ORDER BY 
    inventory_fill_rate DESC
LIMIT 5

SELECT 
    supplier_id, 
    AVG(EXTRACT(EPOCH FROM (
        SELECT 
            date AS lead_time
        FROM 
            inventory_levels
        WHERE 
            supplier_id = i.supplier_id
        AND 
            date >= DATE('now', '-3 months')
        ORDER BY 
            date
        LIMIT 1
    )) - EXTRACT(EPOCH FROM (
        SELECT 
            date AS lead_time
        FROM 
            inventory_levels
        WHERE 
            supplier_id = i.supplier_id
        AND 
            date >= DATE('now', '-3 months')
        ORDER BY 
            date DESC
        LIMIT 1
    ))) AS avg_lead_time
FROM 
    inventory_levels i
GROUP BY 
    supplier_id

SELECT 
    product_category, 
    AVG(quantity) AS avg_demand
FROM 
    product_orders
WHERE 
    order_date >= DATE('now', '-3 months')
GROUP BY 
    product_category

SELECT 
    p.product_category, 
    s.supplier_id, 
    s.supplier_name
FROM 
    product_orders p
JOIN 
    suppliers s ON p.supplier_id = s.supplier_id
WHERE 
    p.quantity > (SELECT 
        AVG(quantity) 
    FROM 
        product_orders
    WHERE 
        product_category = p.product_category AND order_date >= DATE('now', '-3 months'))
------------------
**Time-Series Analysis and Forecasting**

Develop a SQL query to analyze and forecast sales trends for a retail company, considering historical sales data, seasonal fluctuations, and regional market variations. The query should account for the following:

*   Calculate the average monthly sales for each product category over the past three years.
*   Identify the top 3 product categories with the highest average monthly sales.
*   Determine the average sales growth rate for each region (North, South, East, West) over the past two years.
*   Generate a 6-month sales forecast for each product category, considering the historical average sales, seasonal fluctuations, and regional market growth rates.
Schema:
[
    {
        "name": "sales_data",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    p.product_category_name, 
    AVG(s.amount) AS avg_monthly_sales, 
    ROW_NUMBER() OVER (ORDER BY AVG(s.amount) DESC) AS sales_rank
FROM 
    sales_data s
JOIN 
    product_categories p ON s.product_category = p.product_category_name
GROUP BY 
    p.product_category_name
ORDER BY 
    avg_monthly_sales DESC
LIMIT 3;

SELECT 
    r.region_name, 
    AVG(s.amount) AS avg_sales_growth_rate
FROM 
    sales_data s
JOIN 
    regions r ON s.region = r.region_name
WHERE 
    s.sale_date >= DATE('now', '-2 years')
GROUP BY 
    r.region_name
ORDER BY 
    avg_sales_growth_rate DESC;

WITH 
    historical_sales AS (
        SELECT 
            p.product_category_name, 
            AVG(s.amount) AS avg_historical_sales
        FROM 
            sales_data s
        JOIN 
            product_categories p ON s.product_category = p.product_category_name
        WHERE 
            s.sale_date >= DATE('now', '-3 years')
        GROUP BY 
            p.product_category_name
    ),
    seasonal_fluctuations AS (
        SELECT 
            p.product_category_name, 
            AVG(s.amount) AS avg_seasonal_sales
        FROM 
            sales_data s
        JOIN 
            product_categories p ON s.product_category = p.product_category_name
        WHERE 
            s.sale_date >= DATE('now', '-2 years')
        GROUP BY 
            p.product_category_name
    ),
    regional_market_growth AS (
        SELECT 
            r.region_name, 
            AVG(s.amount) AS avg_regional_growth_rate
        FROM 
            sales_data s
        JOIN 
            regions r ON s.region = r.region_name
        WHERE 
            s.sale_date >= DATE('now', '-2 years')
        GROUP BY 
            r.region_name
    )
SELECT 
    h.product_category_name, 
    6 * (h.avg_historical_sales + s.avg_seasonal_sales + r.avg_regional_growth_rate) AS forecast_sales
FROM 
    historical_sales h
JOIN 
    seasonal_fluctuations s ON h.product_category_name = s.product_category_name
JOIN 
    regional_market_growth r ON h.product_category_name = r.region_name
------------------
**Marketing Campaign Effectiveness Analysis**

Develop a SQL query to measure the effectiveness of a marketing campaign for a tech company, considering customer acquisition costs, conversion rates, and return on investment (ROI). The query should account for the following:

*   Calculate the total customer acquisition cost for each marketing channel (email, social media, paid advertising) over the past quarter.
*   Identify the top 3 marketing channels with the highest conversion rates.
*   Determine the average ROI for each marketing channel over the past year.
*   Generate a report comparing the effectiveness of each marketing channel, including customer acquisition costs, conversion rates, and ROI.
Schema:
[
    {
        "name": "customer_acquisition",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "marketing_channel", "type": "VARCHAR(255)"},
            {"name": "cost", "type": "DECIMAL(10, 2)"},
            {"name": "conversion_date", "type": "DATE"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone_number", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "marketing_channels",
        "columns": [
            {"name": "marketing_channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "marketing_channel_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    mc.marketing_channel_name,
    SUM(cac.cost) AS total_customer_acquisition_cost,
    COUNT(*) AS total_conversions,
    COUNT(*) / (SELECT SUM(cost) / COUNT(*) FROM customer_acquisition) AS conversion_rate,
    (COUNT(*) / (SELECT SUM(cost) / COUNT(*) FROM customer_acquisition)) * (SELECT SUM(cost) / COUNT(*) FROM customer_acquisition) AS roi
FROM 
    customer_acquisition cac
JOIN 
    marketing_channels mc ON cac.marketing_channel = mc.marketing_channel_name
WHERE 
    cac.conversion_date >= DATE('now', '-3 month')
GROUP BY 
    mc.marketing_channel_name
ORDER BY 
    conversion_rate DESC
LIMIT 3

UNION ALL

SELECT 
    marketing_channel_name,
    0 AS total_customer_acquisition_cost,
    0 AS total_conversions,
    0 AS conversion_rate,
    0 AS roi
FROM 
    marketing_channels
WHERE 
    marketing_channel_name NOT IN (SELECT marketing_channel FROM customer_acquisition)

UNION ALL

SELECT 
    marketing_channel_name,
    SUM(cac.cost) AS total_customer_acquisition_cost,
    COUNT(*) AS total_conversions,
    COUNT(*) / (SELECT SUM(cost) / COUNT(*) FROM customer_acquisition) AS conversion_rate,
    (COUNT(*) / (SELECT SUM(cost) / COUNT(*) FROM customer_acquisition)) * (SELECT SUM(cost) / COUNT(*) FROM customer_acquisition) AS roi
FROM 
    customer_acquisition cac
JOIN 
    marketing_channels mc ON cac.marketing_channel = mc.marketing_channel_name
GROUP BY 
    mc.marketing_channel_name
------------------
**Supply Chain Optimization and Risk Analysis**

Develop a SQL query to analyze and optimize the supply chain for a manufacturing company, considering supplier performance, inventory levels, and product demand. The query should account for the following:

*   Calculate the average inventory level for each product category over the past quarter.
*   Identify the top 5 suppliers with the highest inventory fill rate (percentage of orders fulfilled on time).
*   Determine the average lead time for each supplier (time between order placement and delivery).
*   Identify products with a demand-supply mismatch (demand exceeding supply) and suggest potential suppliers to address the gap.
Schema:
[
    {
        "name": "inventory_levels",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "supplier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES suppliers(supplier_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "date", "type": "DATE"}
        ]
    },
    {
        "name": "suppliers",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "supplier_name", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "supplier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES suppliers(supplier_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "order_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    product_category, 
    AVG(quantity) AS average_inventory_level
FROM 
    inventory_levels
WHERE 
    date > (SELECT (CURRENT_DATE - INTERVAL 3 MONTH))
GROUP BY 
    product_category

SELECT 
    s.supplier_name, 
    i.quantity / o.quantity AS inventory_fill_rate
FROM 
    suppliers s
JOIN 
    inventory_levels i ON s.supplier_id = i.supplier_id
JOIN 
    product_orders o ON s.supplier_id = o.supplier_id AND i.date = o.order_date
GROUP BY 
    s.supplier_name
ORDER BY 
    inventory_fill_rate DESC
LIMIT 5

SELECT 
    s.supplier_name, 
    AVG(i.quantity - o.quantity) AS average_lead_time
FROM 
    suppliers s
JOIN 
    inventory_levels i ON s.supplier_id = i.supplier_id
JOIN 
    product_orders o ON s.supplier_id = o.supplier_id AND i.date = o.order_date
GROUP BY 
    s.supplier_name

SELECT 
    p.product_category, 
    p.quantity, 
    i.quantity AS available_quantity
FROM 
    product_orders p
JOIN 
    inventory_levels i ON p.product_category = i.product_category AND p.order_date < i.date
WHERE 
    p.quantity > i.quantity
------------------
Analyze sales trends and forecast future revenue for a retail company across different product categories.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"},
            {"name": "sales_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_forecast",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "forecast_date", "type": "DATE"},
            {"name": "forecast_revenue", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  p.product_category,
  SUM(o.quantity * p.sales_price) AS total_revenue,
  ROUND(AVG(o.quantity * p.sales_price), 2) AS average_monthly_revenue,
  ROUND(COUNT(o.order_id) * 0.2, 2) AS forecasted_revenue
FROM orders o
JOIN products p ON o.product_id = p.product_id
GROUP BY p.product_category
ORDER BY total_revenue DESC;
------------------
Identify the most profitable customers for a telecom company based on their usage patterns and churn rates.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "minutes_used", "type": "INT"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    },
    {
        "name": "revenue",
        "columns": [
            {"name": "revenue_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "revenue_date", "type": "DATE"},
            {"name": "revenue_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, SUM(u.minutes_used) AS total_minutes, AVG(r.revenue_amount) AS average_revenue
FROM customers c
JOIN usage u ON c.customer_id = u.customer_id
JOIN revenue r ON c.customer_id = r.customer_id
LEFT JOIN churn ch ON c.customer_id = ch.customer_id
GROUP BY c.customer_id, c.name
HAVING SUM(u.minutes_used) > (SELECT AVG(minutes_used) FROM usage)
AND c.customer_id NOT IN (SELECT customer_id FROM churn WHERE churn_date > (SELECT MAX(churn_date) FROM churn) - INTERVAL 6 MONTH);

SELECT c.customer_id, c.name, SUM(u.minutes_used) AS total_minutes, AVG(r.revenue_amount) AS average_revenue
FROM customers c
JOIN usage u ON c.customer_id = u.customer_id
JOIN revenue r ON c.customer_id = r.customer_id
LEFT JOIN churn ch ON c.customer_id = ch.customer_id
WHERE c.customer_id NOT IN (SELECT customer_id FROM churn WHERE churn_date > (SELECT MAX(churn_date) FROM churn) - INTERVAL 6 MONTH)
GROUP BY c.customer_id, c.name
HAVING SUM(u.minutes_used) > (SELECT AVG(minutes_used) FROM usage);
------------------
Develop a data mart for a hospital to analyze patient outcomes based on their diagnoses, treatments, and age groups.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"}
        ]
    },
    {
        "name": "diagnoses",
        "columns": [
            {"name": "diagnosis_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "diagnosis_date", "type": "DATE"},
            {"name": "diagnosis_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "treatments",
        "columns": [
            {"name": "treatment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_date", "type": "DATE"},
            {"name": "treatment_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "outcomes",
        "columns": [
            {"name": "outcome_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "outcome_date", "type": "DATE"},
            {"name": "outcome_type", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
CREATE TABLE patient_outcomes AS
SELECT p.name, p.age, p.gender, d.diagnosis_date, d.diagnosis_type, t.treatment_date, t.treatment_type, o.outcome_date, o.outcome_type
FROM patients p
JOIN diagnoses d ON p.patient_id = d.patient_id
JOIN treatments t ON p.patient_id = t.patient_id
JOIN outcomes o ON p.patient_id = o.patient_id;

CREATE INDEX idx_patient_id ON patients(patient_id);
CREATE INDEX idx_diagnosis_id ON diagnoses(patient_id);
CREATE INDEX idx_treatment_id ON treatments(patient_id);
CREATE INDEX idx_outcome_id ON outcomes(patient_id);
------------------
**Identify the top 5 most profitable product categories for each region across the globe, considering the average order value, sales volume, and product profitability.**

**Business Problem:** Analyze the sales performance of various product categories across regions to inform regional marketing strategies, optimize product offerings, and make data-driven decisions.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "profit_margin", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "total_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    o.region, 
    p.category, 
    AVG(oi.quantity * oi.unit_price) AS average_order_value, 
    SUM(oi.quantity) AS sales_volume, 
    (AVG(oi.quantity * oi.unit_price) * p.profit_margin) / 100 AS product_profitability
FROM 
    orders o
INNER JOIN 
    order_items oi ON o.order_id = oi.order_id
INNER JOIN 
    products p ON oi.product_id = p.product_id
GROUP BY 
    o.region, 
    p.category
ORDER BY 
    o.region, 
    average_order_value DESC
LIMIT 5;
------------------
**Analyze the behavior of customers who have abandoned their shopping carts and predict which ones are likely to make a purchase in the next 30 days.**

**Business Problem:** Identify the most valuable customers who have abandoned their carts and prioritize them for targeted marketing campaigns to recover lost sales and improve customer retention.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "last_order_date", "type": "DATE"},
            {"name": "total_spend", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_status", "type": "VARCHAR(255)"},
            {"name": "total_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "cart_abandons",
        "columns": [
            {"name": "cart_abandon_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "cart_creation_date", "type": "DATE"},
            {"name": "abandon_date", "type": "DATE"}
        ]
    },
    {
        "name": "product_views",
        "columns": [
            {"name": "view_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "view_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, o.order_status, c.total_spend, ROUND((DATEDIFF('now', c.last_order_date) / 30.44), 2) AS days_since_last_order
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_status = 'Abandoned'
ORDER BY c.total_spend DESC
------------------
**Identify the top 10 most popular products among customers who have purchased products from both the electronics and home goods categories.**

**Business Problem:** Analyze the purchase behavior of customers who have shown interest in multiple product categories to inform product recommendations, optimize product offerings, and improve customer satisfaction.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "last_order_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.product_name, COUNT(DISTINCT o.customer_id) as customer_count
FROM products p
JOIN orders o ON p.product_id = o.product_id
WHERE p.category IN ('electronics', 'home goods')
GROUP BY p.product_name
ORDER BY customer_count DESC
LIMIT 10
------------------
Analyze customer churn and predict the likelihood of a customer leaving within the next 6 months based on their purchase history, demographic information, and interactions with customer support.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10,2)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10,2)"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "returns",
        "columns": [
            {"name": "return_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "return_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "support_interactions",
        "columns": [
            {"name": "interaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "interaction_date", "type": "DATE"},
            {"name": "issue_type", "type": "VARCHAR(255)"},
            {"name": "resolution", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_info",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.signup_date, 
    c.age, 
    c.income, 
    c.location, 
    AVG(o.total_amount) AS avg_order_value, 
    COUNT(r.return_id) AS num_returns, 
    SUM(CASE WHEN si.issue_type = 'complaint' THEN 1 ELSE 0 END) AS num_complaints, 
    SUM(CASE WHEN si.resolution = 'resolved' THEN 1 ELSE 0 END) AS num_resolved_issues, 
    CASE 
        WHEN DATEDIFF('day', c.signup_date, '2023-06-01') <= 183 THEN 1 ELSE 0 
    END AS is_eligible_for_analysis
FROM 
    customers c
LEFT JOIN 
    orders o ON c.customer_id = o.customer_id
LEFT JOIN 
    returns r ON o.order_id = r.order_id
LEFT JOIN 
    support_interactions si ON c.customer_id = si.customer_id
GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    c.signup_date, 
    c.age, 
    c.income, 
    c.location
HAVING 
    AVG(o.total_amount) > (SELECT AVG(total_amount) FROM orders) * 0.8
------------------
**Retail Sales Analysis with Customer Segmentation and Time-Series Forecasting**
Analyze the sales performance of a retail company across different regions, customer groups, and time periods. The goal is to identify the most profitable customer segments, forecast sales for the next quarter, and recommend targeted marketing strategies.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "segment", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "sales_forecast",
        "columns": [
            {"name": "forecast_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  C.name AS customer_name,
  C.region AS region,
  C.segment AS customer_segment,
  SUM(O.order_total) AS total_sales,
  SUM(SF.order_total) AS forecast_sales
FROM 
  customers C
  JOIN orders O ON C.customer_id = O.customer_id
  LEFT JOIN sales_forecast SF ON C.customer_id = SF.customer_id AND O.order_date = SF.order_date
GROUP BY 
  C.name, C.region, C.segment
ORDER BY 
  total_sales DESC;
------------------
**Financial Analysis with Complex Joins and Subqueries**
Analyze the financial performance of a company across different departments, employees, and projects. The goal is to identify the most profitable departments, top-performing employees, and the most expensive projects.
Schema:
[
    {
        "name": "departments",
        "columns": [
            {"name": "department_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "department_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_name", "type": "VARCHAR(255)"},
            {"name": "department_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES departments(department_id)"]}
        ]
    },
    {
        "name": "projects",
        "columns": [
            {"name": "project_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "project_name", "type": "VARCHAR(255)"},
            {"name": "department_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES departments(department_id)"]}
        ]
    },
    {
        "name": "expenses",
        "columns": [
            {"name": "expense_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "project_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES projects(project_id)"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "expense_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    d.department_name, 
    e.employee_name, 
    p.project_name, 
    SUM(E.expense_amount) AS total_expense
FROM 
    expenses E
INNER JOIN 
    projects P ON E.project_id = P.project_id
INNER JOIN 
    employees E2 ON E.employee_id = E2.employee_id
INNER JOIN 
    departments D ON E2.department_id = D.department_id
GROUP BY 
    d.department_name, 
    e.employee_name, 
    p.project_name
ORDER BY 
    total_expense DESC;

WITH most_profitable_departments AS (
    SELECT 
        D.department_name, 
        SUM(E.expense_amount) AS total_expense
    FROM 
        expenses E
    INNER JOIN 
        projects P ON E.project_id = P.project_id
    INNER JOIN 
        employees E2 ON E.employee_id = E2.employee_id
    INNER JOIN 
        departments D ON E2.department_id = D.department_id
    GROUP BY 
        D.department_name
), 
top_performing_employees AS (
    SELECT 
        E2.employee_name, 
        SUM(E.expense_amount) AS total_expense
    FROM 
        expenses E
    INNER JOIN 
        projects P ON E.project_id = P.project_id
    INNER JOIN 
        employees E2 ON E.employee_id = E2.employee_id
    GROUP BY 
        E2.employee_name
), 
most_expensive_projects AS (
    SELECT 
        P.project_name, 
        SUM(E.expense_amount) AS total_expense
    FROM 
        expenses E
    INNER JOIN 
        projects P ON E.project_id = P.project_id
    GROUP BY 
        P.project_name
)
SELECT 
    *
FROM 
    most_profitable_departments
UNION ALL
SELECT 
    *
FROM 
    top_performing_employees
UNION ALL
SELECT 
    *
FROM 
    most_expensive_projects
------------------
**Healthcare Patient Outcomes with Window Functions and CTEs**
Analyze the patient outcomes of a hospital across different departments, patients, and time periods. The goal is to identify the top-performing departments, patients with the highest recovery rates, and the most common complications.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_name", "type": "VARCHAR(255)"},
            {"name": "department_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES departments(department_id)"]}
        ]
    },
    {
        "name": "admissions",
        "columns": [
            {"name": "admission_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "admission_date", "type": "DATE"}
        ]
    },
    {
        "name": "outcomes",
        "columns": [
            {"name": "outcome_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "admission_date", "type": "DATE"},
            {"name": "recovery_rate", "type": "DECIMAL(10, 2)"},
            {"name": "complication", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "departments",
        "columns": [
            {"name": "department_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "department_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
WITH patient_outcomes AS (
  SELECT 
    p.patient_id,
    p.patient_name,
    d.department_name,
    o.admission_date,
    o.recovery_rate,
    o.complication
  FROM patients p
  JOIN admissions a ON p.patient_id = a.patient_id
  JOIN outcomes o ON a.admission_id = o.admission_id
  JOIN departments d ON p.department_id = d.department_id
),

department_ranking AS (
  SELECT 
    department_name,
    AVG(recovery_rate) AS avg_recovery_rate,
    ROW_NUMBER() OVER (PARTITION BY department_name ORDER BY AVG(recovery_rate) DESC) AS rank
  FROM patient_outcomes
  GROUP BY department_name
),

patient_recovery_rates AS (
  SELECT 
    patient_id,
    patient_name,
    AVG(recovery_rate) AS recovery_rate
  FROM patient_outcomes
  GROUP BY patient_id
),

complication_counts AS (
  SELECT 
    complication,
    COUNT(*) AS complication_count
  FROM patient_outcomes
  GROUP BY complication
)

SELECT 
  d.department_name,
  dr.rank,
  d.avg_recovery_rate,
  pr.patient_name,
  pr.recovery_rate,
  cc.complication,
  cc.complication_count
FROM patient_outcomes po
JOIN department_ranking dr ON po.department_name = dr.department_name
JOIN patient_recovery_rates pr ON po.patient_id = pr.patient_id
JOIN complication_counts cc ON po.complication = cc.complication
ORDER BY dr.rank, pr.recovery_rate DESC;
------------------
**Identifying High-Value Customers in a Retail Industry**

Develop a SQL query to identify the top 10% of customers in a retail industry who have spent the most amount on purchases over the past 12 months, and provide their purchase frequency, average order value, and total revenue generated. Also, include the product categories that these high-value customers are most likely to purchase from.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    COUNT(o.order_id) AS purchase_frequency,
    AVG(o.total_amount) AS avg_order_value,
    SUM(o.total_amount) AS total_revenue,
    pc.product_category
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    (SELECT 
         product_id,
         category,
         ROW_NUMBER() OVER (PARTITION BY category ORDER BY SUM(quantity) DESC) AS product_rank
     FROM 
         order_items
     GROUP BY 
         product_id, category) pc ON o.product_id = pc.product_id
JOIN 
    (SELECT 
         category,
         ROW_NUMBER() OVER (PARTITION BY category ORDER BY SUM(quantity) DESC) AS product_rank
     FROM 
         (SELECT 
              oi.product_id,
              p.category,
              SUM(oi.quantity) AS quantity
           FROM 
              order_items oi
           JOIN 
              products p ON oi.product_id = p.product_id
           GROUP BY 
              oi.product_id, p.category) t
     GROUP BY 
         category) pc2 ON pc.category = pc2.category AND pc.product_rank = 1
WHERE 
    o.order_date > (CURRENT_DATE - INTERVAL 1 YEAR)
GROUP BY 
    c.customer_id, c.name, c.email, pc.product_category
ORDER BY 
    total_revenue DESC
LIMIT 
    0.1 * COUNT(*)
------------------
**Analyzing Customer Churn in a Telecommunications Industry**

Develop a SQL query to identify the top 5 reasons why customers in a telecommunications industry are likely to churn based on the frequency of complaints, billing issues, and poor network quality. Also, provide a breakdown of the number of customers who have churned in each region and the average revenue loss per customer.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "complaints",
        "columns": [
            {"name": "complaint_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "issue", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"}
        ]
    },
    {
        "name": "billing_issues",
        "columns": [
            {"name": "billing_issue_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "issue", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"}
        ]
    },
    {
        "name": "network_quality_issues",
        "columns": [
            {"name": "issue_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "issue", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "reason", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  c.reason, 
  COUNT(DISTINCT c.customer_id) as num_customers
FROM 
  churn c
GROUP BY 
  c.reason
ORDER BY 
  num_customers DESC
LIMIT 5

SELECT 
  r.region, 
  COUNT(DISTINCT c.customer_id) as num_customers
FROM 
  churn c
JOIN 
  customers cl ON c.customer_id = cl.customer_id
GROUP BY 
  r.region
ORDER BY 
  num_customers DESC

SELECT 
  AVG(revenue) as avg_revenue
FROM 
  (
    SELECT 
      cl.revenue, 
      cl.customer_id
    FROM 
      churn c
    JOIN 
      customers cl ON c.customer_id = cl.customer_id
  ) subquery
WHERE 
  subquery.customer_id IN (
    SELECT 
      customer_id
    FROM 
      churn
    GROUP BY 
      customer_id
    HAVING 
      COUNT(*) > 1
  )
------------------
**Optimizing Inventory Management in a Manufacturing Industry**

Develop a SQL query to identify the top 10 products in a manufacturing industry that have the highest inventory turnover rate, and provide their average lead time, reorder point, and safety stock level. Also, include the products with the highest value of excess stock and the average days stock outstanding (DSO) for each product.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "lead_time", "type": "INT"},
            {"name": "reorder_point", "type": "INT"},
            {"name": "safety_stock", "type": "INT"}
        ]
    },
    {
        "name": "excess_stock",
        "columns": [
            {"name": "excess_stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "date", "type": "DATE"}
        ]
    }
]
Response:
SELECT p.product_name, 
       ROUND(SUM(i.quantity) / SUM(s.quantity) * 365, 2) AS avg_days_stock_outstanding, 
       AVG(i.lead_time) AS avg_lead_time, 
       AVG(i.reorder_point) AS avg_reorder_point, 
       AVG(i.safety_stock) AS avg_safety_stock, 
       MAX(es.value) AS excess_stock_value
FROM products p
JOIN inventory i ON p.product_id = i.product_id
JOIN sales s ON p.product_id = s.product_id
LEFT JOIN excess_stock es ON p.product_id = es.product_id
GROUP BY p.product_name
ORDER BY SUM(i.quantity) / SUM(s.quantity) * 365 DESC
LIMIT 10

UNION ALL

SELECT p.product_name, 
       NULL AS avg_days_stock_outstanding, 
       NULL AS avg_lead_time, 
       NULL AS avg_reorder_point, 
       NULL AS avg_safety_stock, 
       MAX(es.value) AS excess_stock_value
FROM products p
JOIN excess_stock es ON p.product_id = es.product_id
GROUP BY p.product_name
ORDER BY MAX(es.value) DESC
LIMIT 10
------------------
Analyze sales trends for a e-commerce company across different regions, considering product categories and inventory levels.

Identify the top 3 product categories with the highest average order value (AOV) in each region, taking into account the inventory levels and sales data from the past 12 months. The query should also exclude product categories with less than 10% market share.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "total_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "inventory_level", "type": "INT"}
        ]
    },
    {
        "name": "market_share",
        "columns": [
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "market_share", "type": "DECIMAL(5, 2)"}
        ]
    }
]
Response:
SELECT T1.product_category 
FROM ( SELECT T1.product_category ,  SUM(T3.revenue) / COUNT(DISTINCT T2.order_id) AS AVG_ORDER_VALUE 
FROM sales T1 
JOIN orders T2 ON T1.order_id = T2.order_id 
JOIN products T3 ON T2.region = T3.region AND T1.product_category = T3.product_category 
WHERE T1.sale_date >= DATE('now', '-12 month') 
GROUP BY T1.product_category ,  T2.region ) T4 
JOIN market_share T5 ON T4.product_category = T5.product_category 
WHERE T4.AVG_ORDER_VALUE > ( SELECT AVG(AVG_ORDER_VALUE) * 0.1 
FROM ( SELECT T1.product_category ,  SUM(T3.revenue) / COUNT(DISTINCT T2.order_id) AS AVG_ORDER_VALUE 
FROM sales T1 
JOIN orders T2 ON T1.order_id = T2.order_id 
JOIN products T3 ON T2.region = T3.region AND T1.product_category = T3.product_category 
WHERE T1.sale_date >= DATE('now', '-12 month') 
GROUP BY T1.product_category ,  T2.region ) T6 )
------------------
Identify the top 5 customers in terms of total sales value, considering the sales data from the past 3 years.

Develop a query to calculate the total sales value for each customer, taking into account the sales amount and the number of orders for each customer.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.name, COALESCE(SUM(revenue) / COUNT(*) * 3, 0) AS avg_revenue
FROM customers c
LEFT JOIN sales s ON c.customer_id = s.customer_id
WHERE s.sale_date BETWEEN DATE('now', '-3 years') AND DATE('now')
GROUP BY c.name
ORDER BY avg_revenue DESC
LIMIT 5
------------------
Develop a query to calculate the average monthly sales for each product category, considering the sales data from the past 2 years.

The query should also include a ranking of the top 3 product categories with the highest average monthly sales.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    p.product_category,
    AVG(s.revenue) AS avg_monthly_sales,
    RANK() OVER (ORDER BY AVG(s.revenue) DESC) AS rank
FROM 
    sales s
JOIN 
    orders o ON s.order_id = o.order_id
JOIN 
    products p ON o.customer_id = p.product_id
WHERE 
    s.sale_date >= DATE('now', '-2 years')
GROUP BY 
    p.product_category
ORDER BY 
    avg_monthly_sales DESC
LIMIT 
    3
------------------
Develop a query to identify the top 3 regions with the highest average order value (AOV) for each product category.

The query should consider the sales data from the past 6 months and exclude regions with less than 10% market share.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "total_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "region_market_share",
        "columns": [
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "market_share", "type": "DECIMAL(5, 2)"}
        ]
    }
]
Response:
SELECT T1.region, T1.product_category, AVG(T1.revenue) AS average_order_value 
FROM sales T1 
JOIN orders T2 ON T1.order_id = T2.order_id 
JOIN (
  SELECT region, SUM(market_share) AS total_market_share 
  FROM region_market_share 
  GROUP BY region 
  HAVING SUM(market_share) / (SELECT SUM(market_share) FROM region_market_share) * 100 > 10 
) T3 ON T1.region = T3.region 
WHERE T1.sale_date >= DATE('now', '-6 months') 
GROUP BY T1.region, T1.product_category 
ORDER BY T1.product_category, average_order_value DESC 
LIMIT 3
------------------
Analyze sales trends for the tech industry, identifying the top 3 product categories with the highest average order value (AOV) across different regions, while considering the impact of seasonality and promotions.
Schema:
[
    {
        "name": "products",
        "columns": [
            {
                "name": "product_id",
                "type": "INT",
                "constraints": ["PRIMARY KEY"]
            },
            {
                "name": "product_category",
                "type": "VARCHAR(255)"
            },
            {
                "name": "price",
                "type": "DECIMAL(10, 2)"
            }
        ]
    },
    {
        "name": "orders",
        "columns": [
            {
                "name": "order_id",
                "type": "INT",
                "constraints": ["PRIMARY KEY"]
            },
            {
                "name": "order_date",
                "type": "DATE"
            },
            {
                "name": "customer_id",
                "type": "INT",
                "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]
            },
            {
                "name": "product_id",
                "type": "INT",
                "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]
            },
            {
                "name": "order_total",
                "type": "DECIMAL(10, 2)"
            }
        ]
    },
    {
        "name": "regions",
        "columns": [
            {
                "name": "region_id",
                "type": "INT",
                "constraints": ["PRIMARY KEY"]
            },
            {
                "name": "region_name",
                "type": "VARCHAR(255)"
            }
        ]
    },
    {
        "name": "order_regions",
        "columns": [
            {
                "name": "order_id",
                "type": "INT",
                "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]
            },
            {
                "name": "region_id",
                "type": "INT",
                "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]
            }
        ]
    },
    {
        "name": "promotions",
        "columns": [
            {
                "name": "promotion_id",
                "type": "INT",
                "constraints": ["PRIMARY KEY"]
            },
            {
                "name": "promotion_name",
                "type": "VARCHAR(255)"
            },
            {
                "name": "start_date",
                "type": "DATE"
            },
            {
                "name": "end_date",
                "type": "DATE"
            }
        ]
    },
    {
        "name": "promotion_order",
        "columns": [
            {
                "name": "order_id",
                "type": "INT",
                "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]
            },
            {
                "name": "promotion_id",
                "type": "INT",
                "constraints": ["FOREIGN KEY", "REFERENCES promotions(promotion_id)"]
            }
        ]
    }
]
Response:
SELECT T1.product_category, AVG(T2.order_total) AS avg_order_value, T3.region_name
FROM products T1
JOIN orders T2 ON T1.product_id = T2.product_id
JOIN order_regions T4 ON T2.order_id = T4.order_id
JOIN regions T3 ON T4.region_id = T3.region_id
WHERE T2.order_date >= '2020-01-01' AND T2.order_date <= '2022-12-31'
GROUP BY T1.product_category, T3.region_name
ORDER BY avg_order_value DESC
LIMIT 3
------------------
**Task:** Analyze customer purchase behavior and predict future sales for a retail company.
**Business Problem:** Develop a SQL query to identify the top 10% of customers who have spent the most in the past 12 months, and predict their future sales by calculating the average order value (AOV) for their product categories.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_products",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales_forecast",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "forecast_date", "type": "DATE"},
            {"name": "forecast_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH customer_spending AS (
  SELECT c.customer_id, SUM(op.total_amount) as total_spending
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN order_products op ON o.order_id = op.order_id
  WHERE o.order_date >= DATE('now', '-1 year')
  GROUP BY c.customer_id
),
top_customers AS (
  SELECT customer_id, total_spending
  FROM customer_spending
  ORDER BY total_spending DESC
  LIMIT (SELECT COUNT(*) * 0.1 FROM customers)
),
customer_categories AS (
  SELECT c.customer_id, p.category, AVG(op.total_amount / op.quantity) as avg_order_value
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN order_products op ON o.order_id = op.order_id
  JOIN products p ON op.product_id = p.product_id
  WHERE o.order_date >= DATE('now', '-1 year')
  GROUP BY c.customer_id, p.category
),
forecast AS (
  SELECT c.customer_id, p.category, c.total_spending, COALESCE(cf.forecast_amount, 0) as forecast_amount
  FROM top_customers c
  JOIN customer_categories cc ON c.customer_id = cc.customer_id
  JOIN products p ON cc.category = p.category
  LEFT JOIN sales_forecast cf ON c.customer_id = cf.customer_id AND cf.forecast_date = DATE('now', '+1 month')
)
SELECT customer_id, category, total_spending, forecast_amount
FROM forecast
------------------
**Analyze Sales Performance by Region and Product Category**

We are a large e-commerce company that operates in multiple regions and sells a wide range of products. We want to analyze our sales performance by region and product category to identify areas for improvement and optimize our marketing strategies. The analysis should include the top-selling products in each region and the regions with the highest sales growth.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    r.name AS region, 
    p.category AS product_category, 
    SUM(o.order_total) AS total_sales, 
    SUM(s.amount) AS total_amount
FROM 
    orders o
JOIN 
    products p ON o.product_id = p.product_id
JOIN 
    regions r ON o.region = r.name
JOIN 
    sales s ON o.order_id = s.order_id
GROUP BY 
    r.name, 
    p.category
ORDER BY 
    total_sales DESC;
------------------
**Identify High-Value Customers**

We are a financial services company that wants to identify high-value customers who have a high potential for cross-selling and upselling. The analysis should include customers who have high transaction volumes, have a high average transaction value, and have a long history of transactions.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "creation_date", "type": "DATE"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "account_holders",
        "columns": [
            {"name": "account_holder_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "account_number", "type": "VARCHAR(255)"},
            {"name": "balance", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, COUNT(t.transaction_id) AS transaction_volume, AVG(t.amount) AS average_transaction_value, MAX(t.transaction_date) - MIN(t.transaction_date) AS transaction_history
FROM customers c
JOIN transactions t ON c.customer_id = t.customer_id
GROUP BY c.customer_id, c.name, c.email
HAVING COUNT(t.transaction_id) > 10 AND AVG(t.amount) > 100 AND MAX(t.transaction_date) - MIN(t.transaction_date) > INTERVAL 1 YEAR;
------------------
**Analyze Inventory Levels by Product and Store**

We are a retail company that operates multiple stores and sells a wide range of products. We want to analyze our inventory levels by product and store to identify areas where we need to restock and optimize our supply chain. The analysis should include the current inventory levels, product demand, and store capacity.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "capacity", "type": "INT"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT i.product_id, p.name, i.quantity, s.name AS store_name, s.capacity, COALESCE(o.quantity, 0) AS demand
FROM inventory i
JOIN products p ON i.product_id = p.product_id
JOIN stores s ON i.store_id = s.store_id
JOIN orders o ON i.product_id = o.product_id AND i.store_id = o.store_id
GROUP BY i.product_id, p.name, i.quantity, s.name, s.capacity, o.quantity;
------------------
**Predict Customer Churn**

We are a telecom company that wants to predict customer churn based on historical data. The analysis should include the top factors that contribute to customer churn, such as tenure, usage, and billing.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "creation_date", "type": "DATE"}
        ]
    },
    {
        "name": "usage_data",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "minutes_used", "type": "INT"}
        ]
    },
    {
        "name": "billing_data",
        "columns": [
            {"name": "billing_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "billing_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn_data",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    SUM(ud.minutes_used) AS total_minutes_used,
    SUM(bd.amount) AS total_amount_paid,
    MAX(CURRENT_DATE - c.creation_date) AS tenure_in_days,
    COUNT(CASE WHEN cd.churn_date IS NOT NULL THEN 1 END) AS churn_count
FROM 
    customers c
LEFT JOIN 
    usage_data ud ON c.customer_id = ud.customer_id
LEFT JOIN 
    billing_data bd ON c.customer_id = bd.customer_id
LEFT JOIN 
    churn_data cd ON c.customer_id = cd.customer_id
GROUP BY 
    c.customer_id
HAVING 
    COUNT(CASE WHEN cd.churn_date IS NOT NULL THEN 1 END) > 0;
------------------
**Analyze Student Performance by Course and Department**

We are a university that wants to analyze student performance by course and department to identify areas where students need improvement. The analysis should include the average GPA, attendance, and graduation rates by course and department.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "gpa", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  c.name AS course_name, 
  c.department AS department_name, 
  AVG(g.gpa) AS average_gpa, 
  AVG(e.attendance) AS average_attendance, 
  AVG(g.graduation_rate) AS average_graduation_rate
FROM 
  courses c
  LEFT JOIN enrollments e ON c.course_id = e.course_id
  LEFT JOIN grades g ON c.course_id = g.course_id
GROUP BY 
  c.name, 
  c.department
------------------
**Analyze Customer Retention and Revenue Growth**

Design a SQL query to identify the top 3 customers who have the highest average order value (AOV) over the past 2 years, considering only orders placed within the last 90 days. The query should also calculate the total revenue generated by these top customers in the last quarter and compare it to the total revenue generated in the same quarter last year.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "revenue_history",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"},
            {"name": "quarter", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.name, c.email, AVG(o.total_amount) AS avg_order_value, SUM(CASE WHEN o.order_date >= DATE('now', '-90 days') THEN o.total_amount END) / 3 AS avg_order_value_last_90days, 
       (SELECT SUM(rh.revenue) FROM revenue_history rh WHERE rh.quarter = 'Q4 2023') - (SELECT SUM(rh.revenue) FROM revenue_history rh WHERE rh.quarter = 'Q4 2022') AS revenue_growth
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= DATE('now', '-2 years')
GROUP BY c.customer_id
ORDER BY avg_order_value DESC
LIMIT 3
------------------
**Identify High-Risk Customers**

Design a SQL query to identify customers who have made at least 5 purchases within the last 30 days, have an average order value (AOV) of less than $100, and have a total lifetime spend of less than $1000. The query should also flag these high-risk customers as "high_risk" and calculate the total revenue generated by these customers in the last quarter.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "revenue_history",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"},
            {"name": "quarter", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    COUNT(o.order_id) AS num_orders,
    AVG(o.total_amount) AS avg_order_value,
    SUM(o.total_amount) AS total_lifetime_spend,
    CASE 
        WHEN COUNT(o.order_id) >= 5 AND AVG(o.total_amount) < 100 AND SUM(o.total_amount) < 1000 THEN 'high_risk'
        ELSE 'low_risk'
    END AS high_risk_status,
    SUM(oi.quantity * oi.unit_price) AS total_revenue_last_quarter
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
WHERE o.order_date >= DATE('now', '-30 days')
GROUP BY c.customer_id, c.name, c.email, o.order_date
HAVING COUNT(o.order_id) >= 5 AND AVG(o.total_amount) < 100 AND SUM(o.total_amount) < 1000;
------------------
**Analyze Product Performance**

Design a SQL query to identify the top 5 products by revenue generated in the last quarter, considering only products with a category of "Electronics". The query should also calculate the average revenue generated by these products in the last year.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "revenue_history",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"},
            {"name": "quarter", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(oi.unit_price * oi.quantity) AS total_revenue
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
WHERE p.category = 'Electronics' AND o.order_date >= (CURRENT_DATE - INTERVAL 3 month)
GROUP BY p.product_name
ORDER BY total_revenue DESC
LIMIT 5

SELECT AVG(total_revenue) AS avg_revenue
FROM (
  SELECT p.product_name, SUM(oi.unit_price * oi.quantity) AS total_revenue
  FROM products p
  JOIN order_items oi ON p.product_id = oi.product_id
  JOIN orders o ON oi.order_id = o.order_id
  WHERE p.category = 'Electronics'
  AND o.order_date >= (CURRENT_DATE - INTERVAL 12 month)
  GROUP BY p.product_name
) AS subquery
------------------
**Analyzing Sales Trends and Customer Segments in E-commerce**
Develop a SQL query to identify the top 5 product categories by sales revenue, segmented by region, with a focus on the most loyal customers (i.e., those who have made at least 3 purchases within the last 6 months).
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "loyalty_rate", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY_KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT T3.product_category, T3.revenue, T2.region 
FROM orders AS T1 
JOIN customers AS T2 ON T1.customer_id = T2.customer_id 
JOIN orders AS T4 ON T2.customer_id = T4.customer_id 
JOIN (
    SELECT customer_id, 
    COUNT(order_id) AS purchase_count, 
    MAX(order_date) AS last_order_date 
    FROM orders 
    GROUP BY customer_id 
) AS T5 ON T4.customer_id = T5.customer_id 
WHERE T5.purchase_count >= 3 AND T5.last_order_date > (CURRENT_DATE - INTERVAL 6 MONTH) 
GROUP BY T3.product_category, T3.revenue, T2.region 
ORDER BY T3.revenue DESC 
LIMIT 5
------------------
**Predicting Student Performance in Higher Education**
Develop a SQL query to predict the likelihood of a student passing a course based on their past academic performance, demographics, and course characteristics. The model should consider multiple linear regression, interaction terms, and feature engineering.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "age", "type": "INT"},
            {"name": "gpa", "type": "DECIMAL(4, 2)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(100)"},
            {"name": "credits", "type": "INT"},
            {"name": "difficulty", "type": "VARCHAR(10)"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "VARCHAR(10)"},
            {"name": "pass_year", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  e.student_id, 
  e.course_id, 
  e.grade, 
  s.name AS student_name, 
  s.gender, 
  s.age, 
  s.gpa, 
  c.course_name, 
  c.credits, 
  c.difficulty, 
  (e.grade != 'F' AND e.grade != 'I') AS passed
FROM 
  enrollments e
  INNER JOIN students s ON e.student_id = s.student_id
  INNER JOIN courses c ON e.course_id = c.course_id;

WITH 
  past_performance AS (
    SELECT 
      e.student_id, 
      AVG(CASE WHEN e.grade = 'A' THEN 4 ELSE 0 END) AS a_score, 
      AVG(CASE WHEN e.grade = 'B' THEN 3 ELSE 0 END) AS b_score, 
      AVG(CASE WHEN e.grade = 'C' THEN 2 ELSE 0 END) AS c_score, 
      AVG(CASE WHEN e.grade = 'D' THEN 1 ELSE 0 END) AS d_score, 
      AVG(CASE WHEN e.grade = 'F' THEN 0 ELSE 0 END) AS f_score
    FROM 
      enrollments e
    GROUP BY 
      e.student_id
  ),
  feature_engineering AS (
    SELECT 
      s.student_id, 
      s.name, 
      s.gender, 
      s.age, 
      s.gpa, 
      c.credits, 
      c.difficulty,
      pp.a_score, 
      pp.b_score, 
      pp.c_score, 
      pp.d_score, 
      pp.f_score
    FROM 
      students s
      INNER JOIN past_performance pp ON s.student_id = pp.student_id
      INNER JOIN courses c ON s.student_id IN (
        SELECT 
          e.student_id
        FROM 
          enrollments e
          INNER JOIN courses c ON e.course_id = c.course_id
        WHERE 
          c.course_name = c.course_name
      )
  )
SELECT 
  student_id, 
  name, 
  gender, 
  age, 
  gpa, 
  credits, 
  difficulty, 
  a_score, 
  b_score, 
  c_score, 
  d_score, 
  f_score,
  (a_score * 4 + b_score * 3 + c_score * 2 + d_score * 1 + f_score * 0) / (4 + 3 + 2 + 1 + 0) AS overall_score,
  (a_score * 4 + b_score * 3 + c_score * 2 + d_score * 1 + f_score * 0) / (4 + 3 + 2 + 1 + 0) * (credits / 3) AS weighted_score
FROM 
  feature_engineering;
------------------
**Analyzing Financial Performance and Risk in Banking**
Develop a SQL query to identify the top 3 banks by return on equity (ROE) and risk-adjusted return on capital (RAROC) within the last 2 years, considering both numerator and denominator values for each metric.
Schema:
[
    {
        "name": "banks",
        "columns": [
            {"name": "bank_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "eq", "type": "DECIMAL(15, 2)"}
        ]
    },
    {
        "name": "income_statements",
        "columns": [
            {"name": "income_statement_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "bank_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES banks(bank_id)"]},
            {"name": "net_income", "type": "DECIMAL(15, 2)"},
            {"name": "equity", "type": "DECIMAL(15, 2)"}
        ]
    },
    {
        "name": "balance_sheets",
        "columns": [
            {"name": "balance_sheet_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "bank_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES banks(bank_id)"]},
            {"name": "assets", "type": "DECIMAL(15, 2)"},
            {"name": "liabilities", "type": "DECIMAL(15, 2)"}
        ]
    }
]
Response:
SELECT b.name, i.net_income / b.eq AS rae, b.eq * b.eq / (b.assets - b.liabilities) AS raro
FROM banks b
JOIN income_statements i ON b.bank_id = i.bank_id
JOIN balance_sheets bs ON b.bank_id = bs.bank_id
WHERE b.bank_id IN (
  SELECT bank_id
  FROM income_statements
  WHERE date >= DATE('now', '-2 years')
  GROUP BY bank_id
  ORDER BY SUM(net_income) / SUM(eq) DESC
  LIMIT 3
)
ORDER BY rae DESC, raro DESC
------------------
**Analyze Customer Churn and Predict Future Churn Rates**

Develop a SQL query that identifies the top 5 customers who are most likely to churn within the next 3 months, based on their past purchase behavior and demographic information. The query should consider the following factors:

*   Average order value
*   Purchase frequency
*   Time since last purchase
*   Age
*   Subscription type

The query should also predict the future churn rate for each of the top 5 customers, using a logistic regression model.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "subscription_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_value", "type": "DECIMAL(10, 2)"},
            {"name": "subscription_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES subscriptions(subscription_id)"]}
        ]
    },
    {
        "name": "subscriptions",
        "columns": [
            {"name": "subscription_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "subscription_type", "type": "VARCHAR(255)"},
            {"name": "churn_date", "type": "DATE"}
        ]
    },
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "subscription_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES subscriptions(subscription_id)"]},
            {"name": "purchase_date", "type": "DATE"},
            {"name": "purchase_frequency", "type": "INT"}
        ]
    }
]
Response:
WITH customer_churn_scores AS (
  SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.age,
    c.subscription_type,
    AVG(o.order_value) AS avg_order_value,
    COUNT(o.order_id) AS purchase_frequency,
    MAX(o.order_date) - MIN(o.order_date) AS time_since_last_purchase,
    (SELECT COUNT(*) FROM subscriptions s WHERE s.churn_date <= CURRENT_DATE + INTERVAL 3 MONTH AND c.customer_id = s.customer_id) AS potential_churn
  FROM 
    customers c
  JOIN 
    orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id
),
ranked_customers AS (
  SELECT 
    customer_id,
    name,
    email,
    age,
    subscription_type,
    avg_order_value,
    purchase_frequency,
    time_since_last_purchase,
    potential_churn,
    ROW_NUMBER() OVER (ORDER BY potential_churn DESC) AS rank
  FROM 
    customer_churn_scores
)
SELECT 
  customer_id,
  name,
  email,
  age,
  subscription_type,
  avg_order_value,
  purchase_frequency,
  time_since_last_purchase,
  potential_churn
FROM 
  ranked_customers
WHERE 
  rank <= 5;
------------------
**Forecast Sales Revenue by Product Category**

Develop a SQL query that forecasts the sales revenue for each product category over the next 6 months, based on historical sales data and seasonal trends. The query should consider the following factors:

*   Average monthly sales revenue
*   Seasonal trends (e.g., holiday sales)
*   Product category mix

The query should return a table with the product category, forecasted sales revenue for each month, and a confidence interval for each forecast.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "seasonal_trends",
        "columns": [
            {"name": "month", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "seasonal_multiplier", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH 

monthly_revenue AS (
  SELECT 
    p.product_category,
    EXTRACT(YEAR FROM s.sale_date) AS year,
    EXTRACT(MONTH FROM s.sale_date) AS month,
    SUM(s.sale_amount) AS revenue
  FROM 
    sales s
  JOIN 
    products p ON s.product_id = p.product_id
  GROUP BY 
    p.product_category, EXTRACT(YEAR FROM s.sale_date), EXTRACT(MONTH FROM s.sale_date)
),

seasonal_multipliers AS (
  SELECT 
    st.product_category,
    st.month,
    st.seasonal_multiplier
  FROM 
    seasonal_trends st
),

forecast_revenue AS (
  SELECT 
    mr.product_category,
    mr.year,
    mr.month,
    mr.revenue,
    sm.seasonal_multiplier,
    SUM(mr.revenue * sm.seasonal_multiplier) OVER (
      PARTITION BY mr.product_category, mr.month
      ORDER BY 
        mr.year
      ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
    ) AS forecast
  FROM 
    monthly_revenue mr
  JOIN 
    seasonal_multipliers sm ON mr.product_category = sm.product_category AND mr.month = sm.month
)

SELECT 
  fr.product_category,
  EXTRACT(YEAR FROM DATE('now', '+6 month')) + m.month AS month,
  fr.forecast * (1 + 0.1 * ABS(SIN(6.28318530717959 * m.month / 12))) AS forecasted_revenue,
  fr.forecast * (1 - 0.1 * ABS(SIN(6.28318530717959 * m.month / 12))) AS confidence_interval
FROM 
  forecast_revenue fr
CROSS JOIN 
  generate_series(1, 6) m(month)
------------------
**Identify High-Value Customers and Optimize Marketing Campaigns**

Develop a SQL query that identifies the top 10 high-value customers based on their purchase history and demographic information. The query should consider the following factors:

*   Average order value
*   Purchase frequency
*   Time since last purchase
*   Age
*   Email preferences

The query should return a table with the customer's name, email, and a score indicating their value to the company. The score should be based on a machine learning model that weighs the importance of each factor.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "email_preferences", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_value", "type": "DECIMAL(10, 2)"},
            {"name": "purchase_frequency", "type": "INT"}
        ]
    },
    {
        "name": "machine_learning_model",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "score", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT C.name, C.email, 
       (0.3 * AVG(O.order_value) + 0.2 * AVG(O.purchase_frequency) + 0.1 * AVG(DATEDIFF(CURRENT_DATE, O.order_date)) + 0.1 * C.age + 0.3 * CASE 
         WHEN C.email_preferences LIKE '%NEWSLETTER%' THEN 1
         ELSE 0
       END) AS score
FROM customers C
JOIN (
  SELECT customer_id, AVG(order_value) AS avg_order_value, AVG(purchase_frequency) AS avg_purchase_frequency, 
         MAX(order_date) AS max_order_date
  FROM orders
  GROUP BY customer_id
) O ON C.customer_id = O.customer_id
JOIN (
  SELECT customer_id, score
  FROM machine_learning_model
  WHERE score IS NOT NULL
) ML ON C.customer_id = ML.customer_id
WHERE C.customer_id IN (
  SELECT customer_id
  FROM orders
  GROUP BY customer_id
  HAVING COUNT(*) >= 3
)
GROUP BY C.customer_id
ORDER BY score DESC
LIMIT 10
------------------
Analyze customer behavior and predict future sales for an e-commerce company.

The company wants to identify the top 10% of customers who are most likely to make a purchase in the next month. The analysis should consider the customer's purchase history, average order value, and the time elapsed since their last purchase.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "join_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "customer_activity",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "activity_date", "type": "DATE"},
            {"name": "activity_type", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email
FROM customers c
JOIN (
    SELECT customer_id, AVG(total_amount) AS avg_order_value, MAX(order_date) AS last_purchase_date
    FROM orders
    GROUP BY customer_id
) o ON c.customer_id = o.customer_id
JOIN (
    SELECT customer_id, MAX(activity_date) AS last_activity_date
    FROM customer_activity
    GROUP BY customer_id
) ac ON c.customer_id = ac.customer_id
WHERE ABS(DATEDIFF(MAX(o.order_date), c.join_date)) < 365 AND
      ABS(DATEDIFF(MAX(ac.activity_date), MAX(o.order_date))) < 30 AND
      o.avg_order_value > 50 AND
      (SELECT COUNT(order_id) FROM orders WHERE customer_id = c.customer_id AND order_date > MAX(o.order_date)) > 0
ORDER BY o.avg_order_value DESC
LIMIT 0.1 * (SELECT COUNT(customer_id) FROM customers);
------------------
Identify the top-performing sales regions for a retail company.

The company wants to analyze sales data by region and identify the top 5 regions with the highest average sales growth over the past quarter. The analysis should consider sales data from the past 6 months and exclude any regions with less than 10 sales transactions.
Schema:
[
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT T3.region_name 
FROM ( SELECT T1.region_id, AVG(T1.sale_amount) AS avg_sale_amount 
      FROM sales AS T1 
      WHERE T1.sale_date > DATE('now', '-6 month') 
      GROUP BY T1.region_id 
      HAVING COUNT(T1.sale_id) >= 10 
    ) AS T2 
JOIN regions AS T3 ON T2.region_id = T3.region_id 
JOIN ( SELECT T4.region_id, AVG(T4.sale_amount) - LAG(AVG(T4.sale_amount), 1, 0) OVER (PARTITION BY T4.region_id ORDER BY T4.sale_date) AS avg_growth 
      FROM sales AS T4 
      WHERE T4.sale_date > DATE('now', '-3 month') 
      GROUP BY T4.region_id 
    ) AS T5 ON T2.region_id = T5.region_id 
ORDER BY T5.avg_growth DESC 
LIMIT 5;
------------------
Analyze patient outcomes and identify the top-performing hospitals for a healthcare company.

The company wants to analyze patient outcomes by hospital and identify the top 5 hospitals with the highest average patient satisfaction scores over the past year. The analysis should consider patient data from the past 2 years and exclude any hospitals with less than 100 patients.
Schema:
[
    {
        "name": "hospitals",
        "columns": [
            {"name": "hospital_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "hospital_name", "type": "VARCHAR(255)"},
            {"name": "city", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "hospital_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES hospitals(hospital_id)"]},
            {"name": "admission_date", "type": "DATE"},
            {"name": "discharge_date", "type": "DATE"}
        ]
    },
    {
        "name": "patient_outcomes",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "outcome_date", "type": "DATE"},
            {"name": "satisfaction_score", "type": "INT"},
            {"name": "readmission_rate", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT h.hospital_name, AVG(po.satisfaction_score) AS avg_satisfaction_score
FROM hospitals h
JOIN patients p ON h.hospital_id = p.hospital_id
JOIN patient_outcomes po ON p.patient_id = po.patient_id
WHERE po.outcome_date >= DATE('now', '-2 year')
GROUP BY h.hospital_name
HAVING COUNT(DISTINCT p.patient_id) >= 100
ORDER BY AVG(po.satisfaction_score) DESC
LIMIT 5;
------------------
Identify the top 10% of customers with the highest average order value in the past 6 months, grouped by their location (city, state), and provide a ranking of the top 5 cities by the total revenue generated by these high-value customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES locations(location_id)"]}
        ]
    },
    {
        "name": "locations",
        "columns": [
            {"name": "location_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "city", "type": "VARCHAR(100)"},
            {"name": "state", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    l.city, l.state, 
    AVG(o.total_amount) as avg_order_value, 
    ROW_NUMBER() OVER (PARTITION BY l.city ORDER BY AVG(o.total_amount) DESC) as row_num
FROM 
    customers c
INNER JOIN 
    orders o ON c.customer_id = o.customer_id
INNER JOIN 
    locations l ON c.location_id = l.location_id
WHERE 
    o.order_date >= DATE('now', '-6 months')
GROUP BY 
    l.city, l.state, c.customer_id
HAVING 
    AVG(o.total_amount) > (SELECT AVG(total_amount) FROM orders o2 WHERE o2.order_date >= DATE('now', '-6 months'))
ORDER BY 
    row_num
LIMIT 0.1 * (SELECT COUNT(*) FROM customers WHERE customer_id IN (SELECT customer_id FROM orders WHERE order_date >= DATE('now', '-6 months')));

WITH 
    top_customers AS (
    SELECT 
        l.city, l.state, 
        AVG(o.total_amount) as avg_order_value, 
        ROW_NUMBER() OVER (PARTITION BY l.city ORDER BY AVG(o.total_amount) DESC) as row_num
    FROM 
        customers c
    INNER JOIN 
        orders o ON c.customer_id = o.customer_id
    INNER JOIN 
        locations l ON c.location_id = l.location_id
    WHERE 
        o.order_date >= DATE('now', '-6 months')
    GROUP BY 
        l.city, l.state, c.customer_id
    HAVING 
        AVG(o.total_amount) > (SELECT AVG(total_amount) FROM orders o2 WHERE o2.order_date >= DATE('now', '-6 months'))
    )
SELECT 
    city, state, SUM(avg_order_value) as total_revenue
FROM 
    top_customers
GROUP BY 
    city, state
ORDER BY 
    total_revenue DESC
LIMIT 5;
------------------
Analyze the sales data of a retail company to identify the top 5 product categories by revenue for each region. Also, provide the total revenue generated by each product category across all regions.
Schema:
[
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(100)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT pc.category_name, r.region_name, SUM(s.total_amount) AS total_revenue
FROM sales s
JOIN products p ON s.product_id = p.product_id
JOIN product_categories pc ON p.product_category_id = pc.product_category_id
JOIN regions r ON pc.region_id = r.region_id
GROUP BY pc.category_name, r.region_name
ORDER BY total_revenue DESC
LIMIT 5

UNION

SELECT pc.category_name, 'Total' AS region_name, SUM(s.total_amount) AS total_revenue
FROM sales s
JOIN products p ON s.product_id = p.product_id
JOIN product_categories pc ON p.product_category_id = pc.product_category_id
GROUP BY pc.category_name
------------------
Develop a SQL query to track the inventory levels of products across different warehouses. The query should return a list of products that have a low inventory level (less than 10 units) and are not in stock at Warehouse 1.
Schema:
[
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name 
FROM products p 
JOIN inventory i ON p.product_id = i.product_id 
WHERE i.quantity < 10 AND i.warehouse_id NOT IN (SELECT warehouse_id FROM warehouses WHERE warehouse_name = 'Warehouse 1')
------------------
Evaluate the performance of a marketing campaign by calculating the return on investment (ROI) for each campaign. The query should return the campaign ID, campaign name, and ROI for each campaign, along with the average ROI for all campaigns.
Schema:
[
    {
        "name": "campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(100)"},
            {"name": "budget", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES campaigns(campaign_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  c.campaign_id,
  c.campaign_name,
  (SUM(s.total_amount) / c.budget) AS ROI,
  (SUM(s.total_amount) / c.budget) / (SELECT AVG(c2.budget) FROM campaigns c2) AS avg_ROI
FROM 
  campaigns c
  JOIN sales s ON c.campaign_id = s.campaign_id
GROUP BY 
  c.campaign_id, c.campaign_name, c.budget
------------------
Develop a SQL query to analyze the sales performance of a retail company across different regions, product categories, and time periods.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "department", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "region_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    pc.category_name, 
    SUM(s.sales_amount) AS total_sales
FROM 
    sales s
JOIN 
    regions r ON s.region = r.region_name
JOIN 
    product_categories pc ON s.product_category = pc.category_name
GROUP BY 
    r.region_name, 
    pc.category_name
ORDER BY 
    r.region_name, 
    pc.category_name
------------------
Analyze the financial performance of a bank's investment products, including the total value of assets under management, average return on investment, and top-performing products.
Schema:
[
    {
        "name": "investments",
        "columns": [
            {"name": "investment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "asset_type", "type": "VARCHAR(255)"},
            {"name": "investment_date", "type": "DATE"},
            {"name": "investment_amount", "type": "DECIMAL(10, 2)"},
            {"name": "return_on_investment", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "asset_values",
        "columns": [
            {"name": "asset_value_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "asset_type", "type": "VARCHAR(255)"},
            {"name": "asset_date", "type": "DATE"},
            {"name": "department", "type": "VARCHAR(255)"},
            {"name": "branch", "type": "VARCHAR(255)"},
            {"name": "asset_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    i.product_name,
    SUM(av.asset_amount) AS total_asset_value,
    AVG(i.return_on_investment) AS avg_return_on_investment
FROM 
    investments i
JOIN 
    asset_values av ON i.asset_type = av.asset_type
GROUP BY 
    i.product_name
ORDER BY 
    total_asset_value DESC
------------------
Develop a SQL query to analyze the customer churn rate of a telecom company, including the top reasons for churn, average revenue per user, and customer retention strategies.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "plan_type", "type": "VARCHAR(255)"},
            {"name": "service_start_date", "type": "DATE"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason_for_churn", "type": "VARCHAR(255)"},
            {"name": "revenue_loss", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "revenue",
        "columns": [
            {"name": "revenue_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "revenue_date", "type": "DATE"},
            {"name": "revenue_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    c.name, 
    c.email, 
    r.reason_for_churn, 
    AVG(r.revenue_amount) AS avg_revenue_per_user
FROM 
    customers c
LEFT JOIN 
    revenue r ON c.customer_id = r.customer_id
WHERE 
    c.service_start_date < (SELECT MAX(service_start_date) FROM customers) - INTERVAL 1 YEAR
    AND c.customer_id NOT IN (SELECT customer_id FROM churn)
GROUP BY 
    c.name, 
    c.email, 
    r.reason_for_churn
ORDER BY 
    avg_revenue_per_user DESC;

SELECT 
    r.reason_for_churn, 
    COUNT(c.customer_id) AS churn_count
FROM 
    churn c
GROUP BY 
    r.reason_for_churn
ORDER BY 
    churn_count DESC;

SELECT 
    c.name, 
    c.email, 
    r.revenue_amount, 
    c.service_start_date
FROM 
    customers c
JOIN 
    revenue r ON c.customer_id = r.customer_id
WHERE 
    c.service_start_date > (SELECT MAX(service_start_date) FROM customers) - INTERVAL 2 YEAR;
------------------
Develop a SQL query to analyze the inventory management of an e-commerce company, including the top-selling products, average stock levels, and supply chain bottlenecks.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "stock_level", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "suppliers",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "supplier_name", "type": "VARCHAR(255)"},
            {"name": "contact", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(o.quantity) AS total_sales, AVG(p.stock_level) AS average_stock_level
FROM products p
JOIN orders o ON p.product_id = o.product_id
GROUP BY p.product_name
ORDER BY total_sales DESC;

SELECT supplier_name, SUM(quantity) AS total_orders
FROM (
    SELECT s.supplier_name, s.address, o.quantity
    FROM suppliers s
    JOIN orders o ON s.supplier_id = o.supplier_id
) AS subquery
GROUP BY supplier_name
ORDER BY total_orders DESC;

SELECT address, SUM(quantity) AS total_orders
FROM (
    SELECT s.address, o.quantity
    FROM suppliers s
    JOIN orders o ON s.supplier_id = o.supplier_id
) AS subquery
GROUP BY address
HAVING SUM(quantity) > (
    SELECT AVG(total_orders) * 2
    FROM (
        SELECT supplier_name, SUM(quantity) AS total_orders
        FROM (
            SELECT s.supplier_name, s.address, o.quantity
            FROM suppliers s
            JOIN orders o ON s.supplier_id = o.supplier_id
        ) AS subquery
        GROUP BY supplier_name
        ORDER BY total_orders DESC
        LIMIT 1 OFFSET 1
    ) AS subquery
);
------------------
Analyze Sales Performance of Product Categories across Different Regions

Develop a SQL query that generates a report showing the top 3 product categories with the highest average sales revenue by region. The report should include the product category name, average sales revenue, and the region where the sales are highest.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT pc.category_name, AVG(s.sale_amount) AS avg_sale_amount, r.region_name
FROM sales s
JOIN product_categories pc ON s.product_category_id = pc.product_category_id
JOIN regions r ON s.region_id = r.region_id
GROUP BY pc.category_name, r.region_name
ORDER BY avg_sale_amount DESC
LIMIT 3
------------------
Identify High-Risk Customers and Account Executives

Write a SQL query that identifies high-risk customers and the account executives responsible for them. A high-risk customer is defined as one who has a total purchase value of $10,000 or more in the past 6 months and has not made a payment in the past 30 days. The query should return the customer name, account executive name, and a risk score based on the number of days since the last payment.
Schema:
[
    {
        "name": "customer_accts",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_executive_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES account_executives(account_executive_id)"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "last_payment_date", "type": "DATE"}
        ]
    },
    {
        "name": "account_executives",
        "columns": [
            {"name": "account_executive_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "executive_name", "type": "VARCHAR(255)"},
            {"name": "sales_target", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customer_orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customer_accts(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  ca.customer_name, 
  ae.executive_name, 
  DATEDIFF('day', lpd, COALESCE(lp, lpd)) AS risk_score
FROM 
  customer_accts ca
  JOIN account_executives ae ON ca.account_executive_id = ae.account_executive_id
  LEFT JOIN (
    SELECT 
      customer_id, 
      MAX(last_payment_date) AS lp
    FROM 
      customer_accts
    GROUP BY 
      customer_id
  ) AS lp ON ca.customer_id = lp.customer_id
  LEFT JOIN (
    SELECT 
      customer_id, 
      MAX(last_payment_date) AS lpd
    FROM 
      customer_orders
    GROUP BY 
      customer_id
  ) AS lpd ON ca.customer_id = lpd.customer_id
WHERE 
  ca.customer_id IN (
    SELECT 
      customer_id
    FROM 
      customer_orders
    GROUP BY 
      customer_id
    HAVING 
      SUM(order_amount) >= 10000 AND 
      MAX(order_date) > DATE('now', '-6 month') AND 
      MAX(last_payment_date) < DATE('now', '-30 day')
  )
------------------
Predict Customer Churn Based on Purchase Behavior

Develop a SQL query that uses machine learning techniques to predict customer churn based on purchase history and demographic data. The query should return the predicted churn probability for each customer, along with the customer's name and demographic information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "purchase_date", "type": "DATE"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.name, 
  c.age, 
  c.gender, 
  c.location, 
  COALESCE(AVG(op.order_amount), 0) AS average_order_amount, 
  COALESCE(AVG(cp.purchase_date - l.order_date), 0) AS average_days_between_orders, 
  COALESCE(COUNT(op.order_id), 0) AS total_orders, 
  COALESCE(COUNT(DISTINCT cp.product_id), 0) AS total_products_purchased, 
  COALESCE(SUM(CASE WHEN cp.product_id IN (SELECT product_id FROM products WHERE product_category = 'Premium') THEN 1 ELSE 0 END), 0) AS premium_products_purchased, 
  COALESCE(SUM(CASE WHEN cp.product_id IN (SELECT product_id FROM products WHERE product_category = 'Budget') THEN 1 ELSE 0 END), 0) AS budget_products_purchased, 
  COALESCE(STDEV(c.age), 0) AS age_standard_deviation, 
  COALESCE(STDEV(c.location), 0) AS location_standard_deviation, 
  COALESCE(COUNT(CASE WHEN c.gender = 'Male' THEN 1 END), 0) AS male_count, 
  COALESCE(COUNT(CASE WHEN c.gender = 'Female' THEN 1 END), 0) AS female_count
FROM customers c
LEFT JOIN orders op ON c.customer_id = op.customer_id
LEFT JOIN customer_purchases cp ON c.customer_id = cp.customer_id
LEFT JOIN (
  SELECT customer_id, order_date, 
    LAG(order_date) OVER (PARTITION BY customer_id ORDER BY order_date) AS prev_order_date
  FROM orders
) l ON c.customer_id = lustomer_id AND l.order_date = cp.purchase_date
WHERE c.customer_id IN (SELECT customer_id FROM customer_purchases)
GROUP BY c.customer_id, c.name, c.age, c.gender, c.location
------------------
Optimize Inventory Levels for Maximum Sales

Write a SQL query that analyzes sales data to determine the optimal inventory levels for each product. The query should return the product name, recommended inventory level, and the sales data used to inform the recommendation.
Schema:
[
    {
        "name": "product_inventory",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "current_stock", "type": "INT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_inventory(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    pi.product_name, 
    SUM(s.sale_amount) AS total_sales,
    p.current_stock,
    (SELECT 
        SUM(s.sale_amount) / AVG(p.current_stock) * 1.2
     FROM sales s
     JOIN product_inventory p ON s.product_id = p.product_id) AS recommended_inventory_level
FROM sales s
JOIN product_inventory pi ON s.product_id = pi.product_id
GROUP BY pi.product_name, p.current_stock;
------------------
Analyze Customer Journey and Sales Funnel

Develop a SQL query that analyzes customer journey and sales funnel data to identify drop-off points and areas for improvement. The query should return the customer journey stage, sales funnel stage, and the percentage of customers who drop off at each stage.
Schema:
[
    {
        "name": "customer_journey",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "journey_stage", "type": "VARCHAR(255)"},
            {"name": "entry_date", "type": "DATE"}
        ]
    },
    {
        "name": "sales_funnel",
        "columns": [
            {"name": "funnel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customer_journey(customer_id)"]},
            {"name": "funnel_stage", "type": "VARCHAR(255)"},
            {"name": "drop_off_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  cj.journey_stage, 
  sf.funnel_stage, 
  ROUND(COUNT(sf.funnel_id) * 100.0 / (SELECT COUNT(*) FROM customer_journey cj2), 2) as drop_off_percentage
FROM 
  customer_journey cj 
  LEFT JOIN 
  sales_funnel sf ON cj.customer_id = sf.customer_id
GROUP BY 
  cj.journey_stage, 
  sf.funnel_stage
ORDER BY 
  cj.journey_stage, 
  sf.funnel_stage
------------------
**Identify Top-Performing Sales Regions with High Growth Potential**
Analyze sales data to determine the top-performing sales regions that have shown high growth potential over the past year. Consider the sales revenue, customer acquisition costs, and sales team performance. Rank the regions based on their growth rate, sales revenue, and customer retention.
Schema:
[
    {
        "name": "sales_regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "city", "type": "VARCHAR(255)"},
            {"name": "state", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "sales_revenue", "type": "DECIMAL(10, 2)"},
            {"name": "customer_acquisition_cost", "type": "DECIMAL(10, 2)"},
            {"name": "sales_team_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_teams(sales_team_id)"]}
        ]
    },
    {
        "name": "sales_teams",
        "columns": [
            {"name": "sales_team_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "team_name", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]}
        ]
    },
    {
        "name": "customer_data",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]},
            {"name": "customer_purchase_date", "type": "DATE"},
            {"name": "customer_retention", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    s.region_name, 
    SUM(sd.sales_revenue) AS total_sales_revenue, 
    SUM(sd.customer_acquisition_cost) AS total_customer_acquisition_cost, 
    SUM(cd.customer_retention) AS total_customer_retention, 
    (SUM(sd.sales_revenue) - SUM(sd.customer_acquisition_cost)) / (SELECT COUNT(DISTINCT sd.sales_id) FROM sales_data WHERE sd.order_date > (SELECT MAX(order_date) FROM sales_data) - INTERVAL 1 YEAR) AS growth_rate
FROM 
    sales_regions s 
JOIN 
    sales_data sd ON s.region_id = sd.region_id
JOIN 
    customer_data cd ON s.region_id = cd.region_id
WHERE 
    sd.order_date > (SELECT MAX(order_date) FROM sales_data) - INTERVAL 1 YEAR
GROUP BY 
    s.region_name
ORDER BY 
    growth_rate DESC, 
    total_sales_revenue DESC, 
    total_customer_retention DESC
------------------
**Predicting Customer Churn in the Telecom Industry**

A telecom company wants to identify potential customers who are likely to switch to a competing service provider. They want to analyze their customer data to predict churn based on various factors such as call duration, data usage, and billing information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"},
            {"name": "plan_type", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "calls",
        "columns": [
            {"name": "call_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "call_date", "type": "DATE"},
            {"name": "duration", "type": "INT"}
        ]
    },
    {
        "name": "data_usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_amount", "type": "INT"}
        ]
    },
    {
        "name": "bills",
        "columns": [
            {"name": "bill_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "bill_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "payment_status", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, SUM(CASE WHEN ch.churn_date IS NULL THEN 1 ELSE 0 END) AS is_active
FROM customers c
LEFT JOIN bills b ON c.customer_id = b.customer_id AND b.payment_status = 'paid'
LEFT JOIN calls ca ON c.customer_id = ca.customer_id AND ca.duration > 100
LEFT JOIN data_usage da ON c.customer_id = da.customer_id AND da.data_amount > 1000
LEFT JOIN churn ch ON c.customer_id = ch.customer_id AND ch.churn_date IS NOT NULL
GROUP BY c.customer_id, c.name, c.email
------------------
**Analyzing Student Performance in a University Setting**

A university wants to analyze the performance of its students in various courses. They want to identify the top-performing students in each course, as well as the courses with the highest average grades.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "credits", "type": "INT"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "INT"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]}
        ]
    }
]
Response:
SELECT s.name, c.course_name, AVG(g.grade) AS avg_grade
FROM grades g
JOIN students s ON g.student_id = s.student_id
JOIN courses c ON g.course_id = c.course_id
GROUP BY c.course_name
ORDER BY avg_grade DESC
------------------
**Optimizing Inventory Management in a Retail Store**

A retail store wants to analyze its inventory data to identify slow-moving products and optimize stock levels. They want to calculate the average inventory level per product category and calculate the total inventory value.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "cost_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity_sold", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  p.category, 
  AVG(i.quantity) AS average_inventory_level, 
  SUM(i.quantity * i.cost_price) AS total_inventory_value
FROM 
  products p
  LEFT JOIN inventory i ON p.product_id = i.product_id
GROUP BY 
  p.category
------------------
Identify the top 10 product companies in the e-commerce industry that have a consistent revenue growth above 15% YoY, and provide insights on their average order value, customer retention rate, and market share.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "order_count", "type": "INT"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "year", "type": "INT"},
            {"name": "quarter", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "market_share",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "market_share", "type": "DECIMAL(10, 2)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
WITH 

-- calculate revenue growth for each product company
revenue_growth AS (
  SELECT 
    s.product_id,
    s.year,
    s.quarter,
    (s.revenue - LAG(s.revenue, 1, 0) OVER (PARTITION BY s.product_id ORDER BY s.year, s.quarter)) / LAG(s.revenue, 1, 0) OVER (PARTITION BY s.product_id ORDER BY s.year, s.quarter) * 100 AS revenue_growth_yoy
  FROM 
    sales_data s
),

-- calculate average order value, customer retention rate, and market share for each product company
product_insights AS (
  SELECT 
    p.product_id,
    c.average_order_value,
    c.customer_retention_rate,
    m.market_share
  FROM 
    products p
  JOIN 
    customers c ON p.product_id = c.customer_id
  JOIN 
    market_share m ON p.product_id = m.product_id
),

-- filter product companies with consistent revenue growth above 15% YoY
top_product_companies AS (
  SELECT 
    r.product_id,
    r.year,
    r.quarter,
    r.revenue_growth_yoy
  FROM 
    revenue_growth r
  JOIN 
    product_insights pi ON r.product_id = pi.product_id
  WHERE 
    r.revenue_growth_yoy > 15 AND r.year > (SELECT MAX(year) - 1 FROM sales_data)
  GROUP BY 
    r.product_id, r.year, r.quarter, r.revenue_growth_yoy
  HAVING 
    COUNT(DISTINCT r.year) > 2
),

-- calculate average order value, customer retention rate, and market share for top product companies
top_product_insights AS (
  SELECT 
    AVG(pi.average_order_value) AS avg_order_value,
    AVG(pi.customer_retention_rate) AS customer_retention_rate,
    AVG(pi.market_share) AS market_share
  FROM 
    top_product_companies tp
  JOIN 
    product_insights pi ON tp.product_id = pi.product_id
)

-- get top 10 product companies
SELECT 
  TOP 10 
  tp.product_id,
  tp.year,
  tp.quarter,
  tp.revenue_growth_yoy,
  tpi.avg_order_value,
  tpi.customer_retention_rate,
  tpi.market_share
FROM 
  top_product_companies tp
JOIN 
  top_product_insights tpi ON tp.product_id = tpi.product_id
------------------
Analyze the sales performance above 10,000 units of a specific product (product_id = 123) across different regions in the US, and provide insights on the top 5 regions with the highest sales volume, average revenue per unit, and customer retention rate.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "order_count", "type": "INT"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    region, 
    SUM(quantity) AS total_sales, 
    AVG(revenue) AS avg_revenue_per_unit, 
    (SUM(CASE WHEN sale_date = MAX(sale_date) THEN 1 ELSE 0 END) * 1.0 / COUNT(*)) AS customer_retention_rate
FROM 
    sales 
WHERE 
    product_id = 123 AND region IN (SELECT region FROM sales WHERE product_id = 123 GROUP BY region ORDER BY SUM(quantity) DESC LIMIT 5) 
GROUP BY 
    region
------------------
Develop a predictive model to forecast the daily sales of a specific product (product_id = 456) based on historical sales data, weather conditions, and seasonal trends. Provide insights on the correlation between sales and weather conditions, and the impact of seasonal trends on sales.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "weather",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(10, 2)"},
            {"name": "humidity", "type": "DECIMAL(10, 2)"},
            {"name": "wind_speed", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "seasonal",
        "columns": [
            {"name": "seasonal_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "season", "type": "VARCHAR(255)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "product",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  s.sale_date, 
  w.temperature, 
  w.humidity, 
  s.quantity, 
  s.revenue, 
  s.seasonal_id
FROM 
  sales s
JOIN 
  weather w ON s.sale_date = w.sale_date
JOIN 
  seasonal se ON s.sale_date = se.sale_date AND s.product_id = se.product_id
WHERE 
  s.product_id = 456
ORDER BY 
  s.sale_date DESC

WITH corr AS (
  SELECT 
    w.temperature, 
    w.humidity, 
    correlations(
      w.temperature, 
      s.quantity, 
      s.revenue, 
      s.sale_date
    ) AS corr_temp, 
    correlations(
      w.humidity, 
      s.quantity, 
      s.revenue, 
      s.sale_date
    ) AS corr_humidity
  FROM 
    sales s
  JOIN 
    weather w ON s.sale_date = w.sale_date
  WHERE 
    s.product_id = 456
)
SELECT 
  temperature, 
  humidity, 
  corr_temp, 
  corr_humidity
FROM 
  corr
ORDER BY 
  temperature DESC, 
  humidity DESC

WITH seasonal_sales AS (
  SELECT 
    se.season, 
    SUM(s.quantity) AS total_quantity, 
    SUM(s.revenue) AS total_revenue
  FROM 
    sales s
  JOIN 
    seasonal se ON s.sale_date = se.sale_date AND s.product_id = se.product_id
  WHERE 
    s.product_id = 456
  GROUP BY 
    se.season
)
SELECT 
  season, 
  total_quantity, 
  total_revenue
FROM 
  seasonal_sales
ORDER BY 
  total_quantity DESC, 
  total_revenue DESC
------------------
Develop a data mart to analyze the sales performance of a retail company, and provide insights on the top 5 products with the highest sales volume, average revenue per unit, and customer retention rate. Also, provide a ranking of the top 5 sales regions with the highest sales volume, average revenue per unit, and customer retention rate.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "order_count", "type": "INT"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "region",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    p.product_name,
    SUM(s.quantity) AS total_quantity,
    SUM(s.revenue) AS total_revenue,
    AVG(s.revenue / s.quantity) AS average_revenue_per_unit,
    COUNT(DISTINCT c.customer_id) AS customer_count
FROM 
    sales s
JOIN 
    product p ON s.product_id = p.product_id
JOIN 
    customers c ON s.region = c.region
GROUP BY 
    p.product_name
ORDER BY 
    total_revenue DESC
LIMIT 5

UNION ALL

SELECT 
    r.region_name,
    SUM(s.quantity) AS total_quantity,
    SUM(s.revenue) AS total_revenue,
    AVG(s.revenue / s.quantity) AS average_revenue_per_unit,
    COUNT(DISTINCT c.customer_id) AS customer_count
FROM 
    sales s
JOIN 
    region r ON s.region = r.region_name
JOIN 
    customers c ON s.region = c.region
GROUP BY 
    r.region_name
ORDER BY 
    total_revenue DESC
LIMIT 5
------------------
Analyze the sales performance of a tech company across different product categories and regions, and provide insights on the top 5 product categories with the highest sales volume, average revenue per unit, and customer retention rate. Also, provide a ranking of the top 5 regions with the highest sales volume, average revenue per unit, and customer retention rate.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "order_count", "type": "INT"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "region",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    P.category, 
    SUM(S.quantity) AS total_sales,
    AVG(S.revenue / S.quantity) AS avg_revenue_per_unit,
    (COUNT(DISTINCT S.sale_id) / (SELECT SUM(order_count) FROM customers)) AS customer_retention_rate
FROM 
    sales S
JOIN 
    product P ON S.product_id = P.product_id
GROUP BY 
    P.category
ORDER BY 
    total_sales DESC
LIMIT 5
UNION ALL
SELECT 
    R.region_name, 
    SUM(S.quantity) AS total_sales,
    AVG(S.revenue / S.quantity) AS avg_revenue_per_unit,
    (COUNT(DISTINCT S.sale_id) / (SELECT SUM(order_count) FROM customers)) AS customer_retention_rate
FROM 
    sales S
JOIN 
    region R ON S.region = R.region_name
GROUP BY 
    R.region_name
ORDER BY 
    total_sales DESC
LIMIT 5
------------------
Develop a predictive model to forecast the daily revenue of a retail company based on historical sales data, weather conditions, and seasonal trends. Provide insights on the correlation between sales and weather conditions, and the impact of seasonal trends on sales.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "weather",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(10, 2)"},
            {"name": "humidity", "type": "DECIMAL(10, 2)"},
            {"name": "wind_speed", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "seasonal",
        "columns": [
            {"name": "seasonal_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "season", "type": "VARCHAR(255)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "product",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  s.sale_date, 
  w.temperature, 
  w.humidity, 
  w.wind_speed, 
  s.revenue, 
  s.quantity
FROM 
  sales s
JOIN 
  weather w ON s.sale_date = w.sale_date
JOIN 
  seasonal se ON s.sale_date = se.sale_date
JOIN 
  product p ON se.product_id = p.product_id
WHERE 
  s.region = 'North'
ORDER BY 
  s.sale_date ASC;

-- Predictive Model for Daily Revenue Forecasting
WITH 
  sales_data AS (
    SELECT 
      sale_date, 
      SUM(revenue) AS total_revenue
    FROM 
      sales
    WHERE 
      region = 'North'
    GROUP BY 
      sale_date
  ),
  weather_data AS (
    SELECT 
      sale_date, 
      AVG(temperature) AS avg_temp, 
      AVG(humidity) AS avg_humidity, 
      AVG(wind_speed) AS avg_wind_speed
    FROM 
      weather
    WHERE 
      sale_date IN (SELECT sale_date FROM sales)
    GROUP BY 
      sale_date
  ),
  seasonal_data AS (
    SELECT 
      sale_date, 
      COUNT(*) AS seasonal_count
    FROM 
      seasonal
    WHERE 
      sale_date IN (SELECT sale_date FROM sales)
    GROUP BY 
      sale_date
  )
SELECT 
  sd.sale_date, 
  sd.total_revenue, 
  wd.avg_temp, 
  wd.avg_humidity, 
  wd.avg_wind_speed, 
  sd.total_revenue * (wd.avg_temp + wd.avg_humidity + wd.avg_wind_speed + sd.seasonal_count) AS predicted_revenue
FROM 
  sales_data sd
JOIN 
  weather_data wd ON sd.sale_date = wd.sale_date
JOIN 
  seasonal_data ss ON sd.sale_date = ss.sale_date
------------------
Develop a data mart to analyze the sales performance of a retail company, and provide insights on the top 5 products with the highest sales volume, average revenue per unit, and customer retention rate. Also, provide a ranking of the top 5 sales regions with the highest sales volume, average revenue per unit, and customer retention rate.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "order_count", "type": "INT"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "region",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    p.product_name, 
    SUM(s.quantity) AS total_quantity, 
    SUM(s.revenue) / SUM(s.quantity) AS average_revenue_per_unit, 
    COUNT(DISTINCT c.customer_id) AS customer_count, 
    COUNT(DISTINCT s.sale_id) / c.order_count AS customer_retention_rate, 
    ROW_NUMBER() OVER (ORDER BY SUM(s.quantity) DESC) AS sales_rank
FROM 
    sales s
JOIN 
    customers c ON s.product_id = p.product_id
JOIN 
    product p ON s.product_id = p.product_id
WHERE 
    s.sale_date BETWEEN '2020-01-01' AND '2022-12-31'
GROUP BY 
    p.product_name
ORDER BY 
    total_quantity DESC
LIMIT 5

UNION ALL

SELECT 
    r.region_name, 
    SUM(s.quantity) AS total_quantity, 
    SUM(s.revenue) / SUM(s.quantity) AS average_revenue_per_unit, 
    COUNT(DISTINCT c.customer_id) AS customer_count, 
    COUNT(DISTINCT s.sale_id) / c.order_count AS customer_retention_rate, 
    ROW_NUMBER() OVER (ORDER BY SUM(s.quantity) DESC) AS sales_rank
FROM 
    sales s
JOIN 
    customers c ON s.product_id = p.product_id
JOIN 
    product p ON s.product_id = p.product_id
JOIN 
    region r ON s.region = r.region_name
WHERE 
    s.sale_date BETWEEN '2020-01-01' AND '2022-12-31'
GROUP BY 
    r.region_name
ORDER BY 
    total_quantity DESC
LIMIT 5
------------------
**Analyzing Sales Performance Across Regions and Product Categories**

Develop a SQL query to analyze sales performance across different regions and product categories for a retail company. The query should return the top 3 regions with the highest average sales per product category, along with the average sales amount and the total number of products sold.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT r.region_name, pc.category_name, AVG(s.sale_amount) AS avg_sale_amount, COUNT(*) AS num_products_sold
FROM sales s
JOIN regions r ON s.region_id = r.region_id
JOIN product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY r.region_name, pc.category_name
ORDER BY avg_sale_amount DESC
LIMIT 3;
------------------
**Predicting Customer Churn Based on Purchase History**

Develop a SQL query to predict customer churn based on their purchase history. The query should return the top 5 customers with the highest likelihood of churning, along with their predicted churn probability and the total amount spent in the last 6 months.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn_predictions",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "predicted_churn_probability", "type": "DECIMAL(5, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, cp.predicted_churn_probability, 
       SUM(o.total_amount) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN churn_predictions cp ON c.customer_id = cp.customer_id
WHERE o.order_date >= DATE('now', '-6 months')
GROUP BY c.customer_id, c.name, c.email, cp.predicted_churn_probability
ORDER BY cp.predicted_churn_probability DESC
LIMIT 5
------------------
**Analyzing Inventory Levels Across Warehouses**

Develop a SQL query to analyze inventory levels across different warehouses for a retail company. The query should return the top 5 products with the lowest inventory levels across all warehouses, along with the total quantity available and the percentage of inventory remaining.
Schema:
[
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "stock_movements",
        "columns": [
            {"name": "stock_movement_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "inventory_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES inventory(inventory_id)"]},
            {"name": "movement_date", "type": "DATE"},
            {"name": "movement_type", "type": "VARCHAR(255)"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, 
       SUM(i.quantity) AS total_quantity, 
       (SUM(i.quantity) / (SELECT COALESCE(SUM(quantity), 0) FROM inventory)) * 100 AS percentage_remaining
FROM products p
JOIN inventory i ON p.product_id = i.product_id
GROUP BY p.product_name
ORDER BY total_quantity ASC
LIMIT 5
------------------
Perform a time-series analysis to identify the most successful marketing campaigns for a retail company, considering the sales growth rate and customer retention rate over a 12-month period.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "join_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "campaign_orders",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES campaigns(campaign_id)"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "conversion_rate", "type": "DECIMAL(5,2)"}
        ]
    }
]
Response:
SELECT 
    c.campaign_name,
    SUM(o.quantity) AS total_sales,
    AVG(o.quantity) AS average_sales,
    SUM(CASE WHEN o.order_date > c.end_date THEN 1 ELSE 0 END) AS customer_loss,
    SUM(CASE WHEN o.order_date <= c.end_date THEN 1 ELSE 0 END) AS customer_retention,
    AVG(COALESCE(c.conversion_rate, 0)) AS conversion_rate
FROM 
    campaigns c
LEFT JOIN 
    campaign_orders co ON c.campaign_id = co.campaign_id
LEFT JOIN 
    orders o ON co.order_id = o.order_id
GROUP BY 
    c.campaign_name
ORDER BY 
    total_sales DESC;
------------------
Analyze the relationship between stock prices and economic indicators for a multinational corporation, considering the impact of quarterly earnings reports on stock performance.
Schema:
[
    {
        "name": "stocks",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_symbol", "type": "VARCHAR(10)"},
            {"name": "stock_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "earnings",
        "columns": [
            {"name": "earnings_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "quarter", "type": "INT"},
            {"name": "earnings_date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(20,2)"},
            {"name": "net_income", "type": "DECIMAL(20,2)"}
        ]
    },
    {
        "name": "economic_indicators",
        "columns": [
            {"name": "indicator_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "indicator_name", "type": "VARCHAR(255)"},
            {"name": "value", "type": "DECIMAL(10,2)"},
            {"name": "period", "type": "DATE"}
        ]
    },
    {
        "name": "stock_prices",
        "columns": [
            {"name": "stock_price_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "price_date", "type": "DATE"},
            {"name": "open_price", "type": "DECIMAL(10,2)"},
            {"name": "close_price", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT s.stock_name, e.quarter, e.earnings_date, e.revenue, e.net_income, sp.open_price, sp.close_price, ei.value
FROM stocks s
JOIN earnings e ON s.stock_id = e.stock_id
JOIN stock_prices sp ON s.stock_id = sp.stock_id
JOIN economic_indicators ei ON e.earnings_date = ei.period
WHERE e.quarter = 2 AND e.earnings_date BETWEEN '2020-01-01' AND '2020-12-31'
------------------
Develop a customer segmentation model to identify high-value customers for a healthcare services provider, considering demographic and behavioral factors.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "date_of_birth", "type": "DATE"},
            {"name": "insurance_type", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "appointments",
        "columns": [
            {"name": "appointment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "appointment_date", "type": "DATE"},
            {"name": "service_type", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "claims",
        "columns": [
            {"name": "claim_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "claim_date", "type": "DATE"},
            {"name": "claim_amount", "type": "DECIMAL(20,2)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "zip_code", "type": "VARCHAR(10)"},
            {"name": "income_level", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
WITH high_value_customers AS (
  SELECT 
    p.patient_id,
    c.claim_amount,
    d.zip_code,
    d.income_level
  FROM 
    patients p
  JOIN 
    claims c ON p.patient_id = c.patient_id
  JOIN 
    demographics d ON p.patient_id = d.patient_id
  WHERE 
    c.claim_amount > 10000 AND d.income_level = 'High'
)
SELECT 
  patient_id,
  COUNT(*) AS appointment_count,
  SUM(claim_amount) AS total_claim_amount
FROM 
  appointments a
  JOIN high_value_customers hvc ON a.patient_id = hvc.patient_id
GROUP BY 
  patient_id
ORDER BY 
  total_claim_amount DESC;
------------------
Identify the top 5 sales regions with the highest average order value (AOV) and total revenue for the past 6 months, considering only orders placed by customers who have made at least two purchases within the same region.
Schema:
[
    {
        "name": "sales_regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  AVG(o.total_amount) AS avg_order_value, 
  SUM(o.total_amount) AS total_revenue
FROM 
  orders o
  JOIN customers c ON o.customer_id = c.customer_id
  JOIN sales_regions r ON c.region_id = r.region_id
WHERE 
  o.order_date >= DATE('now', '-6 months')
GROUP BY 
  r.region_name
HAVING 
  COUNT(DISTINCT c.customer_id) >= 2
ORDER BY 
  avg_order_value DESC
LIMIT 5
------------------
Analyze the sales performance of products across different categories within the United States for the past year, considering only products with a sales volume above the national average. Provide the category-wise sales revenue, the top 3 products in each category with the highest sales revenue, and the top sales region for each category.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "sales_volume", "type": "INT"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
WITH national_avg_sales AS (
  SELECT AVG(sales_volume) as avg_sales
  FROM products
),
sales_performance AS (
  SELECT 
    p.category_id,
    pc.category_name,
    SUM(s.sales_amount) as sales_revenue,
    ROW_NUMBER() OVER (PARTITION BY p.category_id ORDER BY SUM(s.sales_amount) DESC) as sales_rank
  FROM products p
  JOIN sales s ON p.product_id = s.product_id
  JOIN sales_regions sr ON s.region_id = sr.region_id
  JOIN product_categories pc ON p.category_id = pc.category_id
  WHERE pc.country = 'United States'
  GROUP BY p.category_id, pc.category_name
),
top_products AS (
  SELECT 
    p.category_id,
    pc.category_name,
    p.product_name,
    SUM(s.sales_amount) as sales_revenue
  FROM products p
  JOIN sales s ON p.product_id = s.product_id
  JOIN sales_regions sr ON s.region_id = sr.region_id
  JOIN product_categories pc ON p.category_id = pc.category_id
  WHERE pc.country = 'United States'
  GROUP BY p.category_id, pc.category_name, p.product_name
),
top_regions AS (
  SELECT 
    p.category_id,
    pc.category_name,
    sr.region_name,
    SUM(s.sales_amount) as sales_revenue
  FROM products p
  JOIN sales s ON p.product_id = s.product_id
  JOIN sales_regions sr ON s.region_id = sr.region_id
  JOIN product_categories pc ON p.category_id = pc.category_id
  WHERE pc.country = 'United States'
  GROUP BY p.category_id, pc.category_name, sr.region_name
),
products_above_avg AS (
  SELECT 
    p.category_id,
    pc.category_name,
    p.product_name,
    p.sales_volume
  FROM products p
  JOIN product_categories pc ON p.category_id = pc.category_id
  WHERE p.sales_volume > (SELECT avg_sales FROM national_avg_sales)
)
SELECT 
  sp.category_name,
  sp.sales_revenue,
  tp.product_name,
  tp.sales_revenue as top_sales_product,
  tr.region_name,
  tr.sales_revenue as top_sales_region
FROM sales_performance sp
JOIN top_products tp ON sp.category_id = tp.category_id AND sp.category_name = tp.category_name
JOIN top_regions tr ON sp.category_id = tr.category_id AND sp.category_name = tr.category_name
JOIN products_above_avg pa ON sp.category_id = pa.category_id AND sp.category_name = pa.category_name
WHERE sp.sales_rank <= 3;
------------------
Develop a predictive model to forecast the future sales of products based on historical sales data, customer demographics, and market trends. Use a window function to calculate the moving average of sales for the past 3 months and the next 2 months, and then apply linear regression to predict the sales for the next quarter.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "sales_volume", "type": "INT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "market_trend", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  sales.product_id,
  customers.name,
  customers.age,
  customers.income,
  sales.sales_amount,
  AVG(sales.sales_amount) OVER (PARTITION BY sales.product_id ORDER BY sales.sales_date ROWS BETWEEN 3 PRECEDING AND CURRENT ROW) AS moving_avg_sales_3,
  AVG(sales.sales_amount) OVER (PARTITION BY sales.product_id ORDER BY sales.sales_date ROWS BETWEEN 2 PRECEDING AND 1 FOLLOWING) AS moving_avg_sales_2,
  (SELECT 
     SUM(sales_amount) 
   FROM 
     sales 
   WHERE 
     product_id = sales.product_id 
   AND 
     sales_date <= (SELECT MAX(sales_date) FROM sales WHERE product_id = sales.product_id)) AS total_sales
FROM 
  sales 
JOIN 
  customers ON sales.customer_id = customers.customer_id 
JOIN 
  products ON sales.product_id = products.product_id 
JOIN 
  product_categories ON products.category_id = product_categories.category_id
WHERE 
  sales_date <= (SELECT MAX(sales_date) FROM sales) - INTERVAL 3 month;
------------------
Develop a data mart to analyze the sales performance of products across different regions and channels for the past year. Provide the top 5 products with the highest sales revenue in each region, the top 3 channels with the highest sales revenue in each region, and the top sales region for each product.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]},
            {"name": "channel_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_channels(channel_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "sales_volume", "type": "INT"}
        ]
    },
    {
        "name": "sales_regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_channels",
        "columns": [
            {"name": "channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "channel_name", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]}
        ]
    }
]
Response:
SELECT 
    s.region_id, 
    pr.region_name, 
    p.product_name, 
    SUM(s.sales_amount) AS total_sales
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
JOIN 
    sales_regions pr ON s.region_id = pr.region_id
WHERE 
    s.sales_date >= DATE('now', '-1 year')
GROUP BY 
    s.region_id, pr.region_name, p.product_name
ORDER BY 
    s.region_id, total_sales DESC;

SELECT 
    s.region_id, 
    sc.channel_name, 
    SUM(s.sales_amount) AS total_sales
FROM 
    sales s
JOIN 
    sales_channels sc ON s.channel_id = sc.channel_id
WHERE 
    s.sales_date >= DATE('now', '-1 year')
GROUP BY 
    s.region_id, sc.channel_name
ORDER BY 
    s.region_id, total_sales DESC
LIMIT 3;

SELECT 
    s.product_id, 
    pr.region_name, 
    p.product_name, 
    SUM(s.sales_amount) AS total_sales
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
JOIN 
    sales_regions pr ON s.region_id = pr.region_id
WHERE 
    s.sales_date >= DATE('now', '-1 year')
GROUP BY 
    s.product_id, pr.region_name, p.product_name
ORDER BY 
    total_sales DESC
LIMIT 5;

SELECT 
    p.product_id, 
    pr.region_name, 
    pr.region_name AS top_region
FROM 
    (
        SELECT 
            s.product_id, 
            s.region_id, 
            SUM(s.sales_amount) AS total_sales
        FROM 
            sales s
        WHERE 
            s.sales_date >= DATE('now', '-1 year')
        GROUP BY 
            s.product_id, s.region_id
    ) AS subquery
JOIN 
    sales_regions pr ON subquery.region_id = pr.region_id
JOIN 
    products p ON subquery.product_id = p.product_id
GROUP BY 
    subquery.product_id, pr.region_name
ORDER BY 
    subquery.product_id, total_sales DESC;
------------------
Analyze the customer churn rate and retention rate for the past year, considering only customers who have made at least two purchases. Provide the top 5 reasons for customer churn, the average revenue loss per customer, and the top 3 products with the highest retention rate.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "sales_volume", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    COUNT(DISTINCT o.order_id) AS num_orders, 
    o.total_amount AS total_spent, 
    cc.churn_date, 
    cc.reason 
FROM 
    customers c 
INNER JOIN 
    orders o ON c.customer_id = o.customer_id 
LEFT JOIN 
    churn cc ON c.customer_id = cc.customer_id 
WHERE 
    c.customer_id NOT IN (
        SELECT 
            customer_id 
        FROM 
            churn 
        GROUP BY 
            customer_id 
        HAVING 
            COUNT(churn_date) < 2
    ) AND 
    o.order_id IN (
        SELECT 
            order_id 
        FROM 
        (
            SELECT 
                order_id, 
                DENSE_RANK() OVER (PARTITION BY customer_id ORDER BY order_date) AS order_rank 
            FROM 
                orders 
        ) 
        WHERE 
            order_rank = 2
    )
GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    o.total_amount, 
    cc.churn_date, 
    cc.reason 
HAVING 
    SUM(o.total_amount) > (SELECT 
        AVG(total_amount) * 2 
        FROM orders) 
ORDER BY 
    o.total_amount DESC
------------------
Develop a data warehouse to analyze the sales performance of products across different regions and channels for the past year, considering only products with a sales volume above the national average. Provide the top 5 products with the highest sales revenue in each region, the top 3 channels with the highest sales revenue in each region, and the top sales region for each product.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]},
            {"name": "channel_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_channels(channel_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "sales_volume", "type": "INT"}
        ]
    },
    {
        "name": "sales_regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_channels",
        "columns": [
            {"name": "channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "channel_name", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]}
        ]
    }
]
Response:
WITH 
national_avg_sales AS (
  SELECT CAST(SUM(sales_amount) AS DECIMAL(10, 2)) / COUNT(DISTINCT product_id) AS avg_sales
  FROM sales
),
top_products AS (
  SELECT region_id, product_id, SUM(sales_amount) AS total_sales
  FROM sales
  JOIN products p ON sales.product_id = p.product_id
  WHERE sales_amount > (SELECT avg_sales FROM national_avg_sales)
  GROUP BY region_id, product_id
),
top_channels AS (
  SELECT region_id, channel_id, SUM(sales_amount) AS total_sales
  FROM sales
  JOIN sales_channels c ON sales.channel_id = c.channel_id
  WHERE sales_amount > (SELECT avg_sales FROM national_avg_sales)
  GROUP BY region_id, channel_id
),
top_product_regions AS (
  SELECT p.product_id, s.region_id, SUM(s.sales_amount) AS top_sales
  FROM sales s
  JOIN products p ON s.product_id = p.product_id
  WHERE s.sales_amount > (SELECT avg_sales FROM national_avg_sales)
  GROUP BY p.product_id, s.region_id
),
top_5_products AS (
  SELECT region_id, product_id, total_sales
  FROM (
    SELECT region_id, product_id, total_sales,
    ROW_NUMBER() OVER (PARTITION BY region_id ORDER BY total_sales DESC) as row_num
    FROM top_products
  ) sub
  WHERE row_num <= 5
),
top_3_channels AS (
  SELECT region_id, channel_id, total_sales
  FROM (
    SELECT region_id, channel_id, total_sales,
    ROW_NUMBER() OVER (PARTITION BY region_id ORDER BY total_sales DESC) as row_num
    FROM top_channels
  ) sub
  WHERE row_num <= 3
)
SELECT * FROM top_5_products
UNION ALL
SELECT * FROM top_3_channels
UNION ALL
SELECT pr.product_id, pr.region_id, pr.top_sales
FROM top_product_regions pr
JOIN (
  SELECT product_id, MAX(top_sales) AS max_sales
  FROM top_product_regions
  GROUP BY product_id
) max_sales ON pr.product_id = max_sales.product_id AND pr.top_sales = max_sales.max_sales
------------------
Analyze the customer segmentation and demographics for the past year, considering only customers who have made at least two purchases. Provide the top 5 customer segments with the highest average revenue, the top 3 age groups with the highest average revenue, and the top 3 regions with the highest average revenue.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customer_segments",
        "columns": [
            {"name": "segment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "segment_name", "type": "VARCHAR(255)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  cs.segment_name,
  AVG(o.total_amount) AS avg_revenue
FROM 
  customer_segments cs
JOIN 
  customers c ON cs.customer_id = c.customer_id
JOIN 
  orders o ON c.customer_id = o.customer_id
GROUP BY 
  cs.segment_name
ORDER BY 
  avg_revenue DESC
LIMIT 5

UNION ALL

SELECT 
  AGE_GROUP,
  AVG(o.total_amount) AS avg_revenue
FROM 
  (
    SELECT 
      FLOOR(EXTRACT(YEAR FROM o.order_date) - c.age) AS AGE_GROUP
    FROM 
      customers c
    JOIN 
      orders o ON c.customer_id = o.customer_id
  ) AS age_groups
JOIN 
  orders o ON age_groups.customer_id = o.customer_id
GROUP BY 
  AGE_GROUP
ORDER BY 
  avg_revenue DESC
LIMIT 3

UNION ALL

SELECT 
  r.region_name,
  AVG(o.total_amount) AS avg_revenue
FROM 
  regions r
JOIN 
  customers c ON r.country = c.country
JOIN 
  orders o ON c.customer_id = o.customer_id
GROUP BY 
  r.region_name
ORDER BY 
  avg_revenue DESC
LIMIT 3
------------------
Develop a data mart to analyze the sales performance of products across different regions and channels for the past year, considering only products with a sales volume above the national average. Provide the top 5 products with the highest sales revenue in each region, the top 3 channels with the highest sales revenue in each region, and the top sales region for each product.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]},
            {"name": "channel_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_channels(channel_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "sales_volume", "type": "INT"}
        ]
    },
    {
        "name": "sales_regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_channels",
        "columns": [
            {"name": "channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "channel_name", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_regions(region_id)"]}
        ]
    }
]
Response:
WITH 
national_average AS (
  SELECT 
    CAST(SUM(sales_amount) AS DECIMAL(10, 2)) / COUNT(*) AS national_average_sales
  FROM 
    sales
),
top_products_by_region AS (
  SELECT 
    sr.region_id, 
    s.product_id, 
    SUM(s.sales_amount) AS total_sales
  FROM 
    sales s
  JOIN 
    sales_regions sr ON s.region_id = sr.region_id
  WHERE 
    s.sales_date >= DATE('now', '-1 year')
  GROUP BY 
    sr.region_id, 
    s.product_id
  ORDER BY 
    sr.region_id, 
    total_sales DESC
),
top_channels_by_region AS (
  SELECT 
    sr.region_id, 
    sc.channel_id, 
    SUM(s.sales_amount) AS total_sales
  FROM 
    sales s
  JOIN 
    sales_channels sc ON s.channel_id = sc.channel_id
  JOIN 
    sales_regions sr ON sc.region_id = sr.region_id
  WHERE 
    s.sales_date >= DATE('now', '-1 year')
  GROUP BY 
    sr.region_id, 
    sc.channel_id
  ORDER BY 
    sr.region_id, 
    total_sales DESC
),
top_sales_region_by_product AS (
  SELECT 
    s.product_id, 
    sr.region_id, 
    SUM(s.sales_amount) AS total_sales
  FROM 
    sales s
  JOIN 
    sales_regions sr ON s.region_id = sr.region_id
  GROUP BY 
    s.product_id, 
    sr.region_id
  ORDER BY 
    s.product_id, 
    total_sales DESC
)
SELECT 
  tpr.region_id, 
  tpr.product_id, 
  tpr.total_sales AS top_product_sales
FROM 
  top_products_by_region tpr
JOIN 
  national_average na ON TRUE
WHERE 
  tpr.total_sales > na.national_average_sales
ORDER BY 
  tpr.region_id, 
  tpr.total_sales DESC
LIMIT 5

UNION ALL

SELECT 
  tcr.region_id, 
  tcr.channel_id, 
  tcr.total_sales AS top_channel_sales
FROM 
  top_channels_by_region tcr
JOIN 
  (SELECT region_id, SUM(total_sales) AS total_sales FROM (SELECT region_id, total_sales, ROW_NUMBER() OVER (PARTITION BY region_id ORDER BY total_sales DESC) AS rn FROM top_channels_by_region) WHERE rn <= 3 GROUP BY region_id) tcr_filtered ON tcr.region_id = tcr_filtered.region_id AND tcr.total_sales = tcr_filtered.total_sales
ORDER BY 
  tcr.region_id, 
  tcr.total_sales DESC

UNION ALL

SELECT 
  tprp.product_id, 
  tprp.region_id, 
  tprp.total_sales AS top_region_sales
FROM 
  top_sales_region_by_product tprp
WHERE 
  (SELECT COUNT(*) FROM top_sales_region_by_product tprp2 WHERE tprp2.product_id = tprp.product_id AND tprp2.total_sales > tprp.total_sales) < 2
------------------
Analyze customer churn in the e-commerce industry using a star schema, identify the most influential factors contributing to customer churn, and predict the likelihood of churn for each customer.
Schema:
[
    {
        "name": "dim_customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"},
            {"name": "last_active_date", "type": "DATE"}
        ]
    },
    {
        "name": "fact_orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES dim_customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "returns_count", "type": "INT"}
        ]
    },
    {
        "name": "dim_products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "fact_order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES fact_orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES dim_products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "dim_channels",
        "columns": [
            {"name": "channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "channel_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "dim_device_types",
        "columns": [
            {"name": "device_type_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "device_type_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    dc.customer_id,
    dc.name,
    dc.email,
    dc.signup_date,
    dc.last_active_date,
    COALESCE(fo.total_amount, 0) AS total_amount,
    COALESCE(fo.returns_count, 0) AS returns_count,
    COALESCE(dp.total_churned_items, 0) AS total_churned_items,
    COALESCE(dct.device_type_name, '') AS device_type,
    COALESCE(dc1.channel_name, '') AS channel,
    COALESCE(dc2.churn_date, '') AS churn_date
FROM 
    dim_customers dc
LEFT JOIN 
    (
        SELECT 
            customer_id,
            SUM(total_amount) AS total_amount,
            SUM(returns_count) AS returns_count
        FROM 
            fact_orders
        GROUP BY 
            customer_id
    ) fo ON dc.customer_id = fo.customer_id
LEFT JOIN 
    (
        SELECT 
            fc.customer_id,
            COUNT(oi.order_item_id) AS total_churned_items
        FROM 
            fact_orders fo
        JOIN 
            fact_order_items oi ON fo.order_id = oi.order_id
        JOIN 
            dim_products p ON oi.product_id = p.product_id
        JOIN 
            (
                SELECT 
                    product_id,
                    COUNT(order_item_id) AS churned_items
                FROM 
                    fact_order_items
                WHERE 
                    order_item_id NOT IN (
                        SELECT 
                            order_item_id
                        FROM 
                            fact_order_items
                        WHERE 
                            quantity > 0
                    )
                GROUP BY 
                    product_id
            ) pc ON p.product_id = pc.product_id
        JOIN 
            dim_customers fc ON fo.customer_id = fc.customer_id
        GROUP BY 
            fc.customer_id
    ) dp ON dc.customer_id = dp.customer_id
LEFT JOIN 
    dim_device_types dct ON dc.device_type_id = dct.device_type_id
LEFT JOIN 
    (
        SELECT 
            customer_id,
            MAX(last_active_date) AS churn_date
        FROM 
            dim_customers
        GROUP BY 
            customer_id
        HAVING 
            MAX(last_active_date) <= DATE('now', '-6 month')
    ) dc2 ON dc.customer_id = dc2.customer_id
LEFT JOIN 
    dim_channels dc1 ON dc.channel_id = dc1.channel_id

WHERE 
    dc.last_active_date <= DATE('now', '-6 month')
------------------
Identify the top 5 product categories contributing to the highest revenue in the retail industry, considering both the product category and the distribution channel. Also, generate a ranking of the top 3 products within each category, considering the sales quantity and revenue.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "channel_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES distribution_channels(channel_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "distribution_channels",
        "columns": [
            {"name": "channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "channel_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  pc.category_name, 
  d.channel_name, 
  SUM(s.revenue) AS total_revenue
FROM 
  sales s
JOIN 
  product_categories pc ON s.category_id = pc.category_id
JOIN 
  distribution_channels d ON s.channel_id = d.channel_id
GROUP BY 
  pc.category_name, 
  d.channel_name
ORDER BY 
  total_revenue DESC
LIMIT 5

WITH top_products AS (
  SELECT 
    pc.category_name, 
    d.channel_name, 
    s.category_id, 
    s.channel_id, 
    ROW_NUMBER() OVER (PARTITION BY pc.category_name, d.channel_name ORDER BY s.revenue DESC) AS rank
  FROM 
    sales s
  JOIN 
    product_categories pc ON s.category_id = pc.category_id
  JOIN 
    distribution_channels d ON s.channel_id = d.channel_id
)
SELECT 
  category_name, 
  channel_name, 
  product_name, 
  quantity, 
  price, 
  revenue
FROM 
  (
    SELECT 
      pc.category_name, 
      d.channel_name, 
      p.product_name, 
      s.quantity, 
      s.price, 
      s.revenue,
      ROW_NUMBER() OVER (PARTITION BY pc.category_name, d.channel_name ORDER BY s.revenue DESC) AS rank
    FROM 
      sales s
    JOIN 
      products p ON s.product_id = p.product_id
    JOIN 
      product_categories pc ON s.category_id = pc.category_id
    JOIN 
      distribution_channels d ON s.channel_id = d.channel_id
  ) t
WHERE 
  rank <= 3
------------------
Analyze the financial performance of a multinational bank, identifying the top 5 countries contributing to the highest revenue from interest income, considering both the country and the loan type. Also, generate a ranking of the top 3 loan products within each country, considering the interest income and the total loan amount.
Schema:
[
    {
        "name": "interest_income",
        "columns": [
            {"name": "interest_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "country_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES countries(country_id)"]},
            {"name": "loan_type_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES loan_types(loan_type_id)"]},
            {"name": "interest_income", "type": "DECIMAL(10, 2)"},
            {"name": "total_loan_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "countries",
        "columns": [
            {"name": "country_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "country_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "loan_types",
        "columns": [
            {"name": "loan_type_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "loan_type_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.country_name, 
    lt.loan_type_name, 
    SUM(ii.interest_income) AS total_interest_income, 
    SUM(ii.total_loan_amount) AS total_loan_amount
FROM 
    interest_income ii
JOIN 
    countries c ON ii.country_id = c.country_id
JOIN 
    loan_types lt ON ii.loan_type_id = lt.loan_type_id
GROUP BY 
    c.country_name, 
    lt.loan_type_name
ORDER BY 
    c.country_name ASC, 
    total_interest_income DESC
LIMIT 5;

SELECT 
    c.country_name, 
    lt.loan_type_name, 
    SUM(ii.interest_income) AS total_interest_income, 
    SUM(ii.total_loan_amount) AS total_loan_amount,
    DENSE_RANK() OVER (PARTITION BY c.country_name ORDER BY SUM(ii.interest_income) DESC, SUM(ii.total_loan_amount) DESC) AS loan_product_rank
FROM 
    interest_income ii
JOIN 
    countries c ON ii.country_id = c.country_id
JOIN 
    loan_types lt ON ii.loan_type_id = lt.loan_type_id
GROUP BY 
    c.country_name, 
    lt.loan_type_name
HAVING 
    DENSE_RANK() OVER (PARTITION BY c.country_name ORDER BY SUM(ii.interest_income) DESC, SUM(ii.total_loan_amount) DESC) <= 3
ORDER BY 
    c.country_name ASC;
------------------
**Analyzing Sales Performance across Regions and Product Categories**
Analyze the sales performance of a retail company across different regions and product categories. The company wants to identify the top-selling product categories in each region, as well as the regions with the highest sales growth.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(100)"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
            {"name": "sale_date", "type": "DATE"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(100)"},
            {"name": "region_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  p.product_category, 
  SUM(s.sale_amount) AS total_sales, 
  ROW_NUMBER() OVER (PARTITION BY r.region_name ORDER BY SUM(s.sale_amount) DESC) AS sales_rank
FROM 
  sales s
JOIN 
  products p ON s.product_id = p.product_id
JOIN 
  regions r ON s.region = r.region_name
GROUP BY 
  r.region_name, p.product_category
ORDER BY 
  r.region_name, sales_rank;
------------------
**Predicting Customer Churn in a Subscription-based Service**
Develop a SQL query to predict customer churn in a subscription-based service company. The company wants! to identify customers who are likely to cancel their subscriptions based on their past behavior and demographic information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "subscription_status", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "payment_history",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "amount_paid", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.subscription_status
FROM customers c
JOIN demographics d ON c.customer_id = d.customer_id
JOIN (
  SELECT customer_id, AVG(CASE WHEN payment_date < DATE('now', '-3 months') THEN 1 ELSE 0 END) AS churn_rate
  FROM payment_history
  GROUP BY customer_id
) p ON c.customer_id = p.customer_id
WHERE c.subscription_status = 'active'
AND d.age > 30
AND p.churn_rate > 0.5
------------------
**Identifying High-Risk Transactions in a Financial Database**
Write a SQL query to identify high-risk transactions in a financial database. The company wants to detect transactions that involve suspicious activity, such as large transfers to unknown recipients or transactions with high transaction fees.
Schema:
[
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sender_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "recipient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_amount", "type": "DECIMAL(10, 2)"},
            {"name": "transaction_fee", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "risk_score", "type": "INT"}
        ]
    },
    {
        "name": "blacklist",
        "columns": [
            {"name": "blacklist_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "recipient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT t.transaction_id, t.sender_id, t.recipient_id, t.transaction_amount, t.transaction_fee 
FROM transactions t
JOIN customers c ON t.sender_id = c.customer_id OR t.recipient_id = c.customer_id
WHERE t.transaction_amount > 1000 OR t.transaction_fee > 0.1 * t.transaction_amount OR c.risk_score > 50
EXCEPT
SELECT t.transaction_id, t.sender_id, t.recipient_id, t.transaction_amount, t.transaction_fee 
FROM transactions t
JOIN blacklist b ON t.recipient_id = b.recipient_id
------------------
**Calculating Employee Salaries and Benefits in a Human Resources Database**
Develop a SQL query to calculate employee salaries and benefits in a human resources database. The company wants to calculate the total compensation for each employee, including salary, bonuses, and benefits.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "salary", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "bonuses",
        "columns": [
            {"name": "bonus_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "bonus_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "benefits",
        "columns": [
            {"name": "benefit_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "benefit_type", "type": "VARCHAR(100)"},
            {"name": "benefit_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT e.employee_id, e.name, e.salary, SUM(b.bonus_amount) AS total_bonuses, SUM(benefit_amount) AS total_benefits FROM employees e LEFT JOIN bonuses b ON e.employee_id = b.employee_id LEFT JOIN benefits ON e.employee_id = benefits.employee_id GROUP BY e.employee_id, e.name, e.salary
------------------
**Predicting Customer Churn for a Telecommunications Company**

A telecommunications company wants to identify customers who are likely to churn based on their historical usage patterns and demographic information. Develop a SQL query that predicts churn probability using a machine learning model.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "plan_type", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "DECIMAL(10, 2)"},
            {"name": "voice_usage", "type": "DECIMAL(10, 2)"},
            {"name": "minutes_used", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason_for_churn", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "machine_learning_model",
        "columns": [
            {"name": "model_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "predicted_churn_probability", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.age,
    c.gender,
    c.plan_type,
    SUM(u.data_usage) AS total_data_usage,
    SUM(u.voice_usage) AS total_voice_usage,
    SUM(u.minutes_used) AS total_minutes_used
FROM 
    customers c
JOIN 
    usage u ON c.customer_id = u.customer_id
WHERE 
    u.usage_date BETWEEN '2020-01-01' AND '2020-12-31'
GROUP BY 
    c.customer_id, c.name, c.email, c.age, c.gender, c.plan_type
ORDER BY 
    total_data_usage DESC

UNION ALL

SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.age,
    c.gender,
    c.plan_type,
    0 AS total_data_usage,
    0 AS total_voice_usage,
    0 AS total_minutes_used
FROM 
    customers c
LEFT JOIN 
    churn ch ON c.customer_id = ch.customer_id
WHERE 
    ch.customer_id IS NULL

WITH RECURSIVE churn_prediction AS (
    SELECT 
        c.customer_id,
        c.name,
        c.email,
        c.age,
        c.gender,
        c.plan_type,
        u.total_data_usage,
        u.total_voice_usage,
        u.total_minutes_used
    FROM 
        churn_prediction_base c
    JOIN 
        churn_prediction_base u ON c.customer_id = u.customer_id
    WHERE 
        c.customer_id IS NOT NULL
        AND u.total_data_usage > 100
    UNION ALL
    SELECT 
        c.customer_id,
        c.name,
        c.email,
        c.age,
        c.gender,
        c.plan_type,
        u.total_data_usage,
        u.total_voice_usage,
        u.total_minutes_used
    FROM 
        churn_prediction_base c
    JOIN 
        churn_prediction_base u ON c.customer_id = u.customer_id
    WHERE 
        c.customer_id IS NOT NULL
        AND u.total_data_usage <= 100
)
SELECT 
    customer_id,
    predicted_churn_probability
FROM 
    machine_learning_model
CROSS JOIN 
    churn_prediction
WHERE 
    predicted_churn_probability >= 0.5
------------------
**Analyzing Sales Trends for an E-commerce Company**

An e-commerce company wants to analyze sales trends by product category, region, and time of year. Develop a SQL query that generates a report showing the top-selling products in each category, along with their sales volumes and revenue.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  p.product_category, 
  p.product_name, 
  SUM(o.quantity) AS sales_volume, 
  SUM(o.quantity * o.price) AS revenue
FROM 
  products p
  JOIN order_items oi ON p.product_id = oi.product_id
  JOIN orders o ON oi.order_id = o.order_id
GROUP BY 
  p.product_category, 
  p.product_name
------------------
**Managing Inventory Levels for a Retail Company**

A retail company wants to optimize its inventory levels by identifying the products that are running low and need to be reordered. Develop a SQL query that generates a report showing the products that are below a certain threshold, along with their current stock levels and reorder quantities.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "stock_level", "type": "INT"},
            {"name": "reorder_quantity", "type": "INT"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.product_name, i.stock_level, i.reorder_quantity
FROM products p
JOIN inventory i ON p.product_id = i.product_id
WHERE i.stock_level < 10;
------------------
Perform a Time-Series Analysis to Predict Sales Revenue by Region and Product Category
Analyze the historical sales data to forecast future sales revenue for each region and product category, considering the seasonal fluctuations and trends in the data.
Schema:
[
    {
        "name": "sales_data",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "product_category", "type": "VARCHAR(50)"},
            {"name": "sales_revenue", "type": "DECIMAL(10,2)"},
            {"name": "season", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(50)"},
            {"name": "region_code", "type": "VARCHAR(10)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(50)"},
            {"name": "product_category_code", "type": "VARCHAR(10)"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "season_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "season_name", "type": "VARCHAR(20)"},
            {"name": "season_start_date", "type": "DATE"},
            {"name": "season_end_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    pc.product_category_name, 
    SUM(sd.sales_revenue) AS total_sales_revenue, 
    AVG(sd.sales_revenue) AS average_sales_revenue, 
    LAG(SUM(sd.sales_revenue)) OVER (PARTITION BY r.region_name, pc.product_category_name ORDER BY sd.date) AS previous_year_sales_revenue, 
    LAG(AVG(sd.sales_revenue)) OVER (PARTITION BY r.region_name, pc.product_category_name ORDER BY sd.date) AS previous_year_average_sales_revenue, 
    SUM(CASE WHEN sd.season = 'Winter' THEN sd.sales_revenue ELSE 0 END) AS winter_sales_revenue, 
    SUM(CASE WHEN sd.season = 'Spring' THEN sd.sales_revenue ELSE 0 END) AS spring_sales_revenue, 
    SUM(CASE WHEN sd.season = 'Summer' THEN sd.sales_revenue ELSE 0 END) AS summer_sales_revenue, 
    SUM(CASE WHEN sd.season = 'Autumn' THEN sd.sales_revenue ELSE 0 END) AS autumn_sales_revenue
FROM 
    sales_data sd
JOIN 
    regions r ON sd.region = r.region_name
JOIN 
    product_categories pc ON sd.product_category = pc.product_category_name
GROUP BY 
    r.region_name, 
    pc.product_category_name, 
    sd.date
ORDER BY 
    r.region_name, 
    pc.product_category_name, 
    sd.date
------------------
Identify High-Value Customers for Targeted Marketing Campaigns
Analyze the customer purchase history and behavioral data to identify high-value customers who have made significant purchases in the past, have high revenue potential, and are likely to respond to targeted marketing campaigns.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "customer_behavior",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "session_id", "type": "INT"},
            {"name": "session_date", "type": "DATE"},
            {"name": "page_views", "type": "INT"},
            {"name": "bounce_rate", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, SUM(o.order_total) AS total_spent, 
       (SELECT COUNT(*) 
        FROM customer_behavior cb 
        WHERE cb.customer_id = c.customer_id AND cb.session_date BETWEEN '2020-01-01' AND '2022-12-31') AS active_sessions,
       (SELECT COUNT(*) 
        FROM customer_behavior cb 
        WHERE cb.customer_id = c.customer_id AND cb.page_views > 5) AS engaged_customers
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name, c.email
HAVING SUM(o.order_total) > 1000 AND 
       (SELECT COUNT(*) 
        FROM customer_behavior cb 
        WHERE cb.customer_id = c.customer_id AND cb.session_date BETWEEN '2020-01-01' AND '2022-12-31') > 5 AND 
       (SELECT COUNT(*) 
        FROM customer_behavior cb 
        WHERE cb.customer_id = c.customer_id AND cb.page_views > 5) > 1
------------------
Analyze Customer Segmentation for Personalized Product Recommendations
Segment customers based on their demographic, behavioral, and transactional data to provide personalized product recommendations and improve customer engagement.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "product_purchases",
        "columns": [
            {"name": "product_id", "type": "INT"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "purchase_date", "type": "DATE"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customer_demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, cd.age, cd.income, COUNT(op.product_id) as total_purchases, SUM(op.order_total) as total_spend
FROM customers c
JOIN customer_demographics cd ON c.customer_id = cd.customer_id
JOIN product_purchases op ON c.customer_id = op.customer_id
GROUP BY c.customer_id, c.name, c.email, cd.age, cd.income
ORDER BY total_spend DESC
------------------
Optimize Inventory Management with Real-Time Stock Levels and Demand Forecasting
Develop a real-time inventory management system that uses historical sales data and current stock levels to forecast demand and optimize inventory levels across different warehouses and products.
Schema:
[
    {
        "name": "inventory",
        "columns": [
            {"name": "item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "stock_level", "type": "INT"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "warehouse_address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_history",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "item_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES inventory(item_id)"]},
            {"name": "order_quantity", "type": "INT"}
        ]
    },
    {
        "name": "demand_forecast",
        "columns": [
            {"name": "item_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES inventory(item_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "forecast_date", "type": "DATE"},
            {"name": "forecast_quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    i.item_id, 
    w.warehouse_name, 
    i.product_name, 
    i.stock_level, 
    AVG(sh.order_quantity) as avg_daily_sales, 
    DATEDIFF(CURRENT_DATE, sh.order_date) as days_since_last_sale
FROM 
    inventory i
JOIN 
    sales_history sh ON i.item_id = sh.item_id
JOIN 
    warehouses w ON i.warehouse_id = w.warehouse_id
GROUP BY 
    i.item_id, w.warehouse_name, i.product_name, i.stock_level
ORDER BY 
    i.item_id, w.warehouse_name, i.product_name;
------------------
Identify Bottlenecks in Supply Chain Operations with Real-Time Tracking and Analysis
Develop a real-time tracking and analysis system to monitor supply chain operations, identify bottlenecks, and optimize logistics and transportation processes.
Schema:
[
    {
        "name": "shipments",
        "columns": [
            {"name": "shipment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "carrier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES carriers(carrier_id)"]},
            {"name": "shipment_status", "type": "VARCHAR(50)"},
            {"name": "shipment_date", "type": "DATE"},
            {"name": "expected_delivery_date", "type": "DATE"}
        ]
    },
    {
        "name": "carriers",
        "columns": [
            {"name": "carrier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "carrier_name", "type": "VARCHAR(255)"},
            {"name": "carrier_address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory_levels",
        "columns": [
            {"name": "item_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES inventory(item_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "inventory_level", "type": "INT"}
        ]
    },
    {
        "name": "transportation_costs",
        "columns": [
            {"name": "shipment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES shipments(shipment_id)"]},
            {"name": "carrier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES carriers(carrier_id)"]},
            {"name": "transportation_cost", "type": "DECIMAL(10,2)"},
            {"name": "transportation_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  s.shipment_id, 
  c.carrier_name, 
  s.shipment_status, 
  s.shipment_date, 
  s.expected_delivery_date, 
  tc.transportation_cost, 
  il.inventory_level
FROM 
  shipments s
  JOIN carriers c ON s.carrier_id = c.carrier_id
  JOIN transportation_costs tc ON s.shipment_id = tc.shipment_id
  JOIN inventory_levels il ON s.shipment_id = il.item_id
WHERE 
  s.shipment_status = 'delayed' 
  AND tc.transportation_cost > (SELECT AVG(transportation_cost) FROM transportation_costs)
------------------
Analyze customer purchase behavior and identify top-selling products by region, taking into account seasonal fluctuations and item categories.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "seasonality", "type": "TINYINT"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "SMALLINT"}
        ]
    }
]
Response:
SELECT 
  p.category, 
  p.seasonality, 
  p.product_name, 
  SUM(oi.quantity) AS total_quantity, 
  SUM(o.order_total) AS total_revenue
FROM 
  orders o
JOIN 
  order_items oi ON o.order_id = oi.order_id
JOIN 
  products p ON oi.product_id = p.product_id
WHERE 
  o.order_date BETWEEN '2022-01-01' AND '2022-12-31'
GROUP BY 
  p.category, 
  p.seasonality, 
  p.product_name
ORDER BY 
  total_revenue DESC
------------------
Develop a financial forecasting model to predict quarterly revenue growth for a retail company, incorporating historical sales data, seasonal trends, and marketing campaign effectiveness.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "quarter", "type": "VARCHAR(10)"},
            {"name": "year", "type": "SMALLINT"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "seasonality", "type": "TINYINT"}
        ]
    },
    {
        "name": "marketing_campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "campaign_sales",
        "columns": [
            {"name": "campaign_sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES marketing_campaigns(campaign_id)"]},
            {"name": "quarter", "type": "VARCHAR(10)"},
            {"name": "year", "type": "SMALLINT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    s.quarter, 
    s.year, 
    s.revenue, 
    p.seasonality,
    c.campaign_name
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
JOIN 
    marketing_campaigns mc ON s.quarter = mc.quarter AND s.year = mc.year
JOIN 
    campaign_sales cs ON mc.campaign_id = cs.campaign_id AND s.quarter = cs.quarter AND s.year = cs.year
JOIN 
    marketing_campaigns c ON cs.campaign_id = c.campaign_id
GROUP BY 
    s.quarter, 
    s.year, 
    p.seasonality, 
    c.campaign_name
ORDER BY 
    s.quarter, 
    s.year
------------------
Identify high-value customers who have purchased similar products in the past, and provide personalized product recommendations based on their purchase history and preferences.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_history", "type": "TEXT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT p.product_name, p.category, p.price 
FROM products p 
JOIN orders o ON p.product_id = o.product_id 
WHERE o.customer_id IN (
  SELECT customer_id 
  FROM customers 
  WHERE purchase_history LIKE '%product_name%' 
  GROUP BY customer_id 
  HAVING COUNT(DISTINCT product_name) > 1
)
------------------
Develop a data warehouse schema to support a large-scale e-commerce business, incorporating sales, customer, and product data from multiple sources, and implementing a star schema design with fact and dimension tables.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "SMALLINT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
CREATE TABLE sales (
    sale_id INT PRIMARY KEY,
    order_id INT,
    product_id INT,
    quantity SMALLINT,
    revenue DECIMAL(10, 2),
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    customer_id INT,
    order_date DATE,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(255),
    email VARCHAR(255),
    location VARCHAR(255)
);

CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(255),
    category VARCHAR(50),
    price DECIMAL(10, 2)
);

CREATE TABLE fact_sales (
    sale_id INT,
    order_id INT,
    product_id INT,
    quantity SMALLINT,
    revenue DECIMAL(10, 2),
    order_date DATE,
    customer_id INT,
    product_name VARCHAR(255),
    category VARCHAR(50),
    price DECIMAL(10, 2),
    PRIMARY KEY (sale_id),
    FOREIGN KEY (sale_id) REFERENCES sales(sale_id),
    FOREIGN KEY (order_id) REFERENCES orders(order_id),
    FOREIGN KEY (product_id) REFERENCES products(product_id)
);

INSERT INTO fact_sales (sale_id, order_id, product_id, quantity, revenue, order_date, customer_id, product_name, category, price)
SELECT s.sale_id, s.order_id, p.product_id, s.quantity, s.revenue, o.order_date, o.customer_id, p.product_name, p.category, p.price
FROM sales s
JOIN orders o ON s.order_id = o.order_id
JOIN products p ON s.product_id = p.product_id;
------------------
Perform a sentiment analysis on customer reviews to identify trends and patterns in their opinions about a company's products, and provide recommendations for improving customer satisfaction.
Schema:
[
    {
        "name": "reviews",
        "columns": [
            {"name": "review_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "review_text", "type": "TEXT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    products.product_name, 
    products.category, 
    reviews.review_text, 
    sentiment.sentiment 
FROM 
    reviews 
JOIN 
    products ON reviews.product_id = products.product_id 
JOIN 
    (SELECT 
         review_text, 
         CASE 
             WHEN REGEXP_MATCH(review_text, r'[a-zA-Z0-9\+\-\*]') THEN 1 
             ELSE 0 
         END 
     AS sentiment 
     FROM 
         reviews) AS sentiment ON reviews.review_text = sentiment.review_text
------------------
Develop a predictive model to forecast inventory levels for a retail company, incorporating historical sales data, product seasonality, and supplier lead times.
Schema:
[
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "quantity", "type": "SMALLINT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "seasonality", "type": "TINYINT"}
        ]
    },
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "supplier_leads",
        "columns": [
            {"name": "lead_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "supplier_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES suppliers(supplier_id)"]},
            {"name": "lead_time", "type": "SMALLINT"}
        ]
    },
    {
        "name": "suppliers",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "supplier_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT inventory_id, product_id, store_id, 
       quantity, 
       LAG(quantity, 1) OVER (PARTITION BY product_id ORDER BY date) AS prev_quantity, 
       products.seasonality, 
       supplier_leads.lead_time
FROM inventory
JOIN products ON inventory.product_id = products.product_id
JOIN supplier_leads ON products.product_id = supplier_leads.product_id
WHERE date BETWEEN '2020-01-01' AND '2020-12-31'
------------------
Analyze customer churn rates and identify the most significant factors contributing to customer attrition, using a combination of machine learning algorithms and statistical analysis.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn_rates",
        "columns": [
            {"name": "churn_rate_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.location, 
  COUNT(o.order_id) AS total_orders, 
  SUM(CASE WHEN cr.churn_date IS NOT NULL THEN 1 ELSE 0 END) AS churned,
  SUM(CASE WHEN cr.churn_date IS NULL THEN 1 ELSE 0 END) AS active
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN churn_rates cr ON c.customer_id = cr.customer_id
GROUP BY 
  c.customer_id, 
  c.name, 
  c.email, 
  c.location
ORDER BY 
  total_orders DESC
------------------
Develop a data visualization dashboard to display sales performance metrics for a retail company, including sales growth, product category performance, and geographic sales distribution.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "SMALLINT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  'Sales Growth' AS metric,
  SUM(CASE WHEN YEAR(t2.order_date) = 2022 THEN t1.revenue ELSE 0 END) AS revenue_2022,
  SUM(CASE WHEN YEAR(t2.order_date) = 2023 THEN t1.revenue ELSE 0 END) AS revenue_2023,
  (SUM(CASE WHEN YEAR(t2.order_date) = 2023 THEN t1.revenue ELSE 0 END) - SUM(CASE WHEN YEAR(t2.order_date) = 2022 THEN t1.revenue ELSE 0 END)) AS growth_rate
FROM sales t1
JOIN orders t2 ON t1.order_id = t2.order_id
JOIN customers t3 ON t2.customer_id = t3.customer_id
WHERE t3.location IN ('New York', 'Los Angeles', 'Chicago')
GROUP BY t3.location

SELECT 
  t2.category AS product_category,
  SUM(t1.revenue) AS total_revenue
FROM sales t1
JOIN products t2 ON t1.product_id = t2.product_id
GROUP BY t2.category

SELECT 
  t3.location AS geographic_location,
  SUM(t1.revenue) AS total_revenue
FROM sales t1
JOIN orders t2 ON t1.order_id = t2.order_id
JOIN customers t3 ON t2.customer_id = t3.customer_id
GROUP BY t3.location
------------------
**Identify Top Performing Sales Territories by Revenue and Customer Growth Rate**

A retail company wants to analyze sales performance across different territories to identify areas with high revenue and customer growth rates. The goal is to provide a ranking of top-performing territories based on these two metrics.
Schema:
[
    {
        "name": "territories",
        "columns": [
            {"name": "territory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "territory_name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "territory_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES territories(territory_id)"]},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "created_at", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    t.territory_name, 
    t.region, 
    SUM(o.total_revenue) AS total_revenue, 
    COUNT(c.customer_id) AS customer_count, 
    ROUND((COUNT(c.customer_id) - (SELECT COUNT(*) FROM customers WHERE created_at < DATE('2022-01-01') AND territory_id = t.territory_id)) / COUNT(c.customer_id), 2) AS growth_rate
FROM 
    territories t
JOIN 
    customers c ON t.territory_id = c.territory_id
JOIN 
    orders o ON c.customer_id = o.customer_id
GROUP BY 
    t.territory_name, t.region
ORDER BY 
    total_revenue DESC, growth_rate DESC
------------------
**Predict Customer Churn by Analyzing Historical Payment Behavior and Demographics**

A financial services company wants to identify customers who are likely to churn based on their historical payment behavior and demographic characteristics. The goal is to develop a predictive model that can flag high-risk customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "account_open_date", "type": "DATE"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10,2)"},
            {"name": "payment_method", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, p.payment_date, p.amount, d.age, d.income, p.payment_method
FROM customers c
JOIN payments p ON c.customer_id = p.customer_id
JOIN demographics d ON c.name = d.name
WHERE p.payment_date > '2020-01-01'
GROUP BY c.customer_id, c.name, c.email, p.payment_date, p.amount, d.age, d.income, p.payment_method
HAVING SUM(CASE WHEN p.amount < 100 THEN 1 ELSE 0 END) > 5
    AND AVG(d.income) < 50000
ORDER BY c.customer_id, p.payment_date;
------------------
**Optimize Inventory Management by Identifying Slow-Moving Products and Stock Levels**

An e-commerce company wants to analyze inventory levels and sales patterns to identify slow-moving products and optimize stock levels. The goal is to provide a list of products with low sales and inventory levels.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "stock_level", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name 
FROM products p 
JOIN inventory i ON p.product_id = i.product_id 
LEFT JOIN (
  SELECT product_id, SUM(quantity) AS total_sales 
  FROM order_items 
  GROUP BY product_id 
) o ON p.product_id = o.product_id 
WHERE i.stock_level < 5 AND (o.total_sales IS NULL OR o.total_sales < 10)
------------------
**Analyze Academic Performance by Examining Student Enrollment and Course Completion Rates**

An educational institution wants to analyze student enrollment and course completion rates to identify areas for improvement. The goal is to provide a report on student performance by department and course.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "enrollment_date", "type": "DATE"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "enrollment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES enrollments(enrollment_id)"]},
            {"name": "grade", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT s.department, c.course_name, COUNT(g.grade_id) AS completion_rate
FROM students s
JOIN enrollments e ON s.student_id = e.student_id
JOIN courses c ON e.course_id = c.course_id
JOIN grades g ON e.enrollment_id = g.enrollment_id
GROUP BY s.department, c.course_name
------------------
**Analyzing Customer Churn and Predicting Future Churn**

A retail company wants to analyze customer churn and predict which customers are likely to churn in the next 6 months. They have a database with customer information, order history, and purchase data. The company wants to identify the top 10% of customers who are most likely to churn and provide personalized offers to retain them.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"},
            {"name": "date", "type": "DATE"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customer_behavior",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "purchase_frequency", "type": "INT"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"},
            {"name": "last_purchase_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT customer_id 
FROM customer_behavior 
WHERE purchase_frequency < 3 
AND average_order_value < 100 
AND last_purchase_date < DATE('now', '-6 months') 
ORDER BY purchase_frequency DESC, average_order_value DESC 
LIMIT 0.1 * (SELECT COUNT(*) FROM customer_behavior);
------------------
**Identifying High-Value Customers and Optimizing Marketing Efforts**

A marketing agency wants to identify high-value customers who have spent over $1,000 with them in the past year and optimize their marketing efforts to target these customers. They have a database with customer information, order history, and purchase data. The agency wants to create a ranked list of customers by their total spend, exclude customers who have not made a purchase in the past year, and provide insights on the products they have purchased.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"},
            {"name": "date", "type": "DATE"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customer_behavior",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "purchase_frequency", "type": "INT"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"},
            {"name": "last_purchase_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, SUM(p.total_amount) AS total_spend, 
       c.signup_date, ROW_NUMBER() OVER (ORDER BY SUM(p.total_amount) DESC) AS ranking
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN (
  SELECT order_id, SUM(total_amount) AS total_amount
  FROM orders
  WHERE order_date > CURRENT_DATE - INTERVAL 1 YEAR
  GROUP BY order_id
) p ON o.order_id = p.order_id
WHERE o.order_date > CURRENT_DATE - INTERVAL 1 YEAR
GROUP BY c.customer_id, c.name, c.email, c.signup_date
HAVING SUM(p.total_amount) > 1000
ORDER BY total_spend DESC
------------------
**Predicting Stock Prices Using Machine Learning**

A finance company wants to predict stock prices using historical data. They have a database with stock information, including prices, trading volumes, and economic indicators. The company wants to train a machine learning model to predict the next day's closing price based on the previous 30 days of data.
Schema:
[
    {
        "name": "stocks",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "exchange", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "price_history",
        "columns": [
            {"name": "price_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "opening_price", "type": "DECIMAL(10, 2)"},
            {"name": "closing_price", "type": "DECIMAL(10, 2)"},
            {"name": "trading_volume", "type": "INT"}
        ]
    },
    {
        "name": "economic_indicators",
        "columns": [
            {"name": "indicator_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "indicator_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT p.closing_price, 
       SUM(e.indicator_value) AS sum_indicators, 
       e.date, 
       p.stock_id, 
       p.date AS price_date
FROM price_history p
JOIN economic_indicators e ON p.stock_id = e.stock_id
WHERE p.date = e.date AND p.stock_id = 1
AND p.date BETWEEN (SELECT DATE('now') - INTERVAL 30 DAY) AND DATE('now')
ORDER BY p.date DESC
LIMIT 30;
------------------
**Analyze Customer Purchase Behavior and Predict Future Sales**
Develop a SQL query to identify the top 10 customers who have made repeat purchases within the last 6 months, grouped by product category, and predict their future sales based on their purchase history.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_sales",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  p.category, 
  SUM(oi.quantity) AS total_quantity, 
  SUM(ps.sales_amount) AS total_sales, 
  DATEDIFF('now', o.order_date) AS days_since_last_purchase 
FROM 
  customers c 
  JOIN orders o ON c.customer_id = o.customer_id 
  JOIN order_items oi ON o.order_id = oi.order_id 
  JOIN products p ON oi.product_id = p.product_id 
  JOIN (
    SELECT 
      product_id, 
      MAX(sales_date) AS max_sales_date 
    FROM 
      product_sales 
    WHERE 
      sales_date >= DATE('now', '-6 months') 
    GROUP BY 
      product_id 
  ) ps ON p.product_id = ps.product_id 
WHERE 
  o.order_date >= DATE('now', '-6 months') 
GROUP BY 
  c.customer_id, 
  p.category 
ORDER BY 
  total_quantity DESC 
LIMIT 10
------------------
**Identify High-Risk Accounts and Predict Default Probability**
Develop a SQL query to identify high-risk accounts with a default probability greater than 10% and predict the likelihood of default for each account based on their credit history, income, and employment status.
Schema:
[
    {
        "name": "accounts",
        "columns": [
            {"name": "account_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "balance", "type": "DECIMAL(10, 2)"},
            {"name": "credit_score", "type": "INT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "income", "type": "DECIMAL(10, 2)"},
            {"name": "employment_status", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "credit_history",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "default_date", "type": "DATE"},
            {"name": "default_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "risk_factors",
        "columns": [
            {"name": "account_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES accounts(account_id)"]},
            {"name": "risk_score", "type": "INT"},
            {"name": "default_probability", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT a.account_id, a.customer_id, c.name, c.income, c.employment_status, b.default_probability 
FROM accounts a 
JOIN customers c ON a.customer_id = c.customer_id 
JOIN risk_factors b ON a.account_id = b.account_id 
WHERE b.default_probability > 0.1
------------------
**Analyze Sales Trends and Identify Product Cannibalization**
Develop a SQL query to analyze sales trends for a retail company and identify product cannibalization by calculating the percentage of sales lost due to the introduction of a new product.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "new_products",
        "columns": [
            {"name": "new_product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "introduction_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  p.product_name, 
  np.introduction_date, 
  SUM(s.sales_amount) AS total_sales, 
  SUM(CASE WHEN s.sales_date < np.introduction_date THEN s.sales_amount ELSE 0 END) AS pre_introduction_sales, 
  ROUND((SUM(CASE WHEN s.sales_date < np.introduction_date THEN s.sales_amount ELSE 0 END) / SUM(s.sales_amount)) * 100, 2) AS sales_lost_percentage
FROM 
  sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN new_products np ON p.product_id = np.product_id
GROUP BY 
  p.product_name, 
  np.introduction_date
------------------
**Predict Customer Churn and Identify Key Drivers**
Develop a SQL query to predict customer churn and identify key drivers of churn by analyzing customer behavior, demographics, and product usage.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "product_usage",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "usage_date", "type": "DATE"}
        ]
    },
    {
        "name": "customer_demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.purchase_date,
    o.order_date,
    p.product_id,
    pu.usage_date,
    cd.age,
    cd.income
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    product_usage pu ON c.customer_id = pu.customer_id
JOIN 
    customer_demographics cd ON c.customer_id = cd.customer_id
JOIN 
    products p ON pu.product_id = p.product_id
WHERE 
    c.purchase_date < (SELECT AVG(purchase_date) FROM customers)
    OR (c.purchase_date IS NULL AND o.order_date < (SELECT AVG(purchase_date) FROM customers))
ORDER BY 
    c.customer_id
LIMIT 
    1000
------------------
**Analyzing Customer Purchase Behavior and Identifying High-Value Customers**

A retail company wants to analyze customer purchase behavior and identify high-value customers. The company has a complex database schema with multiple tables containing information about customers, orders, products, and sales. The objective is to write a SQL query that can retrieve the top 10% of customers who have spent the most money across all orders, and provide details such as the total amount spent, the average order value, and the number of orders made.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"},
            {"name": "phone", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "TEXT"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    SUM(o.total_amount) AS total_amount_spent,
    AVG(o.total_amount) AS average_order_value,
    COUNT(o.order_id) AS num_orders
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id
ORDER BY total_amount_spent DESC
LIMIT (SELECT COUNT(*) * 0.1 FROM orders);
------------------
**Forecasting Sales and Inventory for an E-commerce Company**

An e-commerce company wants to forecast sales and inventory levels for the next quarter. The company has a database schema with tables containing information about products, orders, sales, and inventory levels. The objective is to write a SQL query that can predict sales and inventory levels based on historical data, and provide a forecast for the next quarter.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "reorder_level", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  P.product_name, 
  SUM(S.sale_amount) AS total_sales, 
  I.quantity AS current_inventory, 
  DATEDIFF('DATE', I.reorder_level, 'DATE') AS days_until_reorder
FROM 
  products P
  JOIN sales S ON P.product_id = S.order_id
  JOIN inventory I ON P.product_id = I.product_id
WHERE 
  S.sale_date >= DATE('2022-01-01') AND S.sale_date <= DATE('2022-03-31')
GROUP BY 
  P.product_name, I.quantity, I.reorder_level
ORDER BY 
  total_sales DESC, product_name ASC;
------------------
**Analyzing Customer Churn and Identifying High-Risk Customers**

A telecom company wants to analyze customer churn and identify high-risk customers. The company has a database schema with tables containing information about customers, plans, payments, and cancellations. The objective is to write a SQL query that can retrieve the top 10% of customers who are most likely to churn within the next 3 months, and provide details such as the customer's name, plan type, payment history, and cancellation reason.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "plans",
        "columns": [
            {"name": "plan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "plan_type", "type": "VARCHAR(255)"},
            {"name": "plan_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "payment_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "cancellations",
        "columns": [
            {"name": "cancellation_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "cancellation_date", "type": "DATE"},
            {"name": "cancellation_reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.name, p.plan_type, p.plan_price, 
       COALESCE(SUM(p.payment_amount), 0) AS total_payment,
       COALESCE(SUM(CASE WHEN c.cancellation_date IS NOT NULL THEN 1 ELSE 0 END), 0) AS cancellation_count,
       c.cancellation_reason
FROM customers c
LEFT JOIN plans p ON c.customer_id = p.customer_id
LEFT JOIN payments pp ON c.customer_id = pp.customer_id
LEFT JOIN cancellations cn ON c.customer_id = cn.customer_id
WHERE c.customer_id IN (
  SELECT customer_id
  FROM (
    SELECT customer_id, 
           DENSE_RANK() OVER (PARTITION BY customer_id ORDER BY payment_date DESC) AS payment_rank
    FROM payments
  ) AS subquery
  WHERE payment_rank <= 3
)
OR c.customer_id IN (
  SELECT customer_id
  FROM cancellations
  WHERE cancellation_date BETWEEN CURRENT_DATE AND CURRENT_DATE + INTERVAL 3 MONTH
)
GROUP BY c.name, p.plan_type, p.plan_price, c.cancellation_reason
ORDER BY total_payment DESC
LIMIT 0.1 * (SELECT COUNT(*) FROM customers);
------------------
**Identifying Product Bundles and Pricing Strategies**

A retail company wants to identify product bundles and pricing strategies that are most effective in driving sales. The company has a database schema with tables containing information about products, orders, and sales. The objective is to write a SQL query that can retrieve the top 3 product bundles that have the highest average revenue per user (ARPU), and provide details such as the product bundle name, average revenue per user, and the number of orders made.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_bundles",
        "columns": [
            {"name": "bundle_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "bundle_price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT pb.product_bundle_name, 
       AVG(o.total_amount) as average_revenue_per_user, 
       COUNT(o.order_id) as number_of_orders
FROM product_bundles pb
JOIN orders o ON pb.product_id = o.product_id
GROUP BY pb.product_bundle_name
ORDER BY average_revenue_per_user DESC
LIMIT 3
------------------
**Analyzing Employee Performance and Identifying Top Performers**

A company wants to analyze employee performance and identify top performers. The company has a database schema with tables containing information about employees, performance metrics, and sales data. The objective is to write a SQL query that can retrieve the top 5 employees who have the highest sales revenue, and provide details such as the employee's name, job title, sales revenue, and sales growth rate.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "job_title", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "performance_metrics",
        "columns": [
            {"name": "metric_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "metric_name", "type": "VARCHAR(255)"},
            {"name": "metric_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT e.name, e.job_title, SUM(sd.sale_amount) AS total_sales, 
       ((SUM(sd.sale_amount) - (SELECT SUM(sd2.sale_amount) FROM sales_data sd2 WHERE sd2.sale_date < sd.sale_date)) / 
       (SELECT SUM(sd2.sale_amount) FROM sales_data sd2 WHERE sd2.sale_date < sd.sale_date) * 100) AS sales_growth_rate
FROM employees e
JOIN sales_data sd ON e.employee_id = sd.employee_id
GROUP BY e.employee_id, e.name, e.job_title
ORDER BY total_sales DESC
LIMIT 5
------------------
**Identifying Customer Segments and Predicting Churn**

A telecom company wants to identify customer segments and predict churn. The company has a database schema with tables containing information about customers, plans, payments, and cancellations. The objective is to write a SQL query that can retrieve the top 3 customer segments that are most likely to churn within the next 3 months, and provide details such as the segment name, churn probability, and average revenue per user (ARPU).
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "plans",
        "columns": [
            {"name": "plan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "plan_type", "type": "VARCHAR(255)"},
            {"name": "plan_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "payment_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "cancellations",
        "columns": [
            {"name": "cancellation_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "cancellation_date", "type": "DATE"},
            {"name": "cancellation_reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  s.segment_name,
  COUNT(c.customer_id) AS customer_count,
  AVG(p.payment_amount) AS arpu,
  (SELECT COUNT(*) FROM cancellations c2 WHERE c2.customer_id = c.customer_id AND c2.cancellation_date BETWEEN '2023-03-01' AND '2023-03-31') / COUNT(c.customer_id) AS churn_probability
FROM 
  (
    SELECT 
      customer_id,
      (CASE 
        WHEN plan_type = 'Basic' THEN 'Segment 1'
        WHEN plan_type = 'Premium' THEN 'Segment 2'
        ELSE 'Segment 3'
      END) AS segment_name
    FROM 
      plans
  ) p
  JOIN customers c ON p.customer_id = c.customer_id
  JOIN payments p ON p.customer_id = c.customer_id
GROUP BY 
  s.segment_name
ORDER BY 
  churn_probability DESC
LIMIT 3
------------------
**Forecasting Sales by Product Category in the Next Quarter**

An e-commerce company wants to forecast sales for the next quarter by product category. They provide historical sales data for the last three years, product categorization information, and seasonal sales patterns. The goal is to generate a sales forecast for each product category in the next quarter.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "seasonal_sales",
        "columns": [
            {"name": "season_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "season_name", "type": "VARCHAR(255)"},
            {"name": "season_start_date", "type": "DATE"},
            {"name": "season_end_date", "type": "DATE"}
        ]
    },
    {
        "name": "sales_patterns",
        "columns": [
            {"name": "pattern_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "pattern_name", "type": "VARCHAR(255)"},
            {"name": "pattern_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.category_name, 
  s.sales_amount, 
  EXTRACT(YEAR FROM sales_date) + (EXTRACT(MONTH FROM sales_date) / 3) AS quarter
FROM 
  sales s
JOIN 
  products p ON s.product_id = p.product_id
JOIN 
  categories c ON p.category_id = c.category_id
WHERE 
  EXTRACT(MONTH FROM sales_date) IN (3, 6, 9, 12)
ORDER BY 
  c.category_name, 
  s.sales_amount DESC
------------------
**Identifying High-Risk Customers for Credit Card Issuance**

A fintech company wants to identify high-risk customers for credit card issuance based on their credit history, transaction patterns, and demographic information. They provide a dataset containing customer information, transaction history, and credit scores.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "transaction_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "credit_scores",
        "columns": [
            {"name": "score_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "credit_score", "type": "INT"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email 
FROM customers c 
JOIN demographics d ON c.customer_id = d.customer_id 
JOIN credit_scores cs ON c.customer_id = cs.customer_id 
JOIN transactions t ON c.customer_id = t.customer_id 
WHERE cs.credit_score < 600 
AND t.transaction_amount > (SELECT AVG(transaction_amount) FROM transactions) 
AND d.age < 30;
------------------
Analyze customer purchase behavior across different product categories and identify the top 5 product categories with the highest average order value (AOV) for each age group.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"},
            {"name": "item_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    o.product_category, 
    c.age, 
    AVG(o.order_value) AS avg_order_value
FROM 
    orders o
JOIN 
    customers c ON o.customer_id = c.customer_id
GROUP BY 
    o.product_category, 
    c.age
ORDER BY 
    o.product_category, 
    c.age
LIMIT 
    5;

WITH 
    age_groups AS (
        SELECT 
            c.age, 
            AVG(o.order_value) AS avg_order_value
        FROM 
            orders o
        JOIN 
            customers c ON o.customer_id = c.customer_id
        GROUP BY 
            c.age
    ),
    product_categories AS (
        SELECT 
            o.product_category, 
            AVG(o.order_value) AS avg_order_value
        FROM 
            orders o
        GROUP BY 
            o.product_category
    )
SELECT 
    pc.product_category, 
    ag.age, 
    pc.avg_order_value AS avg_order_value
FROM 
    age_groups ag
CROSS JOIN 
    product_categories pc
ORDER BY 
    pc.avg_order_value DESC
LIMIT 
    5;
------------------
Identify the top 3 products with the highest sales growth rate in the past 12 months across all regions, and also provide the total sales revenue for each of these products in the current month.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    p.product_name, 
    SUM(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = EXTRACT(YEAR FROM CURRENT_DATE) THEN s.quantity * s.price ELSE 0 END) AS current_month_sales, 
    (SUM(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = EXTRACT(YEAR FROM CURRENT_DATE) THEN s.quantity * s.price ELSE 0 END) 
     - LAG(SUM(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = EXTRACT(YEAR FROM CURRENT_DATE) THEN s.quantity * s.price ELSE 0 END), 1, 0) OVER (PARTITION BY p.product_id ORDER BY s.sale_date)) / 
    LAG(SUM(CASE WHEN EXTRACT(YEAR FROM s.sale_date) = EXTRACT(YEAR FROM CURRENT_DATE) THEN s.quantity * s.price ELSE 0 END), 1, 0) OVER (PARTITION BY p.product_id ORDER BY s.sale_date) * 100 AS sales_growth_rate
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
WHERE 
    s.sale_date BETWEEN CURRENT_DATE - INTERVAL 12 month AND CURRENT_DATE
GROUP BY 
    p.product_name
ORDER BY 
    sales_growth_rate DESC
LIMIT 
    3
------------------
Analyze the sales performance of different sales representatives across various regions and identify the top 3 sales representatives with the highest total sales revenue in each region.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sales_rep_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_reps(sales_rep_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_reps",
        "columns": [
            {"name": "sales_rep_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "rep_name", "type": "VARCHAR(255)"},
            {"name": "commission_rate", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT r.region_name, sr.rep_name, SUM(s.quantity * s.price) AS total_revenue
FROM sales s
JOIN sales_reps sr ON s.sales_rep_id = sr.sales_rep_id
JOIN regions r ON s.region = r.region_name
GROUP BY r.region_name, sr.rep_name
ORDER BY r.region_name, total_revenue DESC
LIMIT 3;
------------------
Perform a time-series analysis of the sales data and identify the month with the highest sales revenue for each product category across all regions.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT pc.category_name, 
       EXTRACT(MONTH FROM s.sale_date) AS sale_month, 
       SUM(s.quantity * s.price) AS total_sales
FROM sales s
JOIN products p ON s.product_id = p.product_id
JOIN product_categories pc ON p.category = pc.category_name
GROUP BY pc.category_name, EXTRACT(MONTH FROM s.sale_date)
ORDER BY total_sales DESC;

SELECT pc.category_name, 
       EXTRACT(MONTH FROM s.sale_date) AS sale_month, 
       total_sales
FROM (
  SELECT pc.category_name, 
         EXTRACT(MONTH FROM s.sale_date) AS sale_month, 
         SUM(s.quantity * s.price) AS total_sales
  FROM sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN product_categories pc ON p.category = pc.category_name
  GROUP BY pc.category_name, EXTRACT(MONTH FROM s.sale_date)
) AS subquery
WHERE total_sales = (SELECT MAX(total_sales) FROM (
  SELECT pc.category_name, 
         EXTRACT(MONTH FROM s.sale_date) AS sale_month, 
         SUM(s.quantity * s.price) AS total_sales
  FROM sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN product_categories pc ON p.category = pc.category_name
  GROUP BY pc.category_name, EXTRACT(MONTH FROM s.sale_date)
) AS subquery)
------------------
Develop a customer segmentation analysis to identify the most valuable customers based on their purchase history and demographic information. Use clustering algorithms to group customers into segments and provide a detailed description of each segment, including their characteristics, preferences, and potential for future sales.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"},
            {"name": "order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.age, 
  c.gender, 
  AVG(o.order_value) AS average_order_value, 
  COUNT(DISTINCT o.order_id) AS number_of_orders, 
  COUNT(DISTINCT p.product_id) AS number_of_products_purchased
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN products p ON o.product_id = p.product_id
GROUP BY c.customer_id, c.name, c.email, c.age, c.gender
ORDER BY average_order_value DESC;

WITH customer_clusters AS (
  SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    AVG(o.order_value) AS average_order_value, 
    COUNT(DISTINCT o.order_id) AS number_of_orders, 
    COUNT(DISTINCT p.product_id) AS number_of_products_purchased
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN products p ON o.product_id = p.product_id
  GROUP BY c.customer_id, c.name, c.email, c.age, c.gender
), 
cluster_means AS (
  SELECT 
    AVG(average_order_value) AS cluster_mean_average_order_value, 
    AVG(number_of_orders) AS cluster_mean_number_of_orders, 
    AVG(number_of_products_purchased) AS cluster_mean_number_of_products_purchased
  FROM customer_clusters
)
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.age, 
  c.gender, 
  c.average_order_value, 
  c.number_of_orders, 
  c.number_of_products_purchased, 
  (c.average_order_value - (SELECT cluster_mean_average_order_value FROM cluster_means)) / (SELECT STDEV(average_order_value) FROM customer_clusters) AS z_score_average_order_value,
  (c.number_of_orders - (SELECT cluster_mean_number_of_orders FROM cluster_means)) / (SELECT STDEV(number_of_orders) FROM customer_clusters) AS z_score_number_of_orders,
  (c.number_of_products_purchased - (SELECT cluster_mean_number_of_products_purchased FROM cluster_means)) / (SELECT STDEV(number_of_products_purchased) FROM customer_clusters) AS z_score_number_of_products_purchased
FROM customer_clusters c
------------------
Develop a financial forecasting model to predict the future sales revenue for each product category across all regions. Use historical sales data and external market trends to inform the forecasting model.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "market_trends",
        "columns": [
            {"name": "trend_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "trend_name", "type": "VARCHAR(255)"},
            {"name": "trend_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    p.category, 
    r.region_name, 
    SUM(s.quantity * s.price) AS total_revenue, 
    SUM(s.quantity * s.price) * mt.trend_value AS predicted_revenue
FROM 
    sales s
INNER JOIN 
    products p ON s.product_id = p.product_id
INNER JOIN 
    regions r ON s.region = r.region_name
LEFT JOIN 
    market_trends mt ON p.category = mt.trend_name
GROUP BY 
    p.category, 
    r.region_name
ORDER BY 
    p.category, 
    r.region_name;
------------------
Optimize Inventory Management for a Retail Company
Develop a SQL query to analyze sales data across different product categories, identify underperforming categories, and provide recommendations for inventory optimization.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "inventory_quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "inventory_location", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.category, SUM(s.sale_amount) as total_sales, p.inventory_quantity
FROM products p
JOIN sales s ON p.product_id = s.product_id
GROUP BY p.category
HAVING SUM(s.sale_amount) < (SELECT AVG(total_sales) FROM (SELECT p.category, SUM(s.sale_amount) as total_sales FROM products p JOIN sales s ON p.product_id = s.product_id GROUP BY p.category) AS subquery)
------------------
Analyze Customer Segmentation for a Bank
Develop a SQL query to identify high-value customers, segment them based on their purchase behavior, and provide insights on their demographic characteristics.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "account_balance", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "transaction_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.account_balance,
    SUM(t.transaction_amount) AS total_spent,
    DATEDIFF('day', MIN(t.transaction_date), MAX(t.transaction_date)) AS transaction_period,
    d.age,
    d.income
FROM 
    customers c
JOIN 
    transactions t ON c.customer_id = t.customer_id
JOIN 
    demographics d ON c.customer_id = d.customer_id
WHERE 
    c.account_balance > 1000
GROUP BY 
    c.customer_id
HAVING 
    SUM(t.transaction_amount) > 1000
ORDER BY 
    total_spent DESC;
------------------
Predict Sales Revenue for a Tech Company
Develop a SQL query to forecast sales revenue based on historical sales data, and provide recommendations on marketing strategies to increase sales.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "marketing",
        "columns": [
            {"name": "marketing_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "marketing_campaign", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    s.sale_date, 
    s.revenue, 
    p.category 
FROM 
    sales s 
INNER JOIN 
    products p ON s.product_id = p.product_id 
WHERE 
    s.sale_date BETWEEN DATE('now', '-1 year') AND DATE('now') 
ORDER BY 
    s.revenue DESC
------------------
Identify Bottlenecks in a Supply Chain for a Manufacturing Company
Develop a SQL query to analyze order fulfillment data, identify delays in the supply chain, and provide recommendations for process optimization.
Schema:
[
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_status", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "shipments",
        "columns": [
            {"name": "shipment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "shipment_date", "type": "DATE"},
            {"name": "shipment_status", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  o.order_id, 
  w.warehouse_name, 
  s.shipment_date, 
  s.shipment_status, 
  o.order_status 
FROM 
  orders o 
  JOIN shipments s ON o.order_id = s.order_id 
  JOIN warehouses w ON s.warehouse_id = w.warehouse_id 
WHERE 
  s.shipment_status = 'Delayed' 
  OR o.order_status = 'Delayed' 
  OR s.shipment_date IS NULL 
ORDER BY 
  s.shipment_date ASC;
------------------
Analyze Employee Performance for an Educational Institution
Develop a SQL query to evaluate teacher performance based on student test scores, identify areas for improvement, and provide recommendations for professional development.
Schema:
[
    {
        "name": "teachers",
        "columns": [
            {"name": "teacher_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "subject", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "grade", "type": "INT"}
        ]
    },
    {
        "name": "test_scores",
        "columns": [
            {"name": "test_score_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "teacher_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES teachers(teacher_id)"]},
            {"name": "test_date", "type": "DATE"},
            {"name": "score", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT t.name, t.subject, AVG(ts.score) AS average_score
FROM teachers t
JOIN test_scores ts ON t.teacher_id = ts.teacher_id
GROUP BY t.name, t.subject
ORDER BY average_score ASC;
------------------
Analyze customer purchase behavior across different product categories and identify top-performing product categories based on average order value and customer retention rates.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "join_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_value", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "average_price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "product_variants",
        "columns": [
            {"name": "variant_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "variant_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "purchase_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "product_reviews",
        "columns": [
            {"name": "review_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "review_date", "type": "DATE"},
            {"name": "rating", "type": "INT"},
            {"name": "review_text", "type": "TEXT"}
        ]
    }
]
Response:
SELECT 
    p.category, 
    AVG(o.total_value) AS average_order_value, 
    COUNT(DISTINCT c.customer_id) AS customer_count, 
    (COUNT(DISTINCT c.customer_id) - (SELECT COUNT(DISTINCT customer_id) FROM orders WHERE order_date < DATE('now', '-6 months'))) / COUNT(DISTINCT c.customer_id) AS retention_rate
FROM 
    orders o
JOIN 
    products p ON o.product_id = p.product_id
JOIN 
    customers c ON o.customer_id = c.customer_id
GROUP BY 
    p.category
ORDER BY 
    average_order_value DESC
------------------
Identify the top 5 countries with the highest average order value (AOV) for each product category, and calculate the total revenue generated by each of these countries for the top 5 product categories.
Schema:
[
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "country", "type": "VARCHAR(255)"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    c.country, 
    p.product_category, 
    AVG(o.total_amount) AS average_order_value, 
    SUM(o.total_amount) * o.quantity AS total_revenue
FROM 
    orders o
JOIN 
    order_items oi ON o.order_id = oi.order_id
JOIN 
    products p ON oi.product_id = p.product_id
JOIN 
    customers c ON o.customer_id = c.customer_id
GROUP BY 
    c.country, p.product_category
ORDER BY 
    average_order_value DESC
LIMIT 5

UNION ALL

SELECT 
    c.country, 
    p.product_category, 
    AVG(o.total_amount) AS average_order_value, 
    SUM(o.total_amount) AS total_revenue
FROM 
    orders o
JOIN 
    customers c ON o.customer_id = c.customer_id
JOIN 
    products p ON o.product_id = p.product_id
GROUP BY 
    c.country, p.product_category
ORDER BY 
    average_order_value DESC
LIMIT 5
------------------
Analyze the sales performance of products in different regions, taking into account the time of year and the local holidays. Calculate the average sales quantity and revenue for each product in each region, considering only the months between March and August. Exclude any regions where the average sales quantity is less than 100 units, and also exclude any months where local holidays are observed.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sales_quantity", "type": "INT"},
            {"name": "sales_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "holidays",
        "columns": [
            {"name": "holiday_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "holiday_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    p.product_name, 
    r.region, 
    AVG(s.sales_quantity) AS average_sales_quantity, 
    AVG(s.sales_revenue) AS average_sales_revenue
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
JOIN 
    (
        SELECT 
            region, 
            EXTRACT(MONTH FROM sale_date) AS sale_month
        FROM 
            sales
        WHERE 
            sale_date BETWEEN '2022-03-01' AND '2022-08-31'
    ) AS filtered_sales ON s.region = filtered_sales.region AND s.sale_date BETWEEN '2022-03-01' AND '2022-08-31'
WHERE 
    s.region IN (
        SELECT 
            region
        FROM 
            sales
        GROUP BY 
            region
        HAVING 
            AVG(sales_quantity) >= 100
    )
AND 
    s.sale_date NOT IN (
        SELECT 
            holiday_date
        FROM 
            holidays
        WHERE 
            EXTRACT(MONTH FROM holiday_date) BETWEEN 3 AND 8
        AND 
            EXTRACT(YEAR FROM holiday_date) = EXTRACT(YEAR FROM sale_date)
    )
GROUP BY 
    p.product_name, 
    r.region
ORDER BY 
    average_sales_quantity DESC
------------------
Predict the likelihood of a customer churning based on their purchase history and demographic information. Develop a logistic regression model that takes into account the customer's average order value, order frequency, and time since last purchase, as well as their age, income, and location. Evaluate the model's performance using a holdout set and provide the top 5 features contributing to the model's accuracy.
Schema:
[
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "avg_order_value", "type": "DECIMAL(10, 2)"},
            {"name": "order_frequency", "type": "INT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"}
        ]
    }
]
Response:
WITH 
-- Calculate the time since last purchase for each customer
customer_last_purchase AS (
  SELECT 
    customer_id,
    MAX(order_date) AS last_purchase_date
  FROM 
    customer_purchases
  GROUP BY 
    customer_id
),
-- Calculate the average order value, order frequency, and time since last purchase for each customer
customer_features AS (
  SELECT 
    cp.customer_id,
    AVG(cp.avg_order_value) AS avg_order_value,
    AVG(cp.order_frequency) AS order_frequency,
    LPAD(DATEDIFF('day', clp.last_purchase_date, cp.order_date), 10, '0') AS time_since_last_purchase
  FROM 
    customer_purchases cp
  JOIN 
    customer_last_purchase clp ON cp.customer_id = clp.customer_id
  GROUP BY 
    cp.customer_id
),
-- Merge customer features with demographic information
customer_data AS (
  SELECT 
    c.customer_id,
    c.age,
    c.income,
    c.location,
    cf.avg_order_value,
    cf.order_frequency,
    cf.time_since_last_purchase
  FROM 
    customers c
  JOIN 
    customer_features cf ON c.customer_id = cf.customer_id
)
SELECT 
  customer_id,
  age,
  income,
  location,
  avg_order_value,
  order_frequency,
  time_since_last_purchase,
  -- Predict the likelihood of churn using logistic regression
  EXP(alpha + beta1 * avg_order_value + beta2 * order_frequency + beta3 * time_since_last_purchase + beta4 * age + beta5 * income + beta6 * location) / (1 + EXP(alpha + beta1 * avg_order_value + beta2 * order_frequency + beta3 * time_since_last_purchase + beta4 * age + beta5 * income + beta6 * location))
FROM 
  customer_data
------------------
Optimize the inventory management of a retail company by identifying the top 10 products with the lowest stock levels and the highest demand. Calculate the total stock value of these products and recommend a replenishment plan to meet the expected demand. Consider the lead time for each product and the storage capacity of each warehouse.
Schema:
[
    {
        "name": "inventory",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "stock_quantity", "type": "INT"},
            {"name": "stock_value", "type": "DECIMAL(10, 2)"},
            {"name": "lead_time", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "storage_capacity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    p.product_name, 
    i.stock_quantity, 
    i.stock_value, 
    i.lead_time, 
    (SELECT SUM(o.quantity) FROM orders o WHERE o.product_id = i.product_id) AS total_demand
FROM 
    inventory i
JOIN 
    products p ON i.product_id = p.product_id
ORDER BY 
    total_demand ASC
LIMIT 
    10;
------------------
Identify the top 5 most profitable customers based on their total sales and revenue generated over the past year. Calculate the customer's profit margin and return on investment (ROI) for each product category. Provide a recommendation for marketing campaigns to retain these high-value customers.
Schema:
[
    {
        "name": "customer_sales",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "total_sales", "type": "DECIMAL(10, 2)"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id,
  c.name,
  SUM(cs.total_sales) AS total_sales,
  SUM(cs.revenue) AS total_revenue,
  (SUM(cs.revenue) / SUM(cs.total_sales)) * 100 AS profit_margin,
  (SUM(cs.revenue) / SUM(cs.total_sales)) * 100 AS roi,
  pc.product_category
FROM 
  customers c
  JOIN customer_sales cs ON c.customer_id = cs.customer_id
  JOIN products p ON cs.product_id = p.product_id
  JOIN (
    SELECT 
      product_id,
      product_category,
      SUM(total_sales) AS total_sales,
      SUM(revenue) AS total_revenue
    FROM 
      customer_sales
    GROUP BY 
      product_id, product_category
  ) pc ON p.product_id = pc.product_id
WHERE 
  sale_date >= DATE('now', '-1 year')
GROUP BY 
  c.customer_id, c.name, pc.product_category
ORDER BY 
  total_revenue DESC
LIMIT 
  5
------------------
Analyze the stock market performance of a portfolio of stocks over the past 5 years. Calculate the daily returns, cumulative returns, and Sharpe ratio for each stock. Identify the top 3 stocks with the highest returns and the lowest volatility. Provide a recommendation for investors to diversify their portfolio.
Schema:
[
    {
        "name": "stock_prices",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "open_price", "type": "DECIMAL(10, 2)"},
            {"name": "high_price", "type": "DECIMAL(10, 2)"},
            {"name": "low_price", "type": "DECIMAL(10, 2)"},
            {"name": "close_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "stocks",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_name", "type": "VARCHAR(255)"},
            {"name": "sector", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "portfolio",
        "columns": [
            {"name": "portfolio_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "weight", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  stock_id,
  stock_name,
  sector,
  AVG((close_price - LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) / LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) AS daily_return,
  EXP(SUM(LN(1 + (close_price - LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) / LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)))) - 1 AS cumulative_return,
  STDEV((close_price - LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) / LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) AS volatility,
  (EXP(SUM(LN(1 + (close_price - LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) / LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)))) - 1) / STDEV((close_price - LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) / LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date)) AS sharpe_ratio
FROM 
  stock_prices
JOIN 
  stocks ON stock_prices.stock_id = stocks.stock_id
GROUP BY 
  stock_id, stock_name, sector
ORDER BY 
  cumulative_return DESC, volatility ASC
LIMIT 3
------------------
Evaluate the performance of an online course platform by analyzing the completion rates and retention rates of students. Calculate the average completion time and retention rate for each course, and identify the top 5 courses with the highest completion rates. Provide a recommendation for instructors to improve course design and student engagement.
Schema:
[
    {
        "name": "student_enrollments",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "enrollment_date", "type": "DATE"}
        ]
    },
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "course_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "course_progress",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "completion_date", "type": "DATE"},
            {"name": "completion_time", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  c.course_name,
  AVG(cp.completion_time) AS avg_completion_time,
  (COUNT(DISTINCT sp.student_id) * 1.0 / COUNT(c.course_id)) * 100 AS retention_rate,
  (COUNT(DISTINCT cp.student_id) * 1.0 / COUNT(c.course_id)) * 100 AS completion_rate
FROM 
  courses c
JOIN 
  course_progress cp ON c.course_id = cp.course_id
JOIN 
  student_enrollments se ON c.course_id = se.course_id
JOIN 
  students s ON se.student_id = s.student_id
JOIN 
  (
    SELECT 
      se.course_id,
      se.student_id
    FROM 
      student_enrollments se
    WHERE 
      se.enrollment_date = (
        SELECT 
          MIN(enrollment_date)
        FROM 
          student_enrollments
        WHERE 
          course_id = se.course_id
      )
  ) as first_enrollment ON c.course_id = first_enrollment.course_id AND se.student_id = first_enrollment.student_id
GROUP BY 
  c.course_name
ORDER BY 
  completion_rate DESC
LIMIT 5
------------------
**Analyze Sales Performance by Region and Product Category**

Develop a SQL query to report on the total sales revenue for each region by product category, including the top-selling product categories in each region. The query should also include the average order value (AOV) for each region and product category.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  S.region, 
  S.product_category, 
  SUM(S.order_value) AS total_sales, 
  AVOV.avg_order_value
FROM 
  sales S
  JOIN 
  (
    SELECT 
      region, 
      AVG(order_value) AS avg_order_value
    FROM 
      sales
    GROUP BY 
      region
  ) AVOV ON S.region = AVOV.region
WHERE 
  S.product_category IN (
    SELECT 
      product_category
    FROM 
      sales
    GROUP BY 
      product_category
    ORDER BY 
      SUM(order_value) DESC
    LIMIT 5
  )
GROUP BY 
  S.region, 
  S.product_category
ORDER BY 
  S.region, 
  total_sales DESC
------------------
**Track Inventory Levels and Reorder Points**

Develop a SQL query to track the current inventory levels of products and identify which products are approaching their reorder points. The query should include the product name, current inventory level, and reorder point.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "reorder_point", "type": "INT"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "current_inventory", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, i.current_inventory, p.reorder_point
FROM products p
JOIN inventory i ON p.product_id = i.product_id
WHERE i.current_inventory <= p.reorder_point;
------------------
**Analyze Website Engagement by User Type**

Develop a SQL query to report on the average time spent on the website by user type, including the top 3 pages visited by each user type. The query should also include the bounce rate for each user type.
Schema:
[
    {
        "name": "users",
        "columns": [
            {"name": "user_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "user_type", "type": "VARCHAR(255)"},
            {"name": "login_date", "type": "DATE"}
        ]
    },
    {
        "name": "page_views",
        "columns": [
            {"name": "page_view_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "user_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES users(user_id)"]},
            {"name": "page_name", "type": "VARCHAR(255)"},
            {"name": "visit_time", "type": "TIME"}
        ]
    }
]
Response:
SELECT 
    u.user_type, 
    AVG(PV.visit_time) AS avg_visit_time, 
    PV.page_name, 
    PV.visit_time, 
    (COUNT(CASE WHEN PV.visit_time = '00:00:00' THEN PV.page_view_id END) * 1.0 / COUNT(PV.page_view_id)) AS bounce_rate
FROM 
    users u
JOIN 
    page_views PV ON u.user_id = PV.user_id
GROUP BY 
    u.user_type, PV.page_name
ORDER BY 
    bounce_rate DESC
LIMIT 3;

SELECT 
    u.user_type, 
    AVG(PV.visit_time) AS avg_visit_time, 
    (SELECT 
         page_name 
     FROM 
         page_views PV2 
     JOIN 
         users u2 ON PV2.user_id = u2.user_id 
     WHERE 
         u2.user_type = u.user_type 
     GROUP BY 
         PV2.page_name 
     ORDER BY 
         COUNT(PV2.page_view_id) DESC 
     LIMIT 1) AS top_page
FROM 
    users u
JOIN 
    page_views PV ON u.user_id = PV.user_id
GROUP BY 
    u.user_type
ORDER BY 
    avg_visit_time DESC
LIMIT 3;
------------------
**Predict Stock Prices using Historical Data**

Develop a SQL query to predict the stock prices of a company using historical data. The query should include the predicted stock price, moving averages, and trend analysis.
Schema:
[
    {
        "name": "stock_prices",
        "columns": [
            {"name": "stock_price_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "stock_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "moving_averages",
        "columns": [
            {"name": "moving_average_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "moving_average", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  S.date, 
  S.stock_price, 
  MA.moving_average, 
  CASE 
    WHEN MA.moving_average > S.stock_price THEN 'Decreasing'
    WHEN MA.moving_average < S.stock_price THEN 'Increasing'
    ELSE 'Stable'
  END AS stock_price_trend
FROM 
  stock_prices S
JOIN 
  moving_averages MA ON S.date = MA.date
ORDER BY 
  S.date;
------------------
**Identifying High-Risk Customers for Churn Prevention in the Telecommunications Industry**

Develop a SQL query that identifies high-risk customers for churn prevention in the telecommunications industry. The query should consider various factors such as customer subscription history, service usage patterns, and demographic information to predict the likelihood of customers cancelling their services.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "subscription_date", "type": "DATE"},
            {"name": "demographic_data", "type": "TEXT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "service_plan", "type": "VARCHAR(255)"},
            {"name": "usage_hours", "type": "INT"}
        ]
    },
    {
        "name": "churn_history",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason_for_churn", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "INT"},
            {"name": "education_level", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, MAX(d.age) AS max_age, AVG(d.income) AS avg_income, COUNT(o.order_id) AS num_orders, SUM(o.usage_hours) AS total_usage
FROM customers c
JOIN demographics d ON c.customer_id = d.customer_id
JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN churn_history ch ON c.customer_id = ch.customer_id
WHERE ch.customer_id IS NOT NULL
GROUP BY c.customer_id, c.name, c.email
HAVING COUNT(ch.churn_date) > 1
ORDER BY total_usage DESC;

SELECT c.customer_id, c.name, c.email, MAX(d.age) AS max_age, AVG(d.income) AS avg_income, COUNT(o.order_id) AS num_orders, SUM(o.usage_hours) AS total_usage, COUNT(ch.churn_date) AS churn_count
FROM customers c
JOIN demographics d ON c.customer_id = d.customer_id
JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN churn_history ch ON c.customer_id = ch.customer_id
WHERE ch.customer_id IS NOT NULL
GROUP BY c.customer_id, c.name, c.email
HAVING COUNT(ch.churn_date) > 1
ORDER BY total_usage DESC;
------------------
**Analyzing Sales Performance by Region and Product Category**

Develop a SQL query that analyzes sales performance by region and product category. The query should consider various factors such as sales revenue, product category, and region to identify areas of improvement and opportunities for growth.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "TEXT"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "region_description", "type": "TEXT"}
        ]
    },
    {
        "name": "sales_region",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales(sale_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    p.product_category, 
    SUM(s.sale_amount) AS total_sales
FROM 
    sales s
JOIN 
    sales_region sr ON s.sale_id = sr.sale_id
JOIN 
    regions r ON sr.region_id = r.region_id
JOIN 
    products p ON s.product_id = p.product_id
GROUP BY 
    r.region_name, 
    p.product_category
ORDER BY 
    r.region_name, 
    p.product_category
------------------
**Predicting Customer Lifetime Value (CLV) for a Retail Company**

Develop a SQL query that predicts customer lifetime value (CLV) for a retail company. The query should consider various factors such as customer purchase history, demographic information, and loyalty program participation to estimate the total value of a customer to the business.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "demographic_data", "type": "TEXT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_amount", "type": "DECIMAL(10, 2)"},
            {"name": "loyalty_program_id", "type": "INT"}
        ]
    },
    {
        "name": "loyalty_programs",
        "columns": [
            {"name": "loyalty_program_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "program_name", "type": "VARCHAR(255)"},
            {"name": "program_description", "type": "TEXT"}
        ]
    },
    {
        "name": "customer_loyalty",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "loyalty_program_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES loyalty_programs(loyalty_program_id)"]},
            {"name": "loyalty_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  c.customer_id,
  c.name,
  SUM(o.order_amount) AS total_spent,
  COUNT(DISTINCT o.order_id) AS total_orders,
  COALESCE(lp.program_name, 'No loyalty program') AS loyalty_program,
  MAX(cl.loyalty_date) AS loyalty_date,
  CASE 
    WHEN MAX(cl.loyalty_date) IS NOT NULL THEN 1 
    ELSE 0 
  END AS is_loyal_customer
FROM 
  customers c
  LEFT JOIN orders o ON c.customer_id = o.customer_id
  LEFT JOIN loyalty_programs lp ON o.loyalty_program_id = lp.loyalty_program_id
  LEFT JOIN customer_loyalty cl ON c.customer_id = cl.customer_id
GROUP BY 
  c.customer_id, c.name, lp.program_name
HAVING 
  SUM(o.order_amount) > 0;
------------------
Analyze Sales Performance by Product Category for Regional Managers
Develop a SQL query that generates a report showing the total sales, average sale price, and number of customers who purchased products in each product category for each regional manager. The report should include only the product categories with sales greater than $500,000.
Schema:
[
    {
        "name": "regional_managers",
        "columns": [
            {"name": "manager_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "TEXT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(category_id)"]},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT"},
            {"name": "manager_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regional_managers(manager_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    rm.name AS regional_manager,
    pc.category_name,
    SUM(o.quantity * p.price) AS total_sales,
    AVG(p.price) AS average_sale_price,
    COUNT(DISTINCT c.customer_id) AS num_customers
FROM 
    orders o
JOIN 
    products p ON o.product_id = p.product_id
JOIN 
    customers c ON o.customer_id = c.customer_id
JOIN 
    regional_managers rm ON o.manager_id = rm.manager_id
JOIN 
    product_categories pc ON p.category_id = pc.category_id
GROUP BY 
    rm.name, pc.category_name
HAVING 
    SUM(o.quantity * p.price) > 500000
------------------
Identify High-Risk Customers for Marketing Campaigns
Develop a SQL query that identifies high-risk customers who have made multiple purchases in the past year, have a high average order value, and have a high total spend. The query should also include the number of orders, total revenue, and average order value for each customer.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, COUNT(o.order_id) AS num_orders, SUM(o.total) AS total_revenue, AVG(o.total) AS avg_order_value
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= DATE('now', '-1 year')
GROUP BY c.customer_id, c.name, c.email
HAVING COUNT(o.order_id) > 2 AND AVG(o.total) > (SELECT AVG(total) FROM orders)
ORDER BY total_revenue DESC;
------------------
Optimize Inventory Levels for Warehouse Locations
Develop a SQL query that calculates the total inventory value, average inventory days, and total inventory turnover for each warehouse location. The query should also include the top 5 products with the highest inventory value for each location.
Schema:
[
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "location", "type": "VARCHAR(255)"},
            {"name": "manager", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "TEXT"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "cost", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
    w.warehouse_id,
    w.location,
    SUM(i.quantity * i.cost) AS total_inventory_value,
    AVG(i.quantity * i.cost / (SELECT SUM(quantity) FROM inventory WHERE warehouse_id = w.warehouse_id)) AS avg_inventory_days,
    SUM(i.quantity * i.cost) / (SELECT SUM(cost * quantity) FROM inventory WHERE warehouse_id = w.warehouse_id) AS total_inventory_turnover,
    (SELECT 
            p.product_name,
            i.quantity * i.cost AS inventory_value
        FROM 
            inventory i
        JOIN 
            products p ON i.product_id = p.product_id
        ORDER BY 
            inventory_value DESC
        LIMIT 5) AS top_5_products
FROM 
    warehouses w
JOIN 
    inventory i ON w.warehouse_id = i.warehouse_id
GROUP BY 
    w.warehouse_id, w.location
------------------
Analyze Customer Churn for Telecommunications Providers
Develop a SQL query that identifies customers who have churned in the past quarter and analyzes their usage patterns, including the number of calls, minutes used, and data consumed. The query should also include a comparison of churned customers with non-churned customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "call_count", "type": "INT"},
            {"name": "minutes_used", "type": "DECIMAL(10,2)"},
            {"name": "data_consumed", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT u.customer_id, c.name, u.call_count, u.minutes_used, u.data_consumed
FROM usage u
JOIN customers c ON u.customer_id = c.customer_id
JOIN (
  SELECT customer_id, MAX(churn_date) AS max_churn_date
  FROM churn
  WHERE churn_date >= DATE('now', '-3 months')
  GROUP BY customer_id
) AS churned_customer ON u.customer_id = churned_customer.customer_id
LEFT JOIN (
  SELECT customer_id, COUNT(customer_id) AS total_customers
  FROM customers
) AS total_customers ON churned_customer.customer_id = total_customers.customer_id
LEFT JOIN (
  SELECT customer_id, COUNT(customer_id) AS total_call_count
  FROM usage
  GROUP BY customer_id
) AS total_call_count ON churned_customer.customer_id = total_call_count.customer_id
WHERE churned_customer.max_churn_date IS NOT NULL

UNION ALL

SELECT u.customer_id, c.name, u.call_count, u.minutes_used, u.data_consumed
FROM usage u
JOIN customers c ON u.customer_id = c.customer_id
JOIN (
  SELECT customer_id, MAX(churn_date) AS max_churn_date
  FROM churn
  WHERE churn_date IS NULL
  GROUP BY customer_id
) AS non_churned_customer ON u.customer_id = non_churned_customer.customer_id
LEFT JOIN (
  SELECT customer_id, COUNT(customer_id) AS total_customers
  FROM customers
) AS total_customers ON non_churned_customer.customer_id = total_customers.customer_id
LEFT JOIN (
  SELECT customer_id, COUNT(customer_id) AS total_call_count
  FROM usage
  GROUP BY customer_id
) AS total_call_count ON non_churned_customer.customer_id = total_call_count.customer_id
WHERE non_churned_customer.max_churn_date IS NULL
------------------
Forecast Revenue for Online Retailers
Develop a SQL query that forecasts revenue for the next quarter based on historical sales data, including seasonality, trends, and anomalies. The query should also include a comparison of forecasted revenue with actual revenue for the previous quarter.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "TEXT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT SUM(s.amount) AS forecasted_revenue, 
       SUM(o.total) AS actual_revenue
FROM orders o
JOIN sales s ON o.order_id = s.order_id
WHERE s.sale_date BETWEEN DATE('2022-01-01') AND DATE('2022-12-31')
AND s.sale_date < (SELECT MIN(sale_date) + INTERVAL 3 QUARTER FROM sales);

SELECT SUM(s.amount) AS forecasted_revenue, 
       SUM(o.total) AS actual_revenue
FROM orders o
JOIN sales s ON o.order_id = s.order_id
WHERE s.sale_date BETWEEN DATE('2023-01-01') AND DATE('2023-12-31');
------------------
Analyze Employee Performance for HR Analytics
Develop a SQL query that analyzes employee performance metrics, including job satisfaction, turnover rates, and performance ratings. The query should also include a comparison of employee performance across different departments and locations.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "performance",
        "columns": [
            {"name": "performance_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "rating", "type": "DECIMAL(10,2)"},
            {"name": "comments", "type": "TEXT"}
        ]
    },
    {
        "name": "turnover",
        "columns": [
            {"name": "turnover_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "turnover_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  e.department, 
  e.location, 
  AVG(p.rating) AS avg_rating, 
  COUNT(CASE WHEN t.turnover_date IS NOT NULL THEN 1 END) AS turnover_count, 
  COUNT(e.employee_id) AS total_employees
FROM employees e
LEFT JOIN performance p ON e.employee_id = p.employee_id
LEFT JOIN turnover t ON e.employee_id = t.employee_id
GROUP BY e.department, e.location
------------------
Identify Cross-Selling Opportunities for E-commerce Platforms
Develop a SQL query that identifies customers who have purchased products from multiple categories and analyzes their purchase history to identify potential cross-selling opportunities. The query should also include a comparison of customers who have purchased products from multiple categories with those who have not.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT"},
            {"name": "category_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    COUNT(DISTINCT o.category_id) AS num_categories,
    SUM(CASE WHEN o.category_id IN (SELECT category_id FROM products WHERE category_id NOT IN (27, 31)) THEN 1 ELSE 0 END) AS num_cross_sell
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    products p ON o.product_id = p.product_id
GROUP BY 
    c.customer_id, c.name, c.email
HAVING 
    COUNT(DISTINCT o.category_id) > 1;
------------------
**Analyze Sales Trends and Customer Churn in the E-commerce Industry**

An e-commerce company wants to identify sales trends, customer behavior, and potential churn risks by analyzing customer purchase history, order frequency, and demographic information. The company aims to develop targeted marketing strategies to retain high-value customers and improve overall sales performance.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10,2)"},
            {"name": "payment_method", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "product_reviews",
        "columns": [
            {"name": "review_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "rating", "type": "TINYINT"},
            {"name": "review_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.signup_date, 
    COUNT(o.order_id) AS order_count, 
    SUM(o.total_amount) AS total_spent, 
    MAX(o.order_date) AS last_order_date, 
    COUNT(pr.review_id) AS review_count
FROM 
    customers c
LEFT JOIN 
    orders o ON c.customer_id = o.customer_id
LEFT JOIN 
    product_reviews pr ON c.customer_id = pr.customer_id
GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.signup_date
ORDER BY 
    total_spent DESC;
------------------
**Identify High-Risk Patients and Optimize Healthcare Resource Allocation**

A hospital wants to analyze patient data to identify high-risk patients, track their medical history, and optimize resource allocation to improve patient outcomes. The hospital aims to reduce readmission rates, identify potential complications, and allocate resources more efficiently.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "date_of_birth", "type": "DATE"},
            {"name": "medical_record_number", "type": "VARCHAR(20)"},
            {"name": "insurance_status", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "admissions",
        "columns": [
            {"name": "admission_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "admission_date", "type": "DATE"},
            {"name": "discharge_date", "type": "DATE"},
            {"name": "diagnosis", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "medications",
        "columns": [
            {"name": "medication_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "medication_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "lab_results",
        "columns": [
            {"name": "lab_result_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "test_name", "type": "VARCHAR(255)"},
            {"name": "result_value", "type": "DECIMAL(10,2)"},
            {"name": "result_date", "type": "DATE"}
        ]
    },
    {
        "name": "vitals",
        "columns": [
            {"name": "vital_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "vital_type", "type": "VARCHAR(20)"},
            {"name": "value", "type": "DECIMAL(10,2)"},
            {"name": "measurement_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    p.patient_id, 
    p.name, 
    p.date_of_birth, 
    p.medical_record_number, 
    p.insurance_status, 
    COUNT(DISTINCT a.admission_id) AS admission_count, 
    COUNT(DISTINCT m.medication_id) AS medication_count, 
    COUNT(DISTINCT l.lab_result_id) AS lab_result_count, 
    COUNT(DISTINCT v.vital_id) AS vital_count
FROM patients p
LEFT JOIN admissions a ON p.patient_id = a.patient_id
LEFT JOIN medications m ON p.patient_id = m.patient_id
LEFT JOIN lab_results l ON p.patient_id = l.patient_id
LEFT JOIN vitals v ON p.patient_id = v.patient_id
GROUP BY p.patient_id
ORDER BY admission_count DESC;
------------------
**Identify Top-Performing Sales Regions by Salesperson, Time Period, and Sales Channel**
Analyze sales data to identify the top-performing sales regions by salesperson, time period (quarter), and sales channel (online, offline, or both) for the past 2 years, considering only salespeople who have generated at least $100,000 in sales during that period.
Schema:
[
    {
        "name": "salespeople",
        "columns": [
            {"name": "salesperson_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sales_channel", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "salesperson_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES salespeople(salesperson_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sales_channel", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "quarter_sales",
        "columns": [
            {"name": "quarter", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sales_channel", "type": "VARCHAR(255)"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT s.region, s.name, sq.quarter, sc.sales_channel, SUM(sq.amount) AS total_amount
FROM salespeople s
JOIN (
  SELECT salesperson_id, region, sales_channel, 
         SUM(CASE WHEN EXTRACT(YEAR FROM sale_date) = 2022 THEN amount ELSE 0 END) AS amount_2022,
         SUM(CASE WHEN EXTRACT(YEAR FROM sale_date) = 2023 THEN amount ELSE 0 END) AS amount_2023
  FROM sales
  GROUP BY salesperson_id, region, sales_channel
) sq ON s.salesperson_id = sq.salesperson_id
JOIN (
  SELECT region, sales_channel, 
         SUM(CASE WHEN EXTRACT(YEAR FROM sale_date) = 2022 THEN amount ELSE 0 END) AS amount_2022,
         SUM(CASE WHEN EXTRACT(YEAR FROM sale_date) = 2023 THEN amount ELSE 0 END) AS amount_2023
  FROM quarter_sales
  GROUP BY region, sales_channel
) sc ON sq.region = sc.region AND sq.sales_channel = sc.sales_channel
WHERE s.salesperson_id IN (
  SELECT salesperson_id
  FROM sales
  GROUP BY salesperson_id
  HAVING SUM(amount) >= 100000
)
GROUP BY s.region, s.name, sq.quarter, sc.sales_channel
ORDER BY total_amount DESC;
------------------
**Predict Customer Churn based on Historical Usage Patterns and Demographic Data**
Analyze historical customer data, including usage patterns and demographic information, to predict which customers are likely to churn within the next 3 months, considering factors such as account type, plan usage, and credit limit.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_type", "type": "VARCHAR(255)"},
            {"name": "plan_usage", "type": "VARCHAR(255)"},
            {"name": "credit_limit", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "usage_history",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "usage_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customer_churn",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.account_type, c.plan_usage, c.credit_limit, d.age, d.income, u.usage_amount, u.usage_date, COALESCE(ch.churn_date, '2023-06-30') AS predicted_churn_date
FROM customers c
LEFT JOIN demographics d ON c.customer_id = d.customer_id
LEFT JOIN usage_history u ON c.customer_id = u.customer_id
LEFT JOIN (
    SELECT customer_id, MAX(churn_date) AS churn_date
    FROM customer_churn
    WHERE churn_date >= CURRENT_DATE AND churn_date <= CURRENT_DATE + INTERVAL 3 MONTH
    GROUP BY customer_id
) ch ON c.customer_id = ch.customer_id
WHERE c.account_type IN ('Premium', 'Business') AND u.usage_amount / c.credit_limit > 0.8 AND d.income < 50000
------------------
**Analyze Inventory Levels and Revenue by Product Category, Subcategory, and Store Location**
Analyze the current inventory levels and revenue by product category, subcategory, and store location, considering seasonal fluctuations in demand and accounting for backorders and out-of-stock items.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "subcategory", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "store_location", "type": "VARCHAR(255)"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "store_location", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT p.category, p.subcategory, i.store_location, SUM(s.amount) AS total_revenue, SUM(i.quantity) AS total_inventory 

FROM products p 

JOIN inventory i ON p.product_id = i.product_id 

JOIN sales s ON p.product_id = s.product_id 

GROUP BY p.category, p.subcategory, i.store_location 

ORDER BY p.category, p.subcategory, i.store_location
------------------
**Forecast Monthly Sales Revenue based on Seasonality and Historical Trends**
Analyze historical sales data to forecast the monthly sales revenue for the next 12 months, considering seasonal fluctuations in demand and accounting for anomalies in the data.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "month", "type": "VARCHAR(255)"},
            {"name": "year", "type": "INT"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "seasonal_sales",
        "columns": [
            {"name": "season", "type": "VARCHAR(255)"},
            {"name": "month", "type": "VARCHAR(255)"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "anomalies",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales(sale_id)"]},
            {"name": "month", "type": "VARCHAR(255)"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    s.month,
    s.year,
    COALESCE(ss.amount, a.amount) AS seasonal_amount,
    COALESCE(ss.amount, a.amount) + (COALESCE(ss.amount, a.amount) * 0.2) AS forecasted_amount
FROM 
    sales s
LEFT JOIN 
    seasonal_sales ss ON s.month = ss.month AND s.year = ss.year
LEFT JOIN 
    anomalies a ON s.sale_id = a.sale_id AND s.month = a.month
WHERE 
    s.year = 2022
ORDER BY 
    s.month ASC
------------------
Analyze customer purchasing behavior across different product categories and geographies, and provide recommendations for targeted marketing campaigns.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"},
            {"name": "purchase_frequency", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]},
            {"name": "sales_rank", "type": "INT"}
        ]
    },
    {
        "name": "categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.location, 
    p.category, 
    p.price, 
    SUM(o.quantity) AS total_quantity
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    products p ON o.product_id = p.product_id
GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    c.location, 
    p.category, 
    p.price
ORDER BY 
    total_quantity DESC
------------------
Analyze employee productivity and performance across different categories of tasks, and provide insights on how to improve overall team efficiency.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"},
            {"name": "job_title", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "tasks",
        "columns": [
            {"name": "task_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "task_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "duration", "type": "INT"}
        ]
    },
    {
        "name": "task_assignments",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "task_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES tasks(task_id)"]},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"},
            {"name": "completion_status", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "productivity_metrics",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "task_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES tasks(task_id)"]},
            {"name": "metric_type", "type": "VARCHAR(255)"},
            {"name": "value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "departments",
        "columns": [
            {"name": "department_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    e.name AS employee_name, 
    t.category AS task_category, 
    SUM(pm.value) AS total_value
FROM 
    employees e
JOIN 
    task_assignments ta ON e.employee_id = ta.employee_id
JOIN 
    tasks t ON ta.task_id = t.task_id
LEFT JOIN 
    productivity_metrics pm ON ta.task_id = pm.task_id
GROUP BY 
    e.name, t.category
ORDER BY 
    total_value DESC
------------------
Analyze customer behavior and identify opportunities to increase sales by offering personalized promotions and discounts.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"},
            {"name": "purchase_frequency", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customer_segments",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "segment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES segments(segment_id)"]},
            {"name": "segment_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "segments",
        "columns": [
            {"name": "segment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT C.customer_id, C.name, C.email, C.location, C.purchase_frequency, 
       SUM(O.quantity * P.price) AS total_spent, 
       CASE 
           WHEN CS.segment_description = 'High Value' THEN 'Premium'
           WHEN CS.segment_description = 'Medium Value' THEN 'Regular'
           WHEN CS.segment_description = 'Low Value' THEN 'Basic'
           ELSE 'Unknown'
       END AS customer_segment
FROM customers C
JOIN orders O ON C.customer_id = O.customer_id
JOIN products P ON O.product_id = P.product_id
JOIN customer_segments CS ON C.customer_id = CS.customer_id
GROUP BY C.customer_id, C.name, C.email, C.location, C.purchase_frequency, CS.segment_description
ORDER BY total_spent DESC
------------------
**Predicting Customer Churn in the Telecommunications Industry**

Develop a SQL query to analyze customer data and predict which customers are likely to churn (i.e., cancel their phone service) within the next 6 months. The query should consider customer demographics, service usage, and billing information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "CHAR(1)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone_number", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "service_plans",
        "columns": [
            {"name": "plan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "plan_name", "type": "VARCHAR(50)"},
            {"name": "data_limit", "type": "INT"},
            {"name": "minutes_limit", "type": "INT"}
        ]
    },
    {
        "name": "calls",
        "columns": [
            {"name": "call_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "plan_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES service_plans(plan_id)"]},
            {"name": "call_date", "type": "DATE"},
            {"name": "duration", "type": "INT"}
        ]
    },
    {
        "name": "bills",
        "columns": [
            {"name": "bill_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "bill_date", "type": "DATE"},
            {"name": "total_charges", "type": "DECIMAL(10, 2)"},
            {"name": "payment_status", "type": "CHAR(1)"}
        ]
    },
    {
        "name": "churn_data",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason_for_churn", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.age, 
    c.gender, 
    c.email, 
    c.phone_number, 
    p.plan_name, 
    p.data_limit, 
    p.minutes_limit, 
    SUM(CASE WHEN b.payment_status = 'P' THEN 1 ELSE 0 END) AS payment_count, 
    SUM(CASE WHEN b.payment_status = 'N' THEN 1 ELSE 0 END) AS no_payment_count, 
    COUNT(DISTINCT b.bill_id) AS bill_count, 
    COUNT(DISTINCT c.customer_id) OVER (PARTITION BY c.customer_id) AS total_calls, 
    COUNT(DISTINCT c.customer_id) OVER (PARTITION BY c.customer_id) AS total_minutes, 
    c.age / 60 AS average_call_duration
FROM 
    customers c
JOIN 
    calls cl ON c.customer_id = cl.customer_id
JOIN 
    service_plans p ON cl.plan_id = p.plan_id
JOIN 
    bills b ON c.customer_id = b.customer_id
WHERE 
    c.customer_id NOT IN (SELECT customer_id FROM churn_data WHERE churn_date >= DATE('now', '-6 months'))
GROUP BY 
    c.customer_id, c.name, c.age, c.gender, c.email, c.phone_number, p.plan_name, p.data_limit, p.minutes_limit
HAVING 
    COUNT(DISTINCT b.bill_id) < 10 AND SUM(CASE WHEN b.payment_status = 'P' THEN 1 ELSE 0 END) < 3
------------------
**Analyzing Sales Performance by Region and Product Category in Retail**

Develop a SQL query to analyze sales data and provide insights on sales performance by region and product category. The query should consider sales amount, region, product category, and time period.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(20)"},
            {"name": "product_category", "type": "VARCHAR(20)"},
            {"name": "product_name", "type": "VARCHAR(50)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(20)"},
            {"name": "region_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(20)"},
            {"name": "category_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  pc.category_name, 
  SUM(s.sale_amount) AS total_sales
FROM 
  sales s
  JOIN regions r ON s.region = r.region_name
  JOIN product_categories pc ON s.product_category = pc.category_name
GROUP BY 
  r.region_name, 
  pc.category_name
ORDER BY 
  r.region_name, 
  pc.category_name
------------------
**Identifying High-Risk Patients in a Hospital Setting**

Develop a SQL query to analyze patient data and identify high-risk patients who are at risk of readmission or death within 30 days of discharge. The query should consider patient demographics, medical history, and treatment information.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "CHAR(1)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "discharges",
        "columns": [
            {"name": "discharge_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "discharge_date", "type": "DATE"},
            {"name": "diagnosis", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "treatments",
        "columns": [
            {"name": "treatment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_name", "type": "VARCHAR(50)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "readmissions",
        "columns": [
            {"name": "readmission_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "readmission_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT p.patient_id, p.name, p.age, p.gender, p.email, d.discharge_date, d.diagnosis, r.readmission_date, COUNT(r.readmission_date) AS readmission_count
FROM patients p
JOIN discharges d ON p.patient_id = d.patient_id
LEFT JOIN readmissions r ON p.patient_id = r.patient_id AND d.discharge_date = r.readmission_date
WHERE d.discharge_date > DATE('now', '-30 days')
GROUP BY p.patient_id, p.name, p.age, p.gender, p.email, d.discharge_date, d.diagnosis, r.readmission_date
HAVING COUNT(r.readmission_date) > 0 OR (p.age > 65 AND d.diagnosis IN ('heart failure', 'chronic obstructive pulmonary disease', 'congestive heart failure'))
ORDER BY p.patient_id;
------------------
Analyze sales trends and customer behavior for a retail company operating in multiple regions.

The company wants to identify the top-selling products in each region, along with the average order value and the number of customers who have purchased those products. The sales data is stored in a transactional database, and the company also maintains a separate database for customer information and regional details.
Schema:
[
    {
        "name": "sales_data",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT"},
            {"name": "region_id", "type": "INT"},
            {"name": "order_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    p.product_name, 
    COUNT(s.order_id) AS num_customers, 
    AVG(s.total_amount) AS avg_order_value
FROM 
    sales_data s
JOIN 
    customers c ON s.customer_id = c.customer_id
JOIN 
    regions r ON c.region_id = r.region_id
JOIN 
    products p ON s.product_id = p.product_id
GROUP BY 
    r.region_name, 
    p.product_name
ORDER BY 
    r.region_name, 
    avg_order_value DESC
------------------
Identify the most profitable customers for a e-commerce company based on their purchase history and demographic information.

The company wants to analyze the revenue generated by each customer segment, including their age, gender, and location. The data is stored in a transactional database, and the company also maintains a separate database for customer information and purchase history.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.age, c.gender, c.location, SUM(oi.quantity * oi.unit_price) as total_revenue FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id 
JOIN order_items oi ON o.order_id = oi.order_id 
GROUP BY c.customer_id, c.name, c.age, c.gender, c.location 
ORDER BY total_revenue DESC
------------------
Develop a predictive model to forecast sales for a retail company based on historical sales data and seasonal trends.

The company wants to analyze the relationship between sales and various factors such as date, season, and product category. The data is stored in a transactional database, and the company also maintains a separate database for sales history and product information.
Schema:
[
    {
        "name": "sales_data",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT"},
            {"name": "order_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "season", "type": "VARCHAR(10)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_categories(category_id)"]}
        ]
    }
]
Response:
SELECT 
  s.order_date, 
  p.category, 
  SUM(s.quantity) AS total_quantity, 
  SUM(s.total_amount) AS total_amount
FROM 
  sales_data s 
  JOIN product_categories pc ON s.product_id = pc.product_id
  JOIN products p ON pc.category_id = p.category
GROUP BY 
  s.order_date, 
  p.category
ORDER BY 
  s.order_date, 
  p.category
------------------
Analyze the patient outcomes and treatment effectiveness for a healthcare organization.

The organization wants to identify the most effective treatments for specific medical conditions, along with the associated patient demographics and treatment outcomes. The data is stored in a transactional database, and the organization also maintains a separate database for patient information and treatment history.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "condition", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "treatments",
        "columns": [
            {"name": "treatment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "treatment_name", "type": "VARCHAR(255)"},
            {"name": "treatment_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "patient_treatments",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES treatments(treatment_id)"]},
            {"name": "outcome", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"}
        ]
    }
]
Response:
SELECT t.treatment_name, t.treatment_type, p.name, p.age, p.gender, pt.outcome, pt.date 
FROM treatments t 
JOIN patient_treatments pt ON t.treatment_id = pt.treatment_id 
JOIN patients p ON pt.patient_id = p.patient_id 
GROUP BY t.treatment_id 
ORDER BY COUNT(pt.treatment_id) DESC
------------------
Develop a data warehousing solution for an educational institution to analyze student performance and academic progress.

The institution wants to track student enrollment, course completion, and academic achievement, along with demographic information and course details. The data is stored in a transactional database, and the institution also maintains a separate database for student information and course catalog.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "grade_level", "type": "INT"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "course_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "enrollment_date", "type": "DATE"},
            {"name": "completion_date", "type": "DATE"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "enrollment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES enrollments(enrollment_id)"]},
            {"name": "grade_value", "type": "DECIMAL(3, 2)"},
            {"name": "grade_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT s.student_id, s.name, s.email, s.age, s.grade_level, c.course_name, c.course_type, e.enrollment_date, e.completion_date, g.grade_value 
FROM students s 
JOIN courses c ON c.course_id = e.course_id 
JOIN enrollments e ON e.student_id = s.student_id 
JOIN grades g ON g.enrollment_id = e.enrollment_id
------------------
**Analyze Customer Churn and Predict Future Sales**
Develop a SQL query to identify the top 5 customers who are most likely to churn in the next quarter, and predict their potential sales using a linear regression model. Consider the customers' purchase history, demographic information, and current loyalty program status.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "loyalty_program_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES loyalty_programs(loyalty_program_id)"]}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "loyalty_programs",
        "columns": [
            {"name": "loyalty_program_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "program_name", "type": "VARCHAR(255)"},
            {"name": "reward_points", "type": "INT"}
        ]
    },
    {
        "name": "customer_demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "income", "type": "DECIMAL(10, 2)"},
            {"name": "education_level", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.age, 
  c.loyalty_program_id, 
  o.order_date, 
  COALESCE(SUM(o.quantity), 0) AS total_quantity, 
  COALESCE(SUM(o.total_amount), 0) AS total_amount, 
  cd.income, 
  cd.education_level, 
  lp.reward_points, 
  CASE 
    WHEN o.order_date < DATE('now', '-3 months') THEN 'Churned' 
    ELSE 'Active' 
  END AS churn_status
FROM 
  customers c
  LEFT JOIN orders o ON c.customer_id = o.customer_id
  LEFT JOIN customer_demographics cd ON c.customer_id = cd.customer_id
  LEFT JOIN loyalty_programs lp ON c.loyalty_program_id = lp.loyalty_program_id
GROUP BY 
  c.customer_id
ORDER BY 
  total_amount DESC
LIMIT 
  5;
------------------
**Track Sales Trends and Identify Price Elasticity**
Write a SQL query to analyze sales data from the past year and identify the top 10 products that have shown the highest price elasticity. Consider the product's average price, sales volume, and the impact of price changes on sales.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "average_price", "type": "DECIMAL(10, 2)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "price_history",
        "columns": [
            {"name": "price_history_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "price_date", "type": "DATE"},
            {"name": "new_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_trends",
        "columns": [
            {"name": "sales_trend_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "trend_date", "type": "DATE"},
            {"name": "sales_volume", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_id, p.product_name, AVG(ph.new_price) AS average_price, AVG(o.quantity) AS sales_volume
FROM products p
LEFT JOIN price_history ph ON p.product_id = ph.product_id
LEFT JOIN orders o ON p.product_id = o.product_id
WHERE o.order_date BETWEEN DATE('now', '-1 year') AND DATE('now')
GROUP BY p.product_id, p.product_name
ORDER BY AVG(o.quantity) / AVG(ph.new_price) DESC
LIMIT 10;
------------------
**Analyze Customer Purchase Behavior and Identify Cross-Selling Opportunities**
Develop a SQL query to analyze customer purchase behavior and identify the top 5 products that are commonly purchased together. Consider the products' category, price, and sales volume.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p1.product_name, p2.product_name, COUNT(o.order_id) as sales_volume
FROM orders o
JOIN products p1 ON o.product_id = p1.product_id
JOIN products p2 ON o.product_id != p1.product_id AND o.product_id = p2.product_id
GROUP BY p1.product_name, p2.product_name
ORDER BY sales_volume DESC
LIMIT 5
------------------
**Monitor Warehouse Inventory and Predict Stockouts**
Write a SQL query to analyze warehouse inventory levels and predict which products are likely to go out of stock in the next 30 days. Consider the product's sales history, lead time, and supplier information.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "warehouse_inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity_on_hand", "type": "INT"},
            {"name": "lead_time", "type": "INT"}
        ]
    },
    {
        "name": "supplier_info",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "supplier_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_history",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity_sold", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    p.product_id, 
    p.product_name, 
    wh.quantity_on_hand, 
    wh.lead_time, 
    si.supplier_name, 
    (wh.quantity_on_hand - (SELECT SUM(sh.quantity_sold) FROM sales_history sh WHERE sh.product_id = p.product_id AND sh.sale_date > (CURRENT_DATE - INTERVAL 30 DAY))) AS predicted_shortage
FROM 
    products p
JOIN 
    warehouse_inventory wh ON p.product_id = wh.product_id
JOIN 
    supplier_info si ON p.product_id = si.product_id
ORDER BY 
    predicted_shortage DESC
------------------
**Develop a Recommendation System for Customers**
Create a SQL query to analyze customer purchase behavior and develop a recommendation system for customers. Consider the customers' purchase history, product categories, and demographic information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "loyalty_program_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES loyalty_programs(loyalty_program_id)"]},
            {"name": "demographic_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES demographics(demographic_id)"]}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.loyalty_program_id, 
    c.demographic_id, 
    p.product_id, 
    p.product_name, 
    p.category_id, 
    p.price, 
    o.order_id, 
    o.order_date, 
    o.quantity, 
    o.total_amount 
FROM 
    customers c 
INNER JOIN 
    orders o ON c.customer_id = o.customer_id 
INNER JOIN 
    products p ON o.product_id = p.product_id 
WHERE 
    c.demographic_id IN 
    (SELECT 
         d.demographic_id 
     FROM 
         demographics d 
     GROUP BY 
         d.demographic_id 
     HAVING 
         COUNT(DISTINCT o.product_id) > 1 
     AND 
         COUNT(o.order_id) > 1)
------------------
Develop a SQL query to analyze customer purchase behavior and predict future sales for an e-commerce company. The query should consider the following:

* Identify the top 5 customers who have made the most purchases within the last 6 months.
* Calculate the average order value (AOV) for each of these top customers.
* Determine the product categories with the highest sales growth over the past year.
* Predict the future sales for the top 5 customers based on their historical buying patterns.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, AVG(o.total_order_value) AS avg_order_value
FROM customers c
JOIN (
  SELECT o.customer_id, SUM(p.price * oi.quantity) AS total_order_value
  FROM orders o
  JOIN order_items oi ON o.order_id = oi.order_id
  JOIN products p ON oi.product_id = p.product_id
  WHERE o.order_date BETWEEN DATE('now', '-6 months') AND DATE('now')
  GROUP BY o.customer_id
  ORDER BY total_order_value DESC
  LIMIT 5
) AS top_customers ON c.customer_id = top_customers.customer_id
GROUP BY c.customer_id, c.name, c.email;

WITH sales_growth AS (
  SELECT p.product_category, SUM(s.amount) AS total_sales
  FROM sales s
  JOIN orders o ON s.order_id = o.order_id
  JOIN products p ON o.order_id = (
    SELECT order_id
    FROM order_items
    JOIN products ON order_items.product_id = products.product_id
    WHERE product_category = p.product_category
    GROUP BY order_id
    ORDER BY SUM(quantity) DESC
    LIMIT 1
  )
  WHERE s.sale_date BETWEEN DATE('now', '-1 year') AND DATE('now')
  GROUP BY p.product_category
),
previous_year_sales AS (
  SELECT p.product_category, SUM(s.amount) AS previous_year_sales
  FROM sales s
  JOIN orders o ON s.order_id = o.order_id
  JOIN products p ON o.order_id = (
    SELECT order_id
    FROM order_items
    JOIN products ON order_items.product_id = products.product_id
    WHERE product_category = p.product_category
    GROUP BY order_id
    ORDER BY SUM(quantity) DESC
    LIMIT 1
  )
  WHERE s.sale_date BETWEEN DATE('now', '-2 years') AND DATE('now', '-1 year')
  GROUP BY p.product_category
)
SELECT sg.product_category, (sg.total_sales - psy.previous_year_sales) / psy.previous_year_sales AS sales_growth_rate
FROM sales_growth sg
JOIN previous_year_sales psy ON sg.product_category = psy.product_category
ORDER BY sales_growth_rate DESC;

WITH historical_buying AS (
  SELECT c.customer_id, c.name, c.email, o.order_date, oi.quantity
  FROM customers c
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN order_items oi ON o.order_id = oi.order_id
  WHERE o.order_date BETWEEN DATE('now', '-2 years') AND DATE('now')
)
SELECT c.customer_id, c.name, c.email, AVG(h.quantity) AS avg_quantity
FROM customers c
JOIN historical_buying h ON c.customer_id = h.customer_id
GROUP BY c.customer_id, c.name, c.email
ORDER BY avg_quantity DESC
LIMIT 5;

WITH predicted_sales AS (
  SELECT c.customer_id, c.name, c.email, AVG(h.quantity) AS avg_quantity
  FROM customers c
  JOIN historical_buying h ON c.customer_id = h.customer_id
  GROUP BY c.customer_id, c.name, c.email
)
SELECT ps.customer_id, ps.name, ps.email, ps.avg_quantity * 1.5 AS predicted_sales
FROM predicted_sales ps
WHERE ps.customer_id IN (
  SELECT top_customers.customer_id
  FROM (
    SELECT o.customer_id, SUM(p.price * oi.quantity) AS total_order_value
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    JOIN products p ON oi.product_id = p.product_id
    WHERE o.order_date BETWEEN DATE('now', '-6 months') AND DATE('now')
    GROUP BY o.customer_id
    ORDER BY total_order_value DESC
    LIMIT 5
  ) AS top_customers
)
------------------
Create a SQL query to analyze the sales performance of a retail company across different regions. The query should consider the following:

* Identify the top 3 regions with the highest sales growth over the past year.
* Calculate the average sales revenue for each region.
* Determine the product categories with the highest sales revenue in the top 3 regions.
* Predict the future sales revenue for each region based on historical sales trends.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH sales_growth AS (
  SELECT region, 
         SUM(CASE WHEN DATE(sale_date) > DATE('now', '-1 year') THEN amount ELSE 0 END) AS recent_sales, 
         SUM(amount) AS total_sales
  FROM sales
  GROUP BY region
),
top_regions AS (
  SELECT region, 
         recent_sales - total_sales AS sales_growth
  FROM sales_growth
  ORDER BY sales_growth DESC
  LIMIT 3
),
avg_sales AS (
  SELECT region, 
         AVG(amount) AS avg_recent_sales
  FROM sales
  WHERE DATE(sale_date) > DATE('now', '-1 year')
  GROUP BY region
),
top_product_categories AS (
  SELECT p.product_category, 
         SUM(CASE WHEN s.region IN (SELECT region FROM top_regions) THEN s.amount ELSE 0 END) AS top_sales
  FROM sales s
  JOIN products p ON s.order_id = ANY((SELECT order_id FROM sales WHERE region IN (SELECT region FROM top_regions)))
  GROUP BY p.product_category
  ORDER BY top_sales DESC
  LIMIT 3
),
predicted_sales AS (
  SELECT s.region, 
         (AVG(CASE WHEN DATE(s.sale_date) > DATE('now', '-1 year') THEN amount ELSE 0 END) * 1.1) AS predicted_sales
  FROM sales s
  GROUP BY s.region
)
SELECT tr.region, 
       tr.sales_growth, 
       asr.avg_recent_sales, 
       tpct.product_category, 
       tpct.top_sales, 
       ps.predicted_sales
FROM top_regions tr
JOIN avg_sales asr ON tr.region = asr.region
JOIN top_product_categories tpct ON tr.region = tpct.product_category
JOIN predicted_sales ps ON tr.region = ps.region
ORDER BY tr.sales_growth DESC;
------------------
Design a SQL query to analyze the customer churn rate for a telecom company. The query should consider the following:

* Identify the top 5 reasons for customer churn.
* Determine the average tenure of customers who have churned.
* Calculate the revenue loss due to customer churn over the past year.
* Predict the likelihood of customer churn for each customer based on their usage patterns and subscription plans.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "subscriptions",
        "columns": [
            {"name": "subscription_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "plan_type", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_reason", "type": "VARCHAR(255)"},
            {"name": "churn_date", "type": "DATE"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_data", "type": "VARCHAR(255)"},
            {"name": "usage_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  churn.churn_reason, 
  AVG(DATEDIFF(churn.churn_date, subscriptions.start_date)) AS avg_tenure
FROM 
  churn
  JOIN subscriptions ON churn.customer_id = subscriptions.customer_id
WHERE 
  churn.churn_date > DATE('now', '-1 year')
GROUP BY 
  churn.churn_reason
ORDER BY 
  avg_tenure DESC
LIMIT 5;

WITH churn_data AS (
  SELECT 
    churn.churn_reason, 
    SUM(DATEDIFF(churn.churn_date, subscriptions.start_date)) AS total_tenure
  FROM 
    churn
    JOIN subscriptions ON churn.customer_id = subscriptions.customer_id
  WHERE 
    churn.churn_date > DATE('now', '-1 year')
  GROUP BY 
    churn.churn_reason
),
churn_loss AS (
  SELECT 
    SUM(total_tenure / 365.25 * (SELECT AVG(revenue) FROM subscriptions)) AS revenue_loss
  FROM 
    churn_data
)
SELECT 
  churn_data.churn_reason, 
  churn_data.total_tenure, 
  churn_loss.revenue_loss
FROM 
  churn_data
  JOIN churn_loss ON TRUE
ORDER BY 
  revenue_loss DESC;

WITH churn_likelihood AS (
  SELECT 
    customers.customer_id, 
    churn.churn_reason, 
    COUNT(*) AS churn_count, 
    COUNT(DISTINCT usage.usage_id) AS total_usage, 
    SUM(CASE WHEN usage.usage_data LIKE '%high%' THEN 1 ELSE 0 END) AS high_usage_count
  FROM 
    customers
    JOIN subscriptions ON customers.customer_id = subscriptions.customer_id
    JOIN churn ON customers.customer_id = churn.customer_id
    JOIN usage ON customers.customer_id = usage.customer_id
  WHERE 
    churn.churn_date > DATE('now', '-1 year')
  GROUP BY 
    customers.customer_id, churn.churn_reason
),
churn_probability AS (
  SELECT 
    churn_likelihood.churn_count, 
    churn_likelihood.total_usage, 
    churn_likelihood.high_usage_count, 
    churn_likelihood.churn_reason
  FROM 
    churn_likelihood
  WHERE 
    churn_likelihood.total_usage > 100 AND churn_likelihood.high_usage_count > 10
)
SELECT 
  churn_probability.churn_count / churn_likelihood.total_usage AS churn_likelihood
FROM 
  churn_probability
  JOIN churn_likelihood ON churn_probability.churn_count = churn_likelihood.churn_count;
------------------
Create a SQL query to analyze the inventory levels of a manufacturing company. The query should consider the following:

* Identify the products with the lowest stock levels across all warehouses.
* Determine the average lead time for replenishing stock for each product.
* Calculate the total inventory value for each product.
* Predict the future demand for each product based on historical sales trends.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "capacity", "type": "INT"}
        ]
    },
    {
        "name": "stock",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
WITH stock_levels AS (
  SELECT p.product_id, p.product_name, SUM(s.quantity) AS total_quantity
  FROM products p
  JOIN stock s ON p.product_id = s.product_id
  GROUP BY p.product_id, p.product_name
),
reorder_points AS (
  SELECT p.product_id, p.price, 0.8 * p.price AS reorder_point
  FROM products p
),
future_demand AS (
  SELECT s.product_id, AVG(s.quantity) AS avg_monthly_sales
  FROM sales s
  GROUP BY s.product_id
),
lead_time AS (
  SELECT 
    p.product_id, 
    s.warehouse_id, 
    s.quantity, 
    w.capacity, 
    (s.quantity / w.capacity) * 7 AS lead_time_days
  FROM stock s
  JOIN warehouses w ON s.warehouse_id = w.warehouse_id
  JOIN products p ON s.product_id = p.product_id
)
SELECT 
  sl.product_id,
  sl.product_name,
  sl.total_quantity,
  rp.reorder_point,
  fd.avg_monthly_sales,
  lt.lead_time_days
FROM stock_levels sl
JOIN reorder_points rp ON sl.product_id = rp.product_id
JOIN future_demand fd ON sl.product_id = fd.product_id
JOIN lead_time lt ON sl.product_id = lt.product_id
ORDER BY sl.total_quantity ASC
------------------
Analyze sales performance across different regions and product categories, considering the impact of seasonal fluctuations and customer loyalty programs.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "loyalty_program", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "seasonal_fluctuations",
        "columns": [
            {"name": "month", "type": "VARCHAR(255)"},
            {"name": "season", "type": "VARCHAR(255)"},
            {"name": "average_sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    s.region, 
    s.product_category, 
    EXTRACT(MONTH FROM s.sale_date) AS sale_month, 
    sf.season, 
    AVG(s.sale_amount) AS average_sale_amount, 
    COUNT(s.customer_id) AS total_customers, 
    SUM(CASE WHEN c.loyalty_program = 1 THEN 1 ELSE 0 END) AS loyal_customers
FROM 
    sales s
JOIN 
    customers c ON s.customer_id = c.customer_id
JOIN 
    seasonal_fluctuations sf ON EXTRACT(MONTH FROM s.sale_date) = sf.month
GROUP BY 
    s.region, 
    s.product_category, 
    sf.season, 
    EXTRACT(MONTH FROM s.sale_date)
------------------
Identify high-value customers who have made repeat purchases within a specific time window, considering their purchase history and demographics.
Schema:
[
    {
        "name": "purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "purchase_date", "type": "DATE"},
            {"name": "purchase_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.age, c.location, COUNT(p1.purchase_id) AS repeat_purchases
FROM customers c
JOIN purchases p1 ON c.customer_id = p1.customer_id
JOIN purchases p2 ON c.customer_id = p2.customer_id AND p1.purchase_date < p2.purchase_date AND p2.purchase_date - p1.purchase_date <= INTERVAL 365 DAY
GROUP BY c.customer_id, c.name, c.email, c.age, c.location
HAVING COUNT(DISTINCT p2.product_id) >= 2
------------------
Analyze the impact of marketing campaigns on sales performance, considering the effects of different channels, promotion types, and target audiences.
Schema:
[
    {
        "name": "marketing_campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "channel", "type": "VARCHAR(255)"},
            {"name": "promotion_type", "type": "VARCHAR(255)"},
            {"name": "target_audience", "type": "VARCHAR(255)"},
            {"name": "campaign_start_date", "type": "DATE"},
            {"name": "campaign_end_date", "type": "DATE"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
            {"name": "campaign_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES marketing_campaigns(campaign_id)"]}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email! ", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    m.campaign_name, 
    m.channel, 
    m.promotion_type, 
    m.target_audience, 
    SUM(s.sale_amount) AS total_sales
FROM 
    sales s
JOIN 
    marketing_campaigns m ON s.campaign_id = m.campaign_id
GROUP BY 
    m.campaign_name, 
    m.channel, 
    m.promotion_type, 
    m.target_audience
ORDER BY 
    total_sales DESC
------------------
Analyze the sales performance of a retail company across different product categories and regions, considering the impact of seasonal fluctuations on sales.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "seasonal_flag", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "latitude", "type": "DECIMAL(10, 8)"},
            {"name": "longitude", "type": "DECIMAL(10, 8)"}
        ]
    },
    {
        "name": "weather",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(10, 2)"},
            {"name": "rainfall", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT S.region, S.category, P.product_name, SUM(S.sale_amount) AS total_sales
FROM sales S
JOIN products P ON S.product_id = P.product_id
WHERE S.sale_amount > 0
GROUP BY S.region, S.category, P.product_name
ORDER BY S.region, S.category, total_sales DESC
------------------
Identify the top 5 customers who have purchased the most from the e-commerce platform, considering the total value of their orders, and provide a breakdown of their purchasing history by product category.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, SUM(oi.quantity * p.unit_price) AS total_spent, p.category 
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id 
JOIN order_items oi ON o.order_id = oi.order_id 
JOIN products p ON oi.product_id = p.product_id 
GROUP BY c.customer_id, c.name, c.email, p.category 
ORDER BY total_spent DESC 
LIMIT 5
------------------
Analyze the financial performance of a company across different business segments, considering the impact of investments in research and development (R&D) on revenue growth.
Schema:
[
    {
        "name": "financials",
        "columns": [
            {"name": "financial_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "business_segment", "type": "VARCHAR(255)"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"},
            {"name": "r_and_d_expenses", "type": "DECIMAL(10, 2)"},
            {"name": "year", "type": "INT"}
        ]
    },
    {
        "name": "business_segments",
        "columns": [
            {"name": "segment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "segment_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "investments",
        "columns": [
            {"name": "investment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "business_segment", "type": "VARCHAR(255)"},
            {"name": "investment_date", "type": "DATE"},
            {"name": "investment_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "research",
        "columns": [
            {"name": "research_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "business_segment", "type": "VARCHAR(255)"},
            {"name": "research_topic", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    f.year, 
    b.segment_name, 
    SUM(f.revenue) AS revenue, 
    SUM(f.r_and_d_expenses) AS r_and_d_expenses, 
    SUM(i.investment_amount) AS total_investment
FROM 
    financials f
JOIN 
    business_segments b ON f.business_segment = b.segment_name
LEFT JOIN 
    investments i ON f.business_segment = i.business_segment
GROUP BY 
    f.year, 
    b.segment_name
ORDER BY 
    f.year, 
    b.segment_name
------------------
**Analyzing Customer Churn for a Telecommunications Company**
Develop a SQL query to identify the top 5 reasons why customers have churned in the last quarter, including the number of customers who have churned, the total revenue loss, and the average monthly revenue per user (ARPU) for each reason.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"},
            {"name": "plan_type", "type": "ENUM('personal', 'business')"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn_reasons",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "reason", "type": "VARCHAR(255)"},
            {"name": "description", "type": "TEXT"}
        ]
    },
    {
        "name": "customer_churns",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES churn_reasons(churn_id)"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    },
    {
        "name": "usage_data",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  cr.reason, 
  COUNT(cc.customer_id) AS num_customers, 
  SUM(o.revenue) AS total_revenue_loss, 
  AVG(ud.data_usage) AS arpu
FROM 
  customers c
  JOIN customer_churns cc ON c.customer_id = cc.customer_id
  JOIN churn_reasons cr ON cc.churn_id = cr.churn_id
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN usage_data ud ON c.customer_id = ud.customer_id
WHERE 
  cc.churn_date >= DATE('now', '-3 month')
GROUP BY 
  cr.reason
ORDER BY 
  num_customers DESC
LIMIT 5;
------------------
**Optimizing Warehouse Inventory Management for an E-commerce Company**
Develop a SQL query to forecast the demand for each product category over the next 6 months, considering the historical sales data, seasonal trends, and product category mix.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "subcategory", "type": "VARCHAR(255)"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "seasonal_trends",
        "columns": [
            {"name": "trend_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "trend", "type": "VARCHAR(255)"},
            {"name": "season", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
WITH 
    -- Calculate the total sales for each product category over the next 6 months
    forecast AS (
        SELECT 
            p.category,
            p.subcategory,
            SUM(s.quantity) AS total_sales,
            s.sale_date
        FROM 
            orders o
        JOIN 
            products p ON o.product_id = p.product_id
        JOIN 
            sales_data s ON o.product_id = s.product_id
        WHERE 
            o.order_date BETWEEN DATE('now', '-6 months') AND DATE('now')
        GROUP BY 
            p.category, p.subcategory, s.sale_date
    ),
    
    -- Calculate the seasonal trend for each product category
    seasonal_trend AS (
        SELECT 
            st.category,
            st.season,
            COUNT(st.trend) AS trend_count
        FROM 
            seasonal_trends st
        GROUP BY 
            st.category, st.season
    )

SELECT 
    f.category,
    f.subcategory,
    f.total_sales,
    COALESCE(st.trend_count, 0) AS trend_count
FROM 
    forecast f
LEFT JOIN 
    seasonal_trend st ON f.category = st.category AND f.season = st.season
------------------
**Predicting Credit Card Default Risk for a Financial Institution**
Develop a SQL query to analyze the credit card default risk for a given customer, using a combination of their credit history, payment behavior, and demographic information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "credit_history", "type": "VARCHAR(255)"},
            {"name": "payment_behavior", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "credit_cards",
        "columns": [
            {"name": "card_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "card_type", "type": "VARCHAR(255)"},
            {"name": "credit_limit", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographics_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "default_risk",
        "columns": [
            {"name": "risk_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "risk_level", "type": "VARCHAR(255)"},
            {"name": "risk_score", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, ch.credit_history, pb.payment_behavior, d.age, d.income, dr.risk_level, dr.risk_score
FROM customers c
JOIN credit_cards cc ON c.customer_id = cc.customer_id
JOIN demographics d ON c.customer_id = d.customer_id
JOIN default_risk dr ON c.customer_id = dr.customer_id
JOIN (
  SELECT customer_id, 
         CASE 
           WHEN COUNT(*) > 6 THEN 'High'
           WHEN COUNT(*) BETWEEN 4 AND 6 THEN 'Medium'
           ELSE 'Low'
         END AS risk_level,
         AVG(CASE 
               WHEN payment_status = 'late' THEN 1
               ELSE 0
             END) * 100 AS risk_score
  FROM (
    SELECT c.customer_id, 
           cc.card_id, 
           cc.credit_limit, 
           pb.payment_behavior, 
           pb.payment_status
    FROM customers c
    JOIN credit_cards cc ON c.customer_id = cc.customer_id
    JOIN payment_behavior pb ON c.customer_id = pb.customer_id
  ) AS subquery
  GROUP BY customer_id
) dr ON c.customer_id = dr.customer_id
------------------
Analyze Sales Performance and Customer Segmentation for a Retail Company
Identify the top 5 product categories with the highest average order value (AOV) across different customer segments, while considering the impact of seasonal promotions and returns.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "segment", "type": "VARCHAR(20)"},
            {"name": "loyalty_program", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_value", "type": "DECIMAL(10,2)"},
            {"name": "returns", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "discount", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
  p.category, 
  AVG(o.total_value - oi.discount) AS avg_order_value
FROM 
  orders o
  JOIN order_items oi ON o.order_id = oi.order_id
  JOIN products p ON oi.product_id = p.product_id
  JOIN customers c ON o.customer_id = c.customer_id
WHERE 
  o.returns = 0
GROUP BY 
  p.category
ORDER BY 
  avg_order_value DESC
LIMIT 5
------------------
Analyze the sales performance of a retail company across different regions and product categories, taking into account the impact of seasonal trends, promotions, and sales channels. Identify the top-performing regions and product categories, and provide a forecast of sales for the next quarter.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sales_channel", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "promotions",
        "columns": [
            {"name": "promotion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "promotion_start_date", "type": "DATE"},
            {"name": "promotion_end_date", "type": "DATE"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "seasonality_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "seasonality_type", "type": "VARCHAR(255)"},
            {"name": "seasonality_start_date", "type": "DATE"},
            {"name": "seasonality_end_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  s.region,
  p.category,
  SUM(s.sale_amount) AS total_sales,
  AVG(s.sale_amount) AS average_sales,
  COUNT(DISTINCT s.order_id) AS distinct_orders
FROM 
  sales s
JOIN 
  orders o ON s.order_id = o.order_id
JOIN 
  products p ON s.product_id = p.product_id
WHERE 
  s.sale_date >= '2020-01-01' AND s.sale_date <= '2020-12-31'
  AND p.price > (SELECT AVG(price) FROM products)
  AND s.sales_channel IN ('online', 'retail')
GROUP BY 
  s.region, p.category
ORDER BY 
  total_sales DESC;

WITH 
  next_quarter_start AS (
    SELECT 
      DATE('now') + INTERVAL 3 MONTH AS next_quarter_start
  ),
  last_quarter_sales AS (
    SELECT 
      p.category,
      SUM(s.sale_amount) AS last_quarter_total_sales
    FROM 
      sales s
    JOIN 
      orders o ON s.order_id = o.order_id
    JOIN 
      products p ON s.product_id = p.product_id
    WHERE 
      s.sale_date >= DATE('now') - INTERVAL 3 MONTH AND s.sale_date < DATE('now')
    GROUP BY 
      p.category
  )
SELECT 
  lqs.category,
  lqs.last_quarter_total_sales,
  (lqs.last_quarter_total_sales * 1.2) AS forecast_sales
FROM 
  last_quarter_sales lqs
ORDER BY 
  forecast_sales DESC;
------------------
A hospital wants to analyze patient outcomes based on demographics, medical history, and treatment procedures. Identify the top 3 most common comorbidities among patients with cardiovascular disease, and provide a summary of patient outcomes (e.g., mortality rate, length of stay) for each comorbidity.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "sex", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "diagnoses",
        "columns": [
            {"name": "diagnosis_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "diagnosis_date", "type": "DATE"},
            {"name": "comorbidity", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "procedures",
        "columns": [
            {"name": "procedure_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "procedure_date", "type": "DATE"},
            {"name": "procedure_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "patient_outcomes",
        "columns": [
            {"name": "outcome_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "outcome_date", "type": "DATE"},
            {"name": "mortality_status", "type": "BOOLEAN"},
            {"name": "length_of_stay", "type": "INT"}
        ]
    },
    {
        "name": "cardiovascular_disease",
        "columns": [
            {"name": "cvd_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "cvd_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  comorbidity, 
  COUNT(DISTINCT patient_id) AS num_patients, 
  AVG(CASE WHEN mortality_status = 1 THEN 1 ELSE 0 END) AS mortality_rate, 
  AVG(length_of_stay) AS avg_length_of_stay
FROM 
  (SELECT 
     d.comorbidity, 
     d.patient_id, 
     po.mortality_status, 
     po.length_of_stay
   FROM 
     diagnoses d
   JOIN 
     patient_outcomes po ON d.patient_id = po.patient_id
   JOIN 
     cardiovascular_disease cvd ON d.patient_id = cvd.patient_id
   WHERE 
     d.comorbidity IS NOT NULL
     AND cvd.cvd_date IS NOT NULL) AS subquery
GROUP BY 
  comorbidity
ORDER BY 
  num_patients DESC
LIMIT 3
------------------
Analyze customer churn and identify the most profitable customers to target for retention in the e-commerce industry.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "sign_up_date", "type": "DATE"},
            {"name": "last_order_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "payment_method", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.sign_up_date, 
  c.last_order_date, 
  SUM(o.total_amount) AS total_spent, 
  MAX(o.order_date) AS last_order_date 
FROM 
  customers c 
  LEFT JOIN orders o ON c.customer_id = o.customer_id 
WHERE 
  c.last_order_date < DATE('now', '-1 year') 
GROUP BY 
  c.customer_id, c.name, c.email, c.sign_up_date, c.last_order_date 
HAVING 
  COUNT(o.order_id) < 2
------------------
Forecast sales for the next quarter and identify the top 5 products with the highest sales growth potential in the retail industry.
Schema:
[
    {
        "name": "sales_forecasts",
        "columns": [
            {"name": "forecast_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "forecast_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_history",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "seasonality_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "season", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT p.product_name, p.category, 
       SUM(sf.sales_amount) AS current_sales, 
       SUM(sh.sales_amount) AS past_sales, 
       (SUM(sf.sales_amount) - SUM(sh.sales_amount)) / SUM(sh.sales_amount) * 100 AS sales_growth_rate
FROM sales_forecasts sf
JOIN products p ON sf.product_id = p.product_id
JOIN sales_history sh ON p.product_id = sh.product_id
WHERE sh.sales_date BETWEEN DATE('now', '-1 year') AND DATE('now')
GROUP BY p.product_id, p.product_name, p.category
ORDER BY sales_growth_rate DESC
LIMIT 5;
------------------
Identify the most popular items in each category and calculate the average rating for each item in the e-commerce industry.
Schema:
[
    {
        "name": "items",
        "columns": [
            {"name": "item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "item_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "average_rating", "type": "DECIMAL(3, 2)"}
        ]
    },
    {
        "name": "reviews",
        "columns": [
            {"name": "review_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "item_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES items(item_id)"]},
            {"name": "review_text", "type": "VARCHAR(255)"},
            {"name": "rating", "type": "INT"},
            {"name": "review_date", "type": "DATE"}
        ]
    },
    {
        "name": "categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "parent_category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    i.category, 
    i.item_name, 
    AVG(r.rating) AS average_rating
FROM 
    items i
INNER JOIN 
    reviews r ON i.item_id = r.item_id
GROUP BY 
    i.category, i.item_name
ORDER BY 
    average_rating DESC;
------------------
Analyze customer behavior and identify the top 10 customers who have purchased the most products from different categories in the retail industry.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "sign_up_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, SUM(oi.quantity * pi.unit_price) AS total_spent, COUNT(DISTINCT p.category) AS num_categories
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products pi ON oi.product_id = pi.product_id
GROUP BY c.customer_id, c.name
ORDER BY total_spent DESC
LIMIT 10
------------------
Analyze customer purchase behavior and predict the likelihood of a customer making a repeat purchase within the next 30 days.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "join_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "customer_purchases",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "purchase_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ],
        "constraints": ["UNIQUE (customer_id, product_id, purchase_date)"]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, 
       AVG(CASE WHEN o.order_date + INTERVAL 30 DAY > CURRENT_DATE THEN 1 ELSE 0 END) AS repeat_purchase_likelihood
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name, c.email
------------------
Identify the top-performing sales representatives in the technology industry based on the total sales value and the number of deals closed in the last quarter.
Schema:
[
    {
        "name": "sales_reps",
        "columns": [
            {"name": "sales_rep_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "industry", "type": "VARCHAR(255)"},
            {"name": "commission_rate", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "deals",
        "columns": [
            {"name": "deal_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sales_rep_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_reps(sales_rep_id)"]},
            {"name": "client_name", "type": "VARCHAR(255)"},
            {"name": "deal_value", "type": "DECIMAL(10, 2)"},
            {"name": "close_date", "type": "DATE"}
        ]
    },
    {
        "name": "quarterly_sales",
        "columns": [
            {"name": "quarter", "type": "VARCHAR(10)"},
            {"name": "sales_rep_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_reps(sales_rep_id)"]},
            {"name": "total_sales", "type": "DECIMAL(10, 2)"}
        ],
        "constraints": ["PRIMARY KEY (quarter, sales_rep_id)"]
    }
]
Response:
SELECT s.name, SUM(d.deal_value) as total_sales, COUNT(d.deal_id) as num_deals
FROM deals d
JOIN sales_reps s ON d.sales_rep_id = s.sales_rep_id
JOIN quarterly_sales qs ON s.sales_rep_id = qs.sales_rep_id
WHERE qs.quarter = (SELECT MAX(quarter) FROM quarterly_sales WHERE sales_rep_id = s.sales_rep_id)
GROUP BY s.sales_rep_id, s.name
ORDER BY total_sales DESC, num_deals DESC
------------------
Develop a predictive model to forecast the demand of products in the retail industry based on historical sales data, seasonality, and weather patterns.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "season", "type": "VARCHAR(10)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sales_factor", "type": "DECIMAL(5, 2)"}
        ],
        "constraints": ["PRIMARY KEY (season, sale_date)"]
    },
    {
        "name": "weather_data",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(5, 2)"},
            {"name": "humidity", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "demand_forecast",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "forecast_demand", "type": "INT"}
        ],
        "constraints": ["UNIQUE (product_id, sale_date)"]
    }
]
Response:
WITH sales_data AS (
  SELECT 
    s.product_id, 
    s.sale_date, 
    SUM(s.quantity) AS total_sales
  FROM 
    sales s
  GROUP BY 
    s.product_id, 
    s.sale_date
),
seasonality_data AS (
  SELECT 
    s.season, 
    s.sale_date, 
    s.sales_factor
  FROM 
    seasonality s
),
weather_data AS (
  SELECT 
    w.sale_date, 
    w.temperature, 
    w.humidity
  FROM 
    weather_data w
)
SELECT 
  sd.product_id, 
  sd.sale_date, 
  (sd.total_sales * sw.sales_factor) + (sw.temperature * sw.humidity) AS demand_forecast
FROM 
  sales_data sd
JOIN 
  seasonality_data sw ON sd.sale_date = sw.sale_date
JOIN 
  weather_data w ON sd.sale_date = w.sale_date
------------------
Identify the most popular health insurance plans among customers who are between the ages of 25 and 45 and have a household income of $50,000 or more.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "insurance_plans",
        "columns": [
            {"name": "plan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "plan_name", "type": "VARCHAR(255)"},
            {"name": "premium", "type": "DECIMAL(10, 2)"},
            {"name": "coverage", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "plan_purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "plan_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES insurance_plans(plan_id)"]},
            {"name": "purchase_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT ip.plan_name 
FROM insurance_plans ip
JOIN plan_purchases pp ON ip.plan_id = pp.plan_id
JOIN customers c ON pp.customer_id = c.customer_id
WHERE c.age BETWEEN 25 AND 45
AND c.income >= 50000
GROUP BY ip.plan_name
ORDER BY COUNT(pp.purchase_id) DESC
LIMIT 1;
------------------
**Analyze Customer Churn and Predict Future Churn in the Telecom Industry**

Develop a SQL query to identify the top 10 customers who are most likely to churn in the next 30 days, based on their historical usage patterns and demographic information. The query should also include a predictive model to estimate the likelihood of churning for each customer.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "DECIMAL(10, 2)"},
            {"name": "voice_minutes", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "churn_reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, d.income, u.data_usage, u.voice_minutes, 
       (SELECT COUNT(*) 
        FROM churn 
        WHERE churn_date IS NULL AND customer_id = c.customer_id) AS likelihood_of_churn
FROM customers c
JOIN demographics d ON c.customer_id = d.customer_id
JOIN usage u ON c.customer_id = u.customer_id
WHERE u.usage_date >= DATE('now', '-30 days')
ORDER BY likelihood_of_churn DESC
LIMIT 10
------------------
**Identify Top-Selling Products and Analyze Sales Trends in the E-commerce Industry**

Develop a SQL query to identify the top 20 products by sales revenue in the past 12 months, and analyze the sales trends by product category, region, and time of day.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_trends",
        "columns": [
            {"name": "sales_trend_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "time_of_day", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.name, p.category, SUM(oi.quantity * o.total_amount) AS total_revenue, 
       r.name AS region, 
       STRFTIME('%Y-%m-%d', o.order_date) AS order_date, 
       STRFTIME('%H:%M', o.order_date) AS time_of_day
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN products p ON oi.product_id = p.product_id
JOIN regions r ON o.customer_id = r.customer_id  -- assuming customer_id in regions table
WHERE o.order_date >= DATE('now', '-12 months', 'start')
GROUP BY p.name, p.category, r.name, STRFTIME('%Y-%m-%d', o.order_date)
ORDER BY total_revenue DESC
LIMIT 20
------------------
**Analyze Employee Performance and Predict Future Performance in the HR Industry**

Develop a SQL query to analyze the performance of employees in the past 6 months, and predict their future performance based on their historical performance data, job title, and department.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "job_title", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "departments",
        "columns": [
            {"name": "department_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "performance",
        "columns": [
            {"name": "performance_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "evaluation_date", "type": "DATE"},
            {"name": "rating", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "historical_performance",
        "columns": [
            {"name": "historical_performance_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "evaluation_date", "type": "DATE"},
            {"name": "rating", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "future_performance",
        "columns": [
            {"name": "future_performance_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "evaluation_date", "type": "DATE"},
            {"name": "rating", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  e.employee_id,
  e.name,
  e.job_title,
  d.name AS department_name,
  AVG(p.rating) AS current_rating,
  AVG(hp.rating) AS historical_rating,
  AVG(fp.rating) AS future_rating
FROM 
  employees e
  JOIN departments d ON e.department_id = d.department_id
  LEFT JOIN performance p ON e.employee_id = p.employee_id AND DATE(p.evaluation_date) >= DATE('now', '-6 months')
  LEFT JOIN historical_performance hp ON e.employee_id = hp.employee_id AND DATE(hp.evaluation_date) < DATE('now', '-6 months')
  LEFT JOIN future_performance fp ON e.employee_id = fp.employee_id AND DATE(fp.evaluation_date) BETWEEN DATE('now', '-6 months') AND DATE('now') + INTERVAL 1 YEAR
GROUP BY 
  e.employee_id, e.name, e.job_title, d.name
------------------
**Analyze Customer Segmentation and Purchase Patterns**
Develop a SQL query to identify the most profitable customer segments based on their purchase history and demographic information. The query should group customers by age, income level, and purchase frequency, and calculate the average order value and total revenue generated by each segment.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"},
            {"name": "purchase_frequency", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    c.age,
    c.income,
    c.purchase_frequency,
    AVG(o.order_value) AS avg_order_value,
    SUM(o.order_value) AS total_revenue
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
GROUP BY 
    c.age, c.income, c.purchase_frequency
ORDER BY 
    total_revenue DESC
------------------
**Predict Stock Market Trends using Time-Series Analysis**
Develop a SQL query to forecast stock prices for the next 30 days based on historical data. The query should use a combination of moving averages and exponential smoothing to identify trends and seasonality in the data.
Schema:
[
    {
        "name": "stocks",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_name", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"},
            {"name": "open_price", "type": "DECIMAL(10, 2)"},
            {"name": "high_price", "type": "DECIMAL(10, 2)"},
            {"name": "low_price", "type": "DECIMAL(10, 2)"},
            {"name": "close_price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH 
moving_averages AS (
  SELECT 
    stock_id, 
    date, 
    AVG(open_price) OVER (PARTITION BY stock_id ORDER BY date ROWS 30 PRECEDING) AS ma_30,
    AVG(open_price) OVER (PARTITION BY stock_id ORDER BY date ROWS 60 PRECEDING) AS ma_60,
    AVG(open_price) OVER (PARTITION BY stock_id ORDER BY date ROWS 120 PRECEDING) AS ma_120
  FROM 
    stocks
),
exponential_smoothing AS (
  SELECT 
    stock_id, 
    date, 
    LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date) AS lag_close_price,
    close_price,
    (LAG(close_price) OVER (PARTITION BY stock_id ORDER BY date) + close_price) / 2 AS es
  FROM 
    stocks
)
SELECT 
  s.stock_id, 
  s.date, 
  s.close_price, 
  ma.ma_30, 
  ma.ma_60, 
  ma.ma_120, 
  es.es
FROM 
  stocks s
JOIN 
  moving_averages ma ON s.stock_id = ma.stock_id AND s.date = ma.date
JOIN 
  exponential_smoothing es ON s.stock_id = es.stock_id AND s.date = es.date
WHERE 
  s.date >= (SELECT MIN(date) FROM stocks) AND s.date <= (SELECT MAX(date) FROM stocks)
UNION ALL
SELECT 
  stock_id, 
  date, 
  (ma_30 + ma_60 + ma_120) / 3 AS close_price, 
  ma_30, 
  ma_60, 
  ma_120, 
  NULL
FROM 
  (
    SELECT 
      stock_id, 
      date, 
      ma_30, 
      ma_60, 
      ma_120
    FROM 
      (
        SELECT 
          stock_id, 
          date, 
          ma_30, 
          ma_60, 
          ma_120
        FROM 
          moving_averages
        WHERE 
          date <= (SELECT date - INTERVAL 30 DAY FROM stocks WHERE date = (SELECT MAX(date) FROM stocks))
      ) AS mov_avg
      JOIN LATERAL (
        SELECT 
          stock_id, 
          date, 
          (ma_30 + ma_60 + ma_120) / 3 AS close_price
        FROM 
          (
            SELECT 
              stock_id, 
              date, 
              ma_30, 
              ma_60, 
              ma_120
            FROM 
              moving_averages
            WHERE 
              date <= (SELECT date - INTERVAL 30 DAY FROM stocks WHERE date = (SELECT MAX(date) FROM stocks))
          ) AS mov_avg
      ) AS es ON mov_avg.stock_id = es.stock_id AND mov_avg.date = es.date
  ) AS final
ORDER BY 
  stock_id, 
  date
------------------
**Analyze Retail Sales Data and Identify Top-Selling Products**
Develop a SQL query to identify the top-selling products across different regions and categories. The query should use a combination of subqueries and window functions to rank products by sales revenue and calculate the market share of each product.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  p.product_id, 
  p.product_name, 
  p.category, 
  SUM(s.revenue) AS total_revenue, 
  (SUM(s.revenue) * 100) / (SELECT SUM(revenue) FROM sales) AS market_share
FROM 
  products p
  JOIN sales s ON p.product_id = s.product_id
GROUP BY 
  p.product_id, 
  p.product_name, 
  p.category
ORDER BY 
  total_revenue DESC
------------------
Analyze customer churn and retention rates in the e-commerce industry. Identify the most common reasons for customers abandoning their shopping carts, and compare the retention rates of customers who completed a purchase after abandoning their cart versus those who did not.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "creation_date", "type": "DATE"},
            {"name": "last_activity_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "cart_abandons",
        "columns": [
            {"name": "cart_abandon_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "cart_creation_date", "type": "DATE"},
            {"name": "abandonment_reason", "type": "VARCHAR(255)"},
            {"name": "recovery_date", "type": "DATE"}
        ]
    },
    {
        "name": "cart_contents",
        "columns": [
            {"name": "cart_content_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "cart_abandon_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES cart_abandons(cart_abandon_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id,
  c.name,
  c.email,
  ca.abandonment_reason,
  COUNT(CASE WHEN o.order_date IS NOT NULL THEN 1 END) AS purchase_after_abandon,
  COUNT(CASE WHEN o.order_date IS NULL THEN 1 END) AS no_purchase_after_abandon
FROM 
  customers c
  LEFT JOIN cart_abandons ca ON c.customer_id = ca.customer_id
WHERE 
  ca.cart_abandon_id IS NOT NULL AND c.last_activity_date < ca.cart_creation_date
GROUP BY 
  c.customer_id, c.name, c.email, ca.abandonment_reason
ORDER BY 
  purchase_after_abandon DESC
------------------
Develop a financial forecasting model for a fintech company. Estimate the total revenue for the next quarter based on historical data, taking into account seasonal fluctuations, customer acquisition costs, and product pricing changes. Use a combination of time-series analysis, regression, and forecasting techniques to generate a robust predictive model.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "creation_date", "type": "DATE"},
            {"name": "last_activity_date", "type": "DATE"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH 
revenue_by_product AS (
  SELECT 
    p.product_id,
    p.name,
    AVG(t.amount) AS average_revenue
  FROM 
    transactions t
  JOIN 
    products p ON t.product_id = p.product_id
  GROUP BY 
    p.product_id,
    p.name
), 

customer_acquisition_costs AS (
  SELECT 
    c.customer_id,
    c.name,
    SUM(t.amount) AS total_acquisition_cost
  FROM 
    transactions t
  JOIN 
    customers c ON t.customer_id = c.customer_id
  WHERE 
    EXTRACT(YEAR FROM t.transaction_date) = EXTRACT(YEAR FROM CURRENT_DATE) - 1
  GROUP BY 
    c.customer_id,
    c.name
),

seasonal_fluctuations AS (
  SELECT 
    EXTRACT(YEAR FROM t.transaction_date) AS year,
    EXTRACT(MONTH FROM t.transaction_date) AS month,
    AVG(t.amount) AS average_revenue
  FROM 
    transactions t
  GROUP BY 
    EXTRACT(YEAR FROM t.transaction_date),
    EXTRACT(MONTH FROM t.transaction_date)
), 

quarterly_revenue AS (
  SELECT 
    EXTRACT(YEAR FROM t.transaction_date) AS year,
    EXTRACT(QUARTER FROM t.transaction_date) AS quarter,
    SUM(t.amount) AS quarterly_revenue
  FROM 
    transactions t
  GROUP BY 
    EXTRACT(YEAR FROM t.transaction_date),
    EXTRACT(QUARTER FROM t.transaction_date)
)

SELECT 
  (SELECT 
     SUM(qr.quarterly_revenue) 
   FROM 
     quarterly_revenue qr 
   WHERE 
     qr.year = EXTRACT(YEAR FROM CURRENT_DATE) 
     AND qr.quarter = EXTRACT(QUARTER FROM CURRENT_DATE)) + 
  (SELECT 
     SUM(r.average_revenue * cf.total_acquisition_cost) 
   FROM 
     revenue_by_product r 
   JOIN 
     customer_acquisition_costs cf ON r.product_id = cf.customer_id) + 
  (SELECT 
     SUM(sf.average_revenue * 0.1) 
   FROM 
     seasonal_fluctuations sf 
   WHERE 
     sf.year = EXTRACT(YEAR FROM CURRENT_DATE) 
     AND sf.month BETWEEN 1 AND 3) AS total_revenue
------------------
Identify the most effective marketing channels for a retail company. Analyze the sales data to determine which channels drive the highest revenue, and compare the average order value and conversion rates across different channels. Use a combination of JOINs, subqueries, and window functions to generate a detailed report.
Schema:
[
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "channel", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "creation_date", "type": "DATE"},
            {"name": "last_activity_date", "type": "DATE"}
        ]
    },
    {
        "name": "marketing_channels",
        "columns": [
            {"name": "channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "channel_name", "type": "VARCHAR(255)"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"},
            {"name": "conversion_rate", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    mc.channel_name,
    SUM(o.total_amount) AS total_revenue,
    AVG(o.total_amount) AS average_order_value,
    COUNT(o.order_id) AS total_orders,
    mc.conversion_rate
FROM 
    orders o
INNER JOIN 
    marketing_channels mc ON o.channel = mc.channel_name
GROUP BY 
    mc.channel_name
ORDER BY 
    total_revenue DESC;
------------------
Analyze the financial performance of a retail company by identifying the top-performing stores, product categories, and sales channels, considering the impact of promotions and seasonal fluctuations.
Schema:
[
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "promotion_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES promotions(promotion_id)"]}
        ]
    },
    {
        "name": "promotions",
        "columns": [
            {"name": "promotion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "promotion_name", "type": "VARCHAR(255)"},
            {"name": "promotion_type", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "sales_channels",
        "columns": [
            {"name": "channel_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "channel_name", "type": "VARCHAR(255)"},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]}
        ]
    }
]
Response:
SELECT 
  s.store_name, 
  SUM(CASE WHEN p.category = 'Electronics' THEN s.quantity ELSE 0 END) AS electronics_sales, 
  SUM(CASE WHEN p.category = 'Fashion' THEN s.quantity ELSE 0 END) AS fashion_sales, 
  SUM(CASE WHEN p.category = 'Home Goods' THEN s.quantity ELSE 0 END) AS home_goods_sales, 
  sc.channel_name AS top_channel
FROM 
  (SELECT 
     store_id, 
     product_id, 
     sale_date, 
     quantity, 
     promotion_id, 
     ROW_NUMBER() OVER (PARTITION BY store_id ORDER BY sale_date DESC) AS row_num
   FROM 
     sales) s
LEFT JOIN 
  (SELECT 
     store_id, 
     product_id, 
     SUM(quantity) AS quantity
   FROM 
     sales
   GROUP BY 
     store_id, 
     product_id) p ON s.store_id = p.store_id AND s.product_id = p.product_id
LEFT JOIN 
  (SELECT 
     channel_id, 
     channel_name, 
     store_id
   FROM 
     sales_channels) sc ON s.store_id = sc.store_id
LEFT JOIN 
  (SELECT 
     product_id, 
     category
   FROM 
     products) pc ON s.product_id = pc.product_id
WHERE 
  s.row_num = 1
GROUP BY 
  s.store_name, 
  sc.channel_name
ORDER BY 
  electronics_sales DESC, 
  fashion_sales DESC, 
  home_goods_sales DESC
------------------
Develop a predictive model to forecast the number of visitors to a museum based on historical attendance data, weather conditions, and special events.
Schema:
[
    {
        "name": "visitors",
        "columns": [
            {"name": "visit_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "num_visitors", "type": "INT"}
        ]
    },
    {
        "name": "weather",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(5, 2)"},
            {"name": "precipitation", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "events",
        "columns": [
            {"name": "event_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "event_name", "type": "VARCHAR(255)"},
            {"name": "event_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "exhibitions",
        "columns": [
            {"name": "exhibition_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "exhibition_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    v.date, 
    v.num_visitors, 
    w.temperature, 
    w.precipitation, 
    e.event_name, 
    e.event_type
FROM 
    visitors v
JOIN 
    weather w ON v.date = w.date
LEFT JOIN 
    events e ON v.date = e.date
WHERE 
    v.date BETWEEN '2020-01-01' AND '2020-12-31'
    AND e.event_name IN ('New Year Celebration', 'Summer Festival');

-- To create a predictive model, we'll use the historical data to train a linear regression model.
-- We'll use the num_visitors as the target variable and the other columns as features.
-- We'll use a sliding window approach to split the data into training and testing sets.

-- First, let's create a table to store the historical data
CREATE TABLE historical_data AS
SELECT 
    v.date, 
    v.num_visitors, 
    w.temperature, 
    w.precipitation, 
    e.event_name, 
    e.event_type
FROM 
    visitors v
JOIN 
    weather w ON v.date = w.date
LEFT JOIN 
    events e ON v.date = e.date
WHERE 
    v.date BETWEEN '2020-01-01' AND '2020-12-31'
    AND e.event_name IN ('New Year Celebration', 'Summer Festival');

-- Now, let's create the predictive model using the historical data
CREATE TABLE predictive_model AS
SELECT 
    date, 
    temperature, 
    precipitation, 
    event_name, 
    event_type, 
    num_visitors
FROM 
    historical_data
WHERE 
    date >= (SELECT MIN(date) FROM historical_data) + INTERVAL 1 YEAR;

-- To forecast the number of visitors, we'll use the predict function of the linear regression model
SELECT 
    date, 
    temperature, 
    precipitation, 
    event_name, 
    event_type, 
    predict(num_visitors) AS num_visitors_prediction
FROM 
    predictive_model;
------------------
Analyze Sales Trends and Identify Top-Performing Regions across Multiple Countries

A retail company wants to analyze sales trends across various regions in multiple countries. The company has a complex database structure with normalized tables for customers, orders, products, and regions. The goal is to identify the top-performing regions, considering sales revenue, customer count, and product diversity.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"},
            {"name": "sales_target", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  r.region_id,
  r.name AS region_name,
  r.country,
  SUM(oi.quantity * p.price) AS total_sales,
  COUNT(DISTINCT c.customer_id) AS customer_count,
  COUNT(DISTINCT oi.order_id) AS order_count,
  COUNT(DISTINCT oi.product_id) AS product_diversity
FROM 
  regions r
  JOIN customers c ON r.region_id = c.region_id
  JOIN orders o ON c.customer_id = o.customer_id
  JOIN order_items oi ON o.order_id = oi.order_id
  JOIN products p ON oi.product_id = p.product_id
GROUP BY 
  r.region_id, r.name, r.country
ORDER BY 
  total_sales DESC
------------------
Forecast Quarterly Revenue for a E-commerce Company

A popular e-commerce company wants to forecast its quarterly revenue based on historical sales data. The company has a normalized database structure with tables for orders, customers, products, and order items. The goal is to create a forecast model that accurately predicts quarterly revenue, taking into account seasonal trends, product demand, and customer behavior.
Schema:
[
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_history", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "seasonality", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT SUM(revenue) AS quarterly_revenue
FROM orders
WHERE EXTRACT(QUARTER FROM order_date) = EXTRACT(QUARTER FROM CURRENT_DATE)
AND EXTRACT(YEAR FROM order_date) = EXTRACT(YEAR FROM CURRENT_DATE)
GROUP BY EXTRACT(QUARTER FROM CURRENT_DATE), EXTRACT(YEAR FROM CURRENT_DATE)
------------------
Identify High-Risk Customers for a Bank

A bank wants to identify high-risk customers who are likely to default on their loans. The bank has a complex database structure with normalized tables for customers, loans, and payment history. The goal is to create a risk assessment model that accurately identifies high-risk customers based on their credit score, loan history, and payment behavior.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "credit_score", "type": "INT"}
        ]
    },
    {
        "name": "loans",
        "columns": [
            {"name": "loan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "loan_amount", "type": "DECIMAL(10, 2)"},
            {"name": "interest_rate", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "loan_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES loans(loan_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "amount_paid", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.credit_score 
FROM customers c 
JOIN loans l ON c.customer_id = l.customer_id 
JOIN payments p ON l.loan_id = p.loan_id 
GROUP BY c.customer_id 
HAVING c.credit_score < 600 AND SUM(p.amount_paid) / SUM(l.loan_amount) < 0.5
------------------
Identify the top 5 countries with the highest average order value in the e-commerce industry, considering only orders placed in the last 3 months, by customers who have made at least 2 purchases. Analyze the performance of the company's marketing team by calculating the conversion rate of customers who have made at least one purchase within 30 days of their first order.
Schema:
[
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10,2)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "first_order_date", "type": "DATE"},
            {"name": "last_order_date", "type": "DATE"}
        ]
    },
    {
        "name": "marketing_campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "customer_activity",
        "columns": [
            {"name": "activity_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "activity_date", "type": "DATE"},
            {"name": "activity_type", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.country,
  AVG(o.total_amount) AS avg_order_value
FROM 
  orders o
JOIN 
  customers c ON o.customer_id = c.customer_id
WHERE 
  o.order_date >= DATE('now', '-3 months')
  AND c.first_order_date <= (SELECT MAX(first_order_date) 
                             FROM customers c 
                             JOIN customer_activity ca ON c.customer_id = ca.customer_id 
                             JOIN marketing_campaigns mc ON c.customer_id = mc.customer_id 
                             WHERE ca.activity_type = 'purchase'
                             AND mc.campaign_id IS NOT NULL)
  AND c.last_order_date > (SELECT MIN(first_order_date) 
                            FROM customers c 
                            JOIN customer_activity ca ON c.customer_id = ca.customer_id 
                            WHERE ca.activity_type = 'purchase')
GROUP BY 
  c.country
ORDER BY 
  avg_order_value DESC
LIMIT 5

SELECT 
  (SELECT COUNT(DISTINCT customer_id) 
   FROM customers 
   JOIN customer_activity ca ON customers.customer_id = ca.customer_id 
   WHERE ca.activity_type = 'purchase'
   AND customers.first_order_date <= (SELECT MAX(first_order_date) 
                                       FROM customers c 
                                       JOIN customer_activity ca ON c.customer_id = ca.customer_id 
                                       JOIN marketing_campaigns mc ON c.customer_id = mc.customer_id 
                                       WHERE ca.activity_type = 'purchase'
                                       AND mc.campaign_id IS NOT NULL)
   AND customers.last_order_date > (SELECT MIN(first_order_date) 
                                    FROM customers c 
                                    JOIN customer_activity ca ON c.customer_id = ca.customer_id 
                                    WHERE ca.activity_type = 'purchase')) / 
  (SELECT COUNT(*) 
   FROM customers 
   JOIN customer_activity ca ON customers.customer_id = ca.customer_id 
   WHERE ca.activity_type = 'purchase'
   AND customers.first_order_date <= (SELECT MAX(first_order_date) 
                                       FROM customers c 
                                       JOIN customer_activity ca ON c.customer_id = ca.customer_id 
                                       JOIN marketing_campaigns mc ON c.customer_id = mc.customer_id 
                                       WHERE ca.activity_type = 'purchase'
                                       AND mc.campaign_id IS NOT NULL)
   AND customers.last_order_date > (SELECT MIN(first_order_date) 
                                    FROM customers c 
                                    JOIN customer_activity ca ON c.customer_id = ca.customer_id 
                                    WHERE ca.activity_type = 'purchase')) AS conversion_rate
------------------
Analyze the sales performance of a retail company by identifying the top 10 products with the highest revenue generated in the last quarter, considering only products that have a sales price greater than $100. Calculate the average sales price of each product and the total revenue generated by each product. Provide a comprehensive report with product recommendations for future marketing campaigns.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sales_price", "type": "DECIMAL(10,2)"},
            {"name": "quantity_sold", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sales_price", "type": "DECIMAL(10,2)"},
            {"name": "reorder_level", "type": "INT"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "inventory_date", "type": "DATE"},
            {"name": "quantity_in_stock", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, 
       SUM(s.sales_price * s.quantity_sold) AS total_revenue, 
       AVG(s.sales_price) AS avg_sales_price 
FROM sales s 
JOIN products p ON s.product_id = p.product_id 
WHERE s.sale_date > '2022-10-01' AND p.sales_price > 100 
GROUP BY p.product_name 
ORDER BY total_revenue DESC 
LIMIT 10
------------------
A healthcare organization wants to analyze the patient outcomes of a new medical treatment. Analyze the average patient satisfaction scores of patients who have received the treatment, considering only patients who have a follow-up appointment within 30 days of the treatment date. Calculate the average satisfaction score for each patient and the overall average satisfaction score for the treatment. Identify the top 5 medical conditions treated with the highest average satisfaction score.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_name", "type": "VARCHAR(255)"},
            {"name": "medical_condition", "type": "VARCHAR(255)"},
            {"name": "follow_up_appointment_date", "type": "DATE"}
        ]
    },
    {
        "name": "treatment_outcomes",
        "columns": [
            {"name": "outcome_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_date", "type": "DATE"},
            {"name": "satisfaction_score", "type": "DECIMAL(3,2)"}
        ]
    },
    {
        "name": "medical_conditions",
        "columns": [
            {"name": "condition_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "condition_name", "type": "VARCHAR(255)"},
            {"name": "condition_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    avg(t1.satisfaction_score) as overall_avg,
    t2.condition_name,
    avg(t1.satisfaction_score) as avg_satisfaction_score
FROM 
    treatment_outcomes t1
JOIN 
    patients t2 ON t1.patient_id = t2.patient_id
JOIN 
    medical_conditions t3 ON t2.medical_condition = t3.condition_name
WHERE 
    t1.treatment_date = (SELECT treatment_date FROM treatment_outcomes WHERE patient_id = t2.patient_id ORDER BY treatment_date DESC LIMIT 1)
    AND t2.follow_up_appointment_date BETWEEN t1.treatment_date AND (t1.treatment_date + INTERVAL 30 DAY)
GROUP BY 
    t2.condition_name
ORDER BY 
    avg_satisfaction_score DESC
LIMIT 5
------------------
A university wants to analyze the academic performance of its students. Analyze the average GPA of students who have declared a major in the College of Engineering, considering only students who have completed at least 2 semesters. Calculate the average GPA for each student and the overall average GPA for the major. Identify the top 5 courses with the highest average GPA for students in the major.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_name", "type": "VARCHAR(255)"},
            {"name": "major", "type": "VARCHAR(255)"},
            {"name": "gpa", "type": "DECIMAL(3,2)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "course_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "student_courses",
        "columns": [
            {"name": "student_course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    AVG(T1.gpa) AS average_gpa,
    T1.student_id,
    T1.student_name,
    T1.major
FROM 
    students T1
INNER JOIN 
    student_courses T2
ON 
    T1.student_id = T2.student_id
WHERE 
    T1.major = 'College of Engineering'
GROUP BY 
    T1.student_id, T1.student_name, T1.major
HAVING 
    COUNT(T2.student_course_id) >= 2

UNION ALL

SELECT 
    'Overall Average GPA' AS average_gpa,
    NULL AS student_id,
    NULL AS student_name,
    'College of Engineering' AS major

UNION ALL

SELECT 
    AVG(T3.grade) AS average_gpa,
    T4.course_id,
    T4.course_name,
    NULL AS major
FROM 
    student_courses T3
INNER JOIN 
    courses T4 ON T3.course_id = T4.course_id
WHERE 
    T4.course_id IN (
        SELECT 
            T5.course_id
        FROM 
            student_courses T5
        INNER JOIN 
            students T6 ON T5.student_id = T6.student_id
        WHERE 
            T6.major = 'College of Engineering'
        GROUP BY 
            T5.course_id
        ORDER BY 
            AVG(T5.grade) DESC
        LIMIT 5
    )
GROUP BY 
    T4.course_id, T4.course_name
------------------
Identify the top 10 most profitable products across all regions, including the total revenue generated for each product, and the average order value for each product. Also, include a column that indicates whether the product is a best-seller (i.e., has an average order value greater than $100).
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "total_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_region",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]}
        ]
    }
]
Response:
SELECT p.product_name, 
       SUM(o.total_price) AS total_revenue, 
       AVG(oi.quantity * p.price) AS average_order_value, 
       CASE WHEN AVG(oi.quantity * p.price) > 100 THEN 'true' ELSE 'false' END AS is_best_seller
FROM products p
JOIN orders o ON p.product_id = o.product_id
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY p.product_name
ORDER BY total_revenue DESC
LIMIT 10
------------------
Analyze the sales performance of a retail company across different product categories. Write a SQL query that retrieves the following information:

- The category name
- The total revenue generated for each category
- The average order value for each category
- The number of orders for each category
- The top 3 products with the highest sales for each category
Schema:
[
    {
        "name": "categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "TEXT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "total_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT c.category_name, 
       SUM(o.total_price) AS total_revenue, 
       AVG(o.total_price) AS avg_order_value, 
       COUNT(o.order_id) AS num_orders,
       (
           SELECT p1.product_name
           FROM products p1
           JOIN order_items oi1 ON p1.product_id = oi1.product_id
           JOIN orders o1 ON oi1.order_id = o1.order_id
           WHERE p1.category_id = c.category_id
           GROUP BY p1.product_name
           ORDER BY SUM(oi1.quantity * p1.price) DESC
           LIMIT 3
       ) AS top_products
FROM categories c
JOIN orders o ON c.category_id = c.category_id
GROUP BY c.category_id, c.category_name
------------------
Develop a SQL query that analyzes the sales performance of a healthcare organization across different departments. Write a query that retrieves the following information:

- The department name
- The total revenue generated for each department
- The average number of patients treated for each department
- The top 3 medical procedures with the highest revenue for each department
Schema:
[
    {
        "name": "departments",
        "columns": [
            {"name": "department_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "department_name", "type": "VARCHAR(255)"},
            {"name": "description", "type": "TEXT"}
        ]
    },
    {
        "name": "medical_procedures",
        "columns": [
            {"name": "procedure_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "procedure_name", "type": "VARCHAR(255)"},
            {"name": "department_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES departments(department_id)"]},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "appointments",
        "columns": [
            {"name": "appointment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "appointment_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "procedure_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES medical_procedures(procedure_id)"]},
            {"name": "total_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "appointment_details",
        "columns": [
            {"name": "appointment_detail_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "appointment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES appointments(appointment_id)"]},
            {"name": "department_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES departments(department_id)"]},
            {"name": "number_of_patients", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  d.department_name, 
  SUM(ap.total_price) AS total_revenue, 
  AVG(ad.number_of_patients) AS avg_patients, 
  (SELECT 
     GROUP_CONCAT(mp.procedure_name, ', ') 
   FROM 
     medical_procedures mp 
   JOIN 
     appointments a ON mp.procedure_id = a.procedure_id 
   JOIN 
     appointment_details ad ON a.appointment_id = ad.appointment_id 
   WHERE 
     ad.department_id = d.department_id 
   ORDER BY 
     mp.price DESC 
   LIMIT 3) AS top_3_procedures
FROM 
  departments d 
  LEFT JOIN appointment_details ad ON d.department_id = ad.department_id 
  LEFT JOIN appointments ap ON ad.appointment_id = ap.appointment_id 
  LEFT JOIN medical_procedures mp ON a.procedure_id = mp.procedure_id 
GROUP BY 
  d.department_id, d.department_name
------------------
**Identifying High-Risk Customers and Predicting Churn**

A retail company wants to identify high-risk customers who are likely to churn within the next 3 months. They have a large customer base and want to analyze their purchase history, account balance, and recent activity to make informed decisions about customer retention.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "account_balance", "type": "DECIMAL(10,2)"},
            {"name": "credit_limit", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "recent_activity",
        "columns": [
            {"name": "activity_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "activity_date", "type": "DATE"},
            {"name": "activity_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "credit_reports",
        "columns": [
            {"name": "report_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "report_date", "type": "DATE"},
            {"name": "credit_score", "type": "INT"}
        ]
    },
    {
        "name": "product_purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT"},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "purchase_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.account_balance, c.credit_limit
FROM customers c
JOIN recent_activity ra ON c.customer_id = ra.customer_id
JOIN credit_reports cr ON c.customer_id = cr.customer_id
WHERE ra.activity_date >= DATE('now', '-3 months')
AND cr.report_date >= DATE('now', '-3 months')
AND c.account_balance < (SELECT AVG(account_balance) FROM customers)
AND c.credit_limit < (SELECT AVG(credit_limit) FROM customers)
AND c.credit_score < (SELECT AVG(credit_score) FROM credit_reports)
ORDER BY c.account_balance ASC;
------------------
**Analyze Flight Delays and Cancellations**

An airline company wants to analyze their flight schedules, delays, and cancellations to identify patterns and trends that can help them improve their operations and customer experience.
Schema:
[
    {
        "name": "flights",
        "columns": [
            {"name": "flight_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "flight_number", "type": "VARCHAR(255)"},
            {"name": "departure_airport", "type": "VARCHAR(255)"},
            {"name": "arrival_airport", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "schedules",
        "columns": [
            {"name": "schedule_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "flight_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES flights(flight_id)"]},
            {"name": "departure_time", "type": "TIME"},
            {"name": "arrival_time", "type": "TIME"}
        ]
    },
    {
        "name": "flight_delays",
        "columns": [
            {"name": "delay_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "flight_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES flights(flight_id)"]},
            {"name": "delay_date", "type": "DATE"},
            {"name": "delay_time", "type": "TIME"},
            {"name": "delay_reason", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "cancellations",
        "columns": [
            {"name": "cancellation_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "flight_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES flights(flight_id)"]},
            {"name": "cancellation_date", "type": "DATE"},
            {"name": "cancellation_reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    f.flight_id,
    f.departure_airport,
    f.arrival_airport,
    s.departure_time AS original_departure_time,
    s.arrival_time AS original_arrival_time,
    fd.delay_date,
    fd.delay_time,
    fd.delay_reason,
    c.cancellation_date,
    c.cancellation_reason
FROM flights f
LEFT JOIN schedules s ON f.flight_id = s.flight_id
LEFT JOIN flight_delays fd ON f.flight_id = fd.flight_id
LEFT JOIN cancellations c ON f.flight_id = c.flight_id
------------------
**Predicting Stock Prices using Time-Series Analysis**

A financial analyst wants to predict stock prices using historical data and identify patterns and trends that can help them make informed investment decisions.
Schema:
[
    {
        "name": "stocks",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_symbol", "type": "VARCHAR(255)"},
            {"name": "company_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "stock_prices",
        "columns": [
            {"name": "price_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "price_date", "type": "DATE"},
            {"name": "open_price", "type": "DECIMAL(10,2)"},
            {"name": "high_price", "type": "DECIMAL(10,2)"},
            {"name": "low_price", "type": "DECIMAL(10,2)"},
            {"name": "close_price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "economic_indicators",
        "columns": [
            {"name": "indicator_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "indicator_date", "type": "DATE"},
            {"name": "indicator_value", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "technical_indicators",
        "columns": [
            {"name": "indicator_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "indicator_date", "type": "DATE"},
            {"name": "indicator_value", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
    s.stock_symbol, 
    s.company_name, 
    sp.close_price, 
    ei.indicator_value AS economic_indicator, 
    ti.indicator_value AS technical_indicator
FROM 
    stocks s
LEFT JOIN 
    stock_prices sp ON s.stock_id = sp.stock_id
LEFT JOIN 
    economic_indicators ei ON s.stock_id = ei.stock_id AND sp.price_date = ei.indicator_date
LEFT JOIN 
    technical_indicators ti ON s.stock_id = ti.stock_id AND sp.price_date = ti.indicator_date;
------------------
**Analyzing Customer Churn and Revenue Trends in E-commerce**

Develop a SQL query to identify the top 5 product categories that contribute to customer churn and revenue loss for an e-commerce company. The query should consider the following criteria:

* Calculate the average order value (AOV) for each product category
* Determine the percentage of customers who churned for each product category
* Identify the top 5 product categories that contribute to the highest revenue loss due to customer churn
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "subscription_date", "type": "DATE"},
            {"name": "churn_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    p.product_category, 
    AVG(o.order_total) AS avg_order_value, 
    (COUNT(DISTINCT c.customer_id) - COUNT(DISTINCT c.customer_id) * (1 - COUNT(o.order_id) / (SELECT COUNT(customer_id) FROM customers))) / COUNT(DISTINCT c.customer_id) AS churn_percentage, 
    (COUNT(o.order_id) * o.order_total - (COUNT(o.order_id) - COUNT(DISTINCT c.customer_id)) * o.order_total) / (SELECT COUNT(customer_id) FROM customers) AS revenue_loss
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    products p ON o.product_category = p.product_category
GROUP BY 
    p.product_category
ORDER BY 
    revenue_loss DESC
LIMIT 
    5
------------------
**Identifying High-Risk Accounts for Credit Risk Assessment**

Develop a SQL query to identify high-risk accounts for credit risk assessment based on historical payment behavior, credit utilization, and credit score. The query should consider the following criteria:

* Calculate the average payment delay for each account
* Determine the percentage of accounts with high credit utilization (above 50%)
* Identify the top 10 accounts with the highest risk score based on a weighted sum of payment delay, credit utilization, and credit score
Schema:
[
    {
        "name": "accounts",
        "columns": [
            {"name": "account_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_name", "type": "VARCHAR(255)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "credit_limit", "type": "DECIMAL(10, 2)"},
            {"name": "credit_score", "type": "INT"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES accounts(account_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "payment_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "credit_utilization",
        "columns": [
            {"name": "utilization_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES accounts(account_id)"]},
            {"name": "utilization_date", "type": "DATE"},
            {"name": "balance", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "credit_history", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT a.account_id, a.account_name, AVG(p.payment_delay) AS avg_payment_delay, 
       COUNT(CASE WHEN cu.balance > (a.credit_limit * 0.5) THEN 1 END) / COUNT(a.account_id) * 100 AS high_credit_utilization_rate, 
       r.risk_score
FROM accounts a
JOIN payments p ON a.account_id = p.account_id
JOIN (
  SELECT account_id, 
         (CASE 
           WHEN SUM(payment_amount) > 0 THEN AVG(DATEDIFF(date('now'), payment_date)) 
           ELSE 0 
         END) AS payment_delay
  FROM payments
  GROUP BY account_id
) p_delay ON p.account_id = p_delay.account_id
JOIN (
  SELECT account_id, 
         balance / credit_limit * 100 AS utilization_rate
  FROM credit_utilization
  JOIN accounts ON credit_utilization.account_id = accounts.account_id
) cu ON a.account_id = cu.account_id
CROSS JOIN (
  SELECT 0.4 * AVG(p_delay.payment_delay) + 0.3 * (100 - cu.utilization_rate) + 0.3 * a.credit_score AS risk_score
  FROM (
    SELECT account_id, 
           (CASE 
             WHEN SUM(payment_amount) > 0 THEN AVG(DATEDIFF(date('now'), payment_date)) 
             ELSE 0 
           END) AS payment_delay
    FROM payments
    GROUP BY account_id
  ) p_delay
  JOIN (
    SELECT account_id, 
           balance / credit_limit * 100 AS utilization_rate
    FROM credit_utilization
    JOIN accounts ON credit_utilization.account_id = accounts.account_id
  ) cu ON p_delay.account_id = cu.account_id
  JOIN accounts a ON p_delay.account_id = a.account_id
) r
WHERE a.account_id IN (SELECT account_id FROM payments)
GROUP BY a.account_id, a.account_name, r.risk_score
ORDER BY r.risk_score DESC
LIMIT 10
------------------
**Analyzing Sales Performance by Region and Product Category**

Develop a SQL query to analyze sales performance by region and product category. The query should consider the following criteria:

* Calculate the total sales revenue for each region
* Determine the top 5 product categories with the highest sales revenue for each region
* Identify the regions with the highest average sales revenue per product category
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    r.region_name AS region,
    pc.product_category_name AS product_category,
    SUM(s.sale_amount) AS total_sales_revenue
FROM 
    sales s
JOIN 
    regions r ON s.region_id = r.region_id
JOIN 
    product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY 
    r.region_id, pc.product_category_id
ORDER BY 
    r.region_name, pc.product_category_name

UNION ALL

SELECT 
    r.region_name AS region,
    pc.product_category_name AS product_category,
    SUM(s.sale_amount) AS total_sales_revenue
FROM 
    sales s
JOIN 
    regions r ON s.region_id = r.region_id
JOIN 
    product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY 
    r.region_id, pc.product_category_id
ORDER BY 
    r.region_name, pc.product_category_name

ORDER BY 
    region, product_category, total_sales_revenue DESC

LIMIT 5;

---

SELECT 
    r.region_name AS region,
    pc.product_category_name AS product_category,
    AVG(s.sale_amount) AS average_sales_revenue
FROM 
    sales s
JOIN 
    regions r ON s.region_id = r.region_id
JOIN 
    product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY 
    r.region_id, pc.product_category_id
ORDER BY 
    AVG(s.sale_amount) DESC;

---

SELECT 
    r.region_name AS region,
    pc.product_category_name AS product_category,
    AVG(s.sale_amount) AS average_sales_revenue
FROM 
    sales s
JOIN 
    regions r ON s.region_id = r.region_id
JOIN 
    product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY 
    r.region_id, pc.product_category_id
HAVING 
    AVG(s.sale_amount) = (
        SELECT 
            AVG(s.sale_amount)
        FROM 
            sales s
        JOIN 
            regions r ON s.region_id = r.region_id
        JOIN 
            product_categories pc ON s.product_category_id = pc.product_category_id
        GROUP BY 
            r.region_id
    )
------------------
**Identifying Customers with High Purchase Frequency**

Develop a SQL query to identify customers with high purchase frequency. The query should consider the following criteria:

* Calculate the average purchase frequency for each customer
* Determine the top 10 customers with the highest purchase frequency
* Identify the product categories with the highest average purchase frequency for each customer
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_history", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, AVG(o.quantity) as avg_purchase_frequency
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name, c.email
ORDER BY avg_purchase_frequency DESC
LIMIT 10;

SELECT pc.product_category_name, c.customer_id, c.name, c.email, AVG(o.quantity) as avg_purchase_frequency
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN product_categories pc ON o.product_category_id = pc.product_category_id
GROUP BY pc.product_category_name, c.customer_id, c.name, c.email
ORDER BY pc.product_category_name, avg_purchase_frequency DESC;
------------------
**Analyzing Product Returns and Refunds**

Develop a SQL query to analyze product returns and refunds. The query should consider the following criteria:

* Calculate the total number of returns for each product category
* Determine the top 5 products with the highest return rate
* Identify the regions with the highest average refund amount for each product category
Schema:
[
    {
        "name": "returns",
        "columns": [
            {"name": "return_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "return_date", "type": "DATE"},
            {"name": "refund_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  pc.product_category_name, 
  COUNT(r.return_id) AS total_returns, 
  p.product_name, 
  r.return_date, 
  r.refund_amount, 
  AVG(r.refund_amount) AS avg_refund_amount

FROM 
  returns r
  JOIN products p ON r.product_category_id = p.product_category_id
  JOIN product_categories pc ON p.product_category_id = pc.product_category_id
  JOIN (
    SELECT 
      product_category_id, 
      AVG(refund_amount) AS avg_refund_amount
    FROM 
      returns
    GROUP BY 
      product_category_id
  ) AS refund_avg ON r.product_category_id = refund_avg.product_category_id

GROUP BY 
  pc.product_category_name, 
  p.product_name, 
  r.return_date, 
  r.refund_amount

ORDER BY 
  pc.product_category_name, 
  total_returns DESC

LIMIT 5
------------------
**Identifying Opportunities for Cross-Selling and Upselling**

Develop a SQL query to identify opportunities for cross-selling and upselling. The query should consider the following criteria:

* Determine the top 5 products with the highest average selling price
* Identify the customers who have purchased multiple products from the same category
* Calculate the total revenue generated from cross-selling and upselling opportunities
Schema:
[
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_history", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  p.product_name,
  AVG(p.price) AS avg_selling_price
FROM 
  orders o
  JOIN products p ON o.product_id = p.product_id
GROUP BY 
  p.product_name
ORDER BY 
  avg_selling_price DESC
LIMIT 5;

WITH cross_sell_opportunities AS (
  SELECT 
    o.customer_id,
    p.product_name,
    o.order_date,
    o.quantity,
    SUM(o.quantity) OVER (PARTITION BY o.customer_id) AS total_purchases
  FROM 
    orders o
    JOIN products p ON o.product_id = p.product_id
  WHERE 
    o.customer_id IN (
      SELECT 
        customer_id
      FROM 
        orders
      GROUP BY 
        customer_id
      HAVING 
        COUNT(DISTINCT product_id) > 1
    )
)
SELECT 
  customer_id,
  product_name,
  order_date,
  quantity,
  total_purchases
FROM 
  cross_sell_opportunities
WHERE 
  product_name IN (
    SELECT 
      product_name
    FROM 
      products
    GROUP BY 
      product_name
    HAVING 
      AVG(price) > (
        SELECT 
          AVG(price)
        FROM 
          products
      )
  );

WITH upsell_opportunities AS (
  SELECT 
    o.customer_id,
    p.product_name,
    o.order_date,
    o.quantity,
    o.quantity / (
      SELECT 
        AVG(quantity)
      FROM 
        orders o2
        JOIN products p2 ON o2.product_id = p2.product_id
      WHERE 
        o2.customer_id = o.customer_id
    ) AS upsell_ratio
  FROM 
    orders o
    JOIN products p ON o.product_id = p.product_id
)
SELECT 
  customer_id,
  product_name,
  order_date,
  quantity,
  upsell_ratio
FROM 
  upsell_opportunities
WHERE 
  upsell_ratio > 1;

WITH revenue AS (
  SELECT 
    o.customer_id,
    p.product_name,
    o.order_date,
    o.quantity,
    p.price * o.quantity AS revenue
  FROM 
    orders o
    JOIN products p ON o.product_id = p.product_id
)
SELECT 
  SUM(revenue) AS total_revenue
FROM 
  revenue;
------------------
**Predicting Customer Churn and Identifying High-Risk Customers**
A telecom company wants to identify customers who are likely to churn within the next 3 months based on their past behavior and demographic characteristics.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "CHAR(1)"},
            {"name": "plan_type", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "service_plan", "type": "VARCHAR(50)"},
            {"name": "charge", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "charges",
        "columns": [
            {"name": "charge_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "charge_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "call_logs",
        "columns": [
            {"name": "log_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "call_date", "type": "DATE"},
            {"name": "duration", "type": "INT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.age, c.gender, c.plan_type
FROM customers c
JOIN (
    SELECT customer_id, COUNT(*) as num_orders, SUM(charge) as total_charge, MAX(call_date) as last_call_date
    FROM orders
    JOIN charges ON orders.order_id = charges.order_id
    JOIN call_logs ON customers.customer_id = call_logs.customer_id
    WHERE orders.order_date >= DATE('now', '-3 months')
    GROUP BY customer_id
) o ON c.customer_id = o.customer_id
WHERE o.num_orders < 3 OR o.total_charge < 100.0 OR o.last_call_date < DATE('now', '-3 months')
------------------
**Analyzing Sales Performance by Region and Product Category**
A retail company wants to analyze sales performance by region and product category, including the top-selling products in each region and the total sales revenue for each product category.
Schema:
[
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  s.region, 
  p.category, 
  SUM(s.quantity * s.price) AS total_revenue, 
  p.name AS top_selling_product
FROM 
  sales s
JOIN 
  products p ON s.product_id = p.product_id
GROUP BY 
  s.region, 
  p.category, 
  p.name
ORDER BY 
  s.region, 
  p.category, 
  total_revenue DESC
------------------
**Identifying High-Value Customers and Their Purchase Patterns**
A fashion brand wants to identify high-value customers and analyze their purchase patterns, including the frequency and amount of their purchases.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, COUNT(o.order_id) as purchase_frequency, SUM(o.total_amount) as total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.name, c.email
HAVING COUNT(o.order_id) > 5 AND SUM(o.total_amount) > 1000
------------------
Analyze sales trends across different regions and product categories, and identify the top-selling products in each region, while considering the impact of promotional campaigns on sales.
Schema:
[
    {
        "name": "sales_data",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(100)"},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
            {"name": "discount_percentage", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "promotions",
        "columns": [
            {"name": "promotion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(100)"},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"},
            {"name": "discount_percentage", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "product_info",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "average_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(100)"},
            {"name": "region_code", "type": "VARCHAR(10)"}
        ]
    }
]
Response:
SELECT 
  s.region, 
  p.product_category, 
  p.product_name, 
  SUM(s.sale_amount) AS total_sales, 
  SUM(s.sale_amount * (1 - s.discount_percentage / 100)) AS net_sales
FROM 
  sales_data s
JOIN 
  product_info p 
  ON s.product_name = p.product_name
JOIN 
  regions r 
  ON s.region = r.region_name
LEFT JOIN 
  promotions pr 
  ON s.region = pr.region 
  AND s.product_category = pr.product_category 
  AND s.sale_date BETWEEN pr.start_date AND pr.end_date
GROUP BY 
  s.region, 
  p.product_category, 
  p.product_name
ORDER BY 
  s.region, 
  total_sales DESC
------------------
Identify the most profitable customers in a retail store, based on their purchase history, and segment them into different groups based on their average order value and frequency of purchases.
Schema:
[
    {
        "name": "customer_info",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customer_info(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_info",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "average_price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.customer_name,
    c.email,
    AVG(o.order_total) AS avg_order_value,
    COUNT(o.order_id) AS purchase_frequency
INTO #temp
FROM customer_info c
JOIN orders o ON c.customer_id = o.customer_id
GROUP BY c.customer_id, c.customer_name, c.email
HAVING AVG(o.order_total) > 100 AND COUNT(o.order_id) > 5

SELECT 
    customer_id,
    customer_name,
    email,
    avg_order_value,
    purchase_frequency
FROM (
    SELECT 
        customer_id,
        customer_name,
        email,
        avg_order_value,
        purchase_frequency,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY avg_order_value) OVER (PARTITION BY customer_id) AS upper_75_percentile,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY avg_order_value) OVER (PARTITION BY customer_id) AS lower_25_percentile
    FROM #temp
) t
WHERE upper_75_percentile > lower_25_percentile
------------------
Analyze the impact of weather conditions on sales of different products in a retail store, and identify the top-selling products during different weather conditions.
Schema:
[
    {
        "name": "weather_data",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "city", "type": "VARCHAR(100)"},
            {"name": "state", "type": "VARCHAR(100)"},
            {"name": "weather_condition", "type": "VARCHAR(100)"},
            {"name": "temperature", "type": "DECIMAL(5, 2)"},
            {"name": "humidity", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_info(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "product_info",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "average_price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    WD.weather_condition,
    WI.product_name,
    WI.average_price,
    SUM(SD.sale_amount) AS total_sales
FROM 
    sales_data SD
JOIN 
    product_info WI ON SD.product_id = WI.product_id
JOIN 
    weather_data WD ON SD.sale_date = WD.city
GROUP BY 
    WD.weather_condition, WI.product_name, WI.average_price
ORDER BY 
    WD.weather_condition, WI.product_name, total_sales DESC
------------------
**Analyzing Customer Churn and Predicting Future Churn in the Telecommunications Industry**
Develop a SQL query that calculates the churn rate for each region, identifies the top 3 regions with the highest churn rates, and forecasts the future churn rate for each region based on historical data and seasonality.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "subscription_date", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "churn_data",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "seasonality",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "season", "type": "VARCHAR(20)"}
        ]
    }
]
Response:
SELECT 
  c.region, 
  COUNT(c.customer_id) AS total_customers, 
  SUM(CASE WHEN CHURN_DATA.customer_id IS NOT NULL THEN 1 ELSE 0 END) AS churned_customers, 
  (SUM(CASE WHEN CHURN_DATA.customer_id IS NOT NULL THEN 1 ELSE 0 END) / COUNT(c.customer_id)) * 100 AS churn_rate
FROM customers c 
LEFT JOIN churn_data ON c.customer_id = CHURN_DATA.customer_id 
GROUP BY c.region 
ORDER BY churn_rate DESC 
LIMIT 3;

WITH forecast AS (
  SELECT 
    seasonality.season, 
    EXTRACT(MONTH FROM seasonality.date) AS month, 
    AVG(churn_rate) AS average_churn_rate
  FROM (
    SELECT 
      EXTRACT(YEAR FROM seasonality.date) * 12 + EXTRACT(MONTH FROM seasonality.date) AS date_year_month, 
      c.region, 
      c.name, 
      CHURN_DATA.customer_id AS churned_customer_id, 
      CHURN_DATA.churn_date, 
      c.subscription_date, 
      EXTRACT(YEAR FROM c.subscription_date) * 12 + EXTRACT(MONTH FROM c.subscription_date) AS subscription_date_year_month, 
      CASE WHEN CHURN_DATA.customer_id IS NOT NULL THEN 1 ELSE 0 END AS churned
    FROM customers c 
    LEFT JOIN churn_data ON c.customer_id = CHURN_DATA.customer_id 
    LEFT JOIN seasonality ON EXTRACT(YEAR FROM c.subscription_date) = seasonality.date
  ) AS subquery 
  GROUP BY seasonality.season, EXTRACT(MONTH FROM seasonality.date)
)
SELECT 
  f.season, 
  f.month, 
  f.average_churn_rate, 
  (f.average_churn_rate / 100) * (SELECT COUNT(c.customer_id) FROM customers c WHERE c.region = f.season) AS forecasted_churn
FROM forecast f
------------------
**Analyzing Sales Performance and Identifying Opportunities for Growth in the Retail Industry**
Develop a SQL query that calculates the total sales revenue for each product category, identifies the top 3 products with the highest sales growth rates, and forecasts the future sales revenue for each product category based on historical data and market trends.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales_data",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "sales", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "market_trends",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "trend", "type": "VARCHAR(20)"}
        ]
    }
]
Response:
SELECT 
    p.category, 
    SUM(s.sales) as total_sales
FROM 
    sales_data s
JOIN 
    orders o ON s.order_id = o.order_id
JOIN 
    products p ON o.product_id = p.product_id
GROUP BY 
    p/category
ORDER BY 
    total_sales DESC

WITH RECURSIVE top_categories AS (
    SELECT 
        p.category, 
        SUM(s.sales) as total_sales,
        ROW_NUMBER() OVER (ORDER BY SUM(s.sales) DESC) as rank
    FROM 
        sales_data s
    JOIN 
        orders o ON s.order_id = o.order_id
    JOIN 
        products p ON o.product_id = p.product_id
    GROUP BY 
        p.category
),
top_products AS (
    SELECT 
        p.name, 
        o.order_id, 
        o.order_date, 
        s.sales,
        (s.sales / LAG(s.sales, 1, 0) OVER (ORDER BY o.order_id)) as sales_growth_rate,
        ROW_NUMBER() OVER (ORDER BY (s.sales / LAG(s.sales, 1, 0) OVER (ORDER BY o.order_id)) DESC) as rank
    FROM 
        sales_data s
    JOIN 
        orders o ON s.order_id = o.order_id
    JOIN 
        products p ON o.product_id = p.product_id
)
SELECT 
    * 
FROM 
    top_products
WHERE 
    rank <= 3

WITH RECURSIVE forecast AS (
    SELECT 
        p.category, 
        SUM(s.sales) as total_sales,
        (SELECT 
             AVG(mt.trend) 
         FROM 
             market_trends mt 
         WHERE 
             mt.date <= (SELECT MIN(order_date) FROM orders)) as trend
    FROM 
        sales_data s
    JOIN 
        orders o ON s.order_id = o.order_id
    JOIN 
        products p ON o.product_id = p.product_id
    GROUP BY 
        p.category
),
forecasted_sales AS (
    SELECT 
        f.category, 
        SUM(f.total_sales * (f.trend + (f.trend / 100))) as forecasted_sales
    FROM 
        forecast f
    GROUP BY 
        f.category
)
SELECT 
    * 
FROM 
    forecasted_sales
------------------
**Analyzing Student Performance and Identifying Factors that Affect Academic Success in the Education Industry**
Develop a SQL query that calculates the average GPA for each student, identifies the top 3 students with the highest GPAs, and forecasts the future academic performance of students based on their past performance, attendance, and demographics.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "grade_level", "type": "INT"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "grade", "type": "DECIMAL(3,2)"}
        ]
    },
    {
        "name": "attendance",
        "columns": [
            {"name": "attendance_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "absent", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "parent_education", "type": "VARCHAR(50)"},
            {"name": "family_income", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
  AVG(g.grade) AS avg_gpa,
  s.student_id,
  s.name
FROM 
  students s
  JOIN grades g ON s.student_id = g.student_id
GROUP BY 
  s.student_id, s.name
ORDER BY 
  avg_gpa DESC

SELECT 
  student_id,
  name,
  AVG(g.grade) AS avg_gpa
FROM 
  students s
  JOIN grades g ON s.student_id = g.student_id
GROUP BY 
  s.student_id, s.name
ORDER BY 
  avg_gpa DESC
LIMIT 3

WITH ranked_students AS (
  SELECT 
    student_id,
    name,
    AVG(g.grade) AS avg_gpa,
    RANK() OVER (ORDER BY AVG(g.grade) DESC) AS rank
  FROM 
    students s
    JOIN grades g ON s.student_id = g.student_id
  GROUP BY 
    s.student_id, s.name
)
SELECT 
  *
FROM 
  ranked_students
WHERE 
  rank <= 3
------------------
**Predict Customer Churn in a Telecom Company**
Develop a SQL query to identify the top 5 customer segments most likely to churn within the next 6 months. The query should include customer demographics, subscription plans, and historical usage data.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "subscription_plan", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "FLOAT"},
            {"name": "voice_usage", "type": "FLOAT"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.age, c.gender, c.subscription_plan, 
       SUM(u.data_usage) AS total_data_usage, SUM(u.voice_usage) AS total_voice_usage, 
       MAX(cu.churn_date) AS churn_date
FROM customers c
JOIN usage u ON c.customer_id = u.customer_id
LEFT JOIN churn cu ON c.customer_id = cu.customer_id AND cu.churn_date BETWEEN DATE('now', '-6 months') AND DATE('now')
GROUP BY c.customer_id, c.name, c.age, c.gender, c.subscription_plan
ORDER BY total_data_usage DESC, total_voice_usage DESC
LIMIT 5
------------------
**Analyze Inventory Levels and Sales Trends in a Retail Company**
Develop a SQL query to identify the top 10 products by sales revenue, sales channel, and inventory level. The query should include product attributes, sales history, and inventory levels.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(100)"},
            {"name": "subcategory", "type": "VARCHAR(100)"},
            {"name": "price", "type": "FLOAT"},
            {"name": "weight", "type": "FLOAT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_channel", "type": "VARCHAR(50)"},
            {"name": "sales_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "FLOAT"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "inventory_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, s.sales_channel, SUM(s.revenue) AS total_revenue, i.quantity AS inventory_level 
FROM products p 
JOIN sales s ON p.product_id = s.product_id 
JOIN inventory i ON p.product_id = i.product_id 
GROUP BY p.product_name, s.sales_channel, i.quantity 
ORDER BY total_revenue DESC 
LIMIT 10;
------------------
Identify the top-performing product lines for each region, considering both revenue and profit margins, and provide a ranked list of the top 3 product lines for each region.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"},
            {"name": "profit_margin", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_subcategory", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT region, product_name, revenue, profit_margin FROM (
  SELECT 
    region, product_name, revenue, profit_margin, 
    ROW_NUMBER() OVER (PARTITION BY region ORDER BY revenue * profit_margin DESC) AS revenue_profit_rank,
    ROW_NUMBER() OVER (PARTITION BY region ORDER BY profit_margin DESC) AS profit_margin_rank
  FROM sales
) subquery
WHERE revenue_profit_rank <= 3 OR profit_margin_rank <= 3
------------------
Analyze the sales performance of products in different categories and subcategories, and identify the top 5 products in each category with the highest revenue. Also, provide the total revenue for each category.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "subcategory", "type": "VARCHAR(255)"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_subcategory", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  p.product_category, 
  p.product_subcategory, 
  s.product_name, 
  s.revenue
FROM 
  sales s
JOIN 
  products p ON s.product_id  =  p.product_id
GROUP BY 
  p.product_category, 
  p.product_subcategory, 
  s.product_name, 
  s.revenue
ORDER BY 
  s.revenue DESC
LIMIT 5

UNION ALL

SELECT 
  product_category, 
  product_subcategory, 
  NULL, 
  SUM(revenue)
FROM 
  sales
GROUP BY 
  product_category, 
  product_subcategory
------------------
Develop a financial forecasting model to predict the total revenue for the next quarter based on historical sales data. Consider the impact of seasonality, holidays, and economic indicators.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"},
            {"name": "seasonality", "type": "INT"},
            {"name": "holiday", "type": "BOOLEAN"},
            {"name": "economic_indicator", "type": "INT"}
        ]
    },
    {
        "name": "economic_indicators",
        "columns": [
            {"name": "economic_indicator_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "indicator_name", "type": "VARCHAR(255)"},
            {"name": "indicator_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    DATE_TRUNC('quarter', date) AS quarter,
    SUM(revenue) AS total_revenue,
    AVG(seasonality) AS average_seasonality,
    COUNT(CASE WHEN holiday = TRUE THEN 1 END) AS holiday_count,
    AVG(economic_indicator) AS average_economic_indicator
FROM 
    sales
JOIN 
    (
    SELECT 
        economic_indicator_id,
        indicator_name,
        AVG(indicator_value) AS average_value
    FROM 
        economic_indicators
    GROUP BY 
        economic_indicator_id, indicator_name
    ) AS avg_economic_indicators
ON 
    sales.economic_indicator = avg_economic_indicators.economic_indicator_id
WHERE 
    date >= DATE_TRUNC('quarter', 'now') AND date < DATE_TRUNC('quarter', 'now') + 1
GROUP BY 
    quarter
ORDER BY 
    quarter
------------------
Perform customer segmentation based on their purchase history, demographic data, and behavioral characteristics. Identify the most valuable customers and provide a list of their purchase history, demographics, and behavioral characteristics.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.age,
    c.income,
    o.order_id,
    o.order_date,
    p.product_name,
    p.product_category
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    products p ON o.product_id = p.product_id
WHERE 
    o.order_date >= DATE('2020-01-01')
ORDER BY 
    c.income DESC
------------------
Develop an inventory management system to track the movement of products across different warehouses and locations. Provide a list of products that are out of stock, along with their current stock levels and warehouse locations.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "stock_level", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, i.stock_level, w.location 
FROM products p 
JOIN inventory i ON p.product_id = i.product_id 
JOIN warehouses w ON i.warehouse_id = w.warehouse_id 
WHERE i.stock_level = 0;
------------------
Analyze the performance of different marketing campaigns and identify the most effective channels and strategies. Provide a list of top-performing campaigns, along with their conversion rates and return on investment (ROI).
Schema:
[
    {
        "name": "campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "channel", "type": "VARCHAR(255)"},
            {"name": "strategy", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES campaigns(campaign_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.campaign_name, c.channel, c.strategy, o.order_id, o.order_date, o.revenue, 
       (o.revenue / c.revenue) AS conversion_rate, 
       (o.revenue / (SELECT SUM(revenue) FROM orders WHERE campaign_id = c.campaign_id)) AS roi
FROM campaigns c
JOIN orders o ON c.campaign_id = o.campaign_id
ORDER BY conversion_rate DESC;
------------------
Develop a recommendation system to suggest products to customers based on their purchase history and demographic data. Provide a list of recommended products for each customer, along with their predicted ratings and probabilities.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "ratings",
        "columns": [
            {"name": "rating_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "rating", "type": "DECIMAL(4, 2)"}
        ]
    }
]
Response:
SELECT p.product_name, r.rating, r.rating_id, 
       (SELECT COUNT(r2.rating_id) 
        FROM ratings r2 
        WHERE r2.customer_id = c.customer_id AND r2.product_id = r.product_id) AS freq,
       (ROUND((SELECT COUNT(r2.rating_id) 
               FROM ratings r2 
               WHERE r2.customer_id = c.customer_id AND r2.product_id = r.product_id) 
              * 1.0 / (SELECT COUNT(r.rating_id) 
                      FROM ratings r 
                      WHERE r.customer_id = c.customer_id), 2)) AS prob
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN products p ON o.product_id = p.product_id
JOIN ratings r ON o.product_id = r.product_id
WHERE c.customer_id = 1
GROUP BY p.product_name, r.rating, r.rating_id, freq, prob
ORDER BY freq DESC, prob DESC;
------------------
Develop a system to track the status of customer service requests and provide a list of open and resolved requests, along with their corresponding status and timestamps.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "requests",
        "columns": [
            {"name": "request_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "request_date", "type": "DATE"},
            {"name": "status", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "request_status",
        "columns": [
            {"name": "status_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "status_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
CREATE TABLE request_status (
    status_id INT PRIMARY KEY,
    status_name VARCHAR(255)
);

INSERT INTO request_status (status_id, status_name)
VALUES 
(1, 'Open'),
(2, 'Resolved'),
(3, 'On Hold');

CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(255),
    email VARCHAR(255)
);

CREATE TABLE requests (
    request_id INT PRIMARY KEY,
    customer_id INT,
    request_date DATE,
    status_id INT,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id),
    FOREIGN KEY (status_id) REFERENCES request_status(status_id)
);

INSERT INTO customers (customer_id, name, email)
VALUES 
(1, 'John Doe', 'john.doe@example.com'),
(2, 'Jane Doe', 'jane.doe@example.com');

INSERT INTO requests (request_id, customer_id, request_date, status_id)
VALUES 
(1, 1, '2022-01-01', 1),
(2, 1, '2022-01-15', 2),
(3, 2, '2022-02-01', 1),
(4, 2, '2022-03-01', 2);

SELECT r.request_id, r.customer_id, r.request_date, rs.status_name, rs.status_id
FROM requests r
JOIN request_status rs ON r.status_id = rs.status_id
WHERE rs.status_id IN (1, 2)
------------------
Analyze the student performance data from a university and identify the top-performing students, courses, and instructors in each department. Provide a list of top-performing students, courses, and instructors, along with their corresponding grades and performance metrics.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "instructors",
        "columns": [
            {"name": "instructor_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "DECIMAL(3, 2)"}
        ]
    }
]
Response:
SELECT 
  S.name AS StudentName, 
  S.email AS StudentEmail, 
  C.course_name AS CourseName, 
  C.department AS Department, 
  I.name AS InstructorName, 
  G.grade AS Grade,
  ROW_NUMBER() OVER (PARTITION BY C.department ORDER BY G.grade DESC) AS StudentRank,
  ROW_NUMBER() OVER (PARTITION BY C.department ORDER BY G.grade DESC) AS CourseRank,
  ROW_NUMBER() OVER (PARTITION BY C.department ORDER BY G.grade DESC) AS InstructorRank
FROM 
  grades G 
  INNER JOIN students S ON G.student_id = S.student_id 
  INNER JOIN courses C ON G.course_id = C.course_id 
  INNER JOIN instructors I ON C.instructor_id = I.instructor_id
------------------
Develop a system to track the sales performance of different sales teams and provide a list of top-performing teams, along with their corresponding sales metrics and performance indicators.
Schema:
[
    {
        "name": "sales_teams",
        "columns": [
            {"name": "team_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "team_name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "team_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_teams(team_id)"]}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  t.team_name, 
  SUM(o.revenue) AS total_revenue, 
  COUNT(o.order_id) AS total_orders, 
  AVG(o.revenue) AS average_revenue
FROM 
  sales_teams t
  JOIN employees e ON t.team_id = e.team_id
  JOIN orders o ON e.employee_id = o.employee_id
GROUP BY 
  t.team_name
ORDER BY 
  total_revenue DESC
------------------
**Identify the Top 10 Product Categories with the Most Sales Growth in the Last Quarter, Categorized by Region and with a 20% Margin of Error**

A retail company wants to analyze sales trends by product category, region, and time period. The goal is to identify the top 10 product categories with the most sales growth in the last quarter, considering a 20% margin of error.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "name", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(20)"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(50)"},
            {"name": "code", "type": "VARCHAR(10)"}
        ]
    }
]
Response:
SELECT 
  p.category, 
  r.name AS region, 
  SUM(o.quantity * o.price) AS total_sales, 
  SUM(s.quantity * s.price) AS total_sales_last_quarter, 
  (SUM(s.quantity * s.price) - SUM(o.quantity * o.price)) / SUM(o.quantity * o.price) AS sales_growth_percentage,
  p.category
FROM 
  products p 
  JOIN orders o ON p.product_id = o.product_id 
  JOIN regions r ON o.region = r.code 
  JOIN sales s ON o.order_id = s.order_id 
  AND s.sale_date BETWEEN (o.order_date - INTERVAL 3 QUARTER) AND o.order_date 
GROUP BY 
  p.category, 
  r.name 
ORDER BY 
  sales_growth_percentage DESC 
LIMIT 10
------------------
**Analyze Customer Churn and Identify the Most Valuable Customers**

A telecom company wants to identify customers who are likely to churn and those who are most valuable. The goal is to analyze customer behavior, identify patterns, and provide insights to improve customer retention and increase revenue.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(100)"},
            {"name": "email", "type": "VARCHAR(100)"},
            {"name": "phone", "type": "VARCHAR(20)"},
            {"name": "plan", "type": "VARCHAR(20)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "INT"},
            {"name": "call_minutes", "type": "INT"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.plan, 
    SUM(P.amount) AS total_payment,
    COUNT(u.usage_id) AS total_usage,
    COUNT(p.payment_id) AS total_payments,
    u.usage_date,
    u.data_usage,
    u.call_minutes
FROM 
    customers c
JOIN 
    usage u ON c.customer_id = u.customer_id
JOIN 
    payments p ON c.customer_id = p.customer_id
WHERE 
    c.signup_date > DATE('now', '-1 year')
GROUP BY 
    c.customer_id, c.name, c.email, c.plan
HAVING 
    SUM(P.amount) < 1000 AND COUNT(u.usage_id) < 12 AND COUNT(p.payment_id) < 6
------------------
**Predicting Customer Churn in the Telecom Industry**
Develop a SQL query to identify high-value customers who are likely to churn within the next 6 months, based on their historical usage patterns, plan types, and demographic information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone_number", "type": "VARCHAR(20)"},
            {"name": "account_creation_date", "type": "DATE"}
        ]
    },
    {
        "name": "plans",
        "columns": [
            {"name": "plan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "plan_name", "type": "VARCHAR(100)"},
            {"name": "data_limit", "type": "INT"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "usage_data",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "INT"}
        ]
    },
    {
        "name": "churn_risk_factors",
        "columns": [
            {"name": "risk_factor_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "plan_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES plans(plan_id)"]},
            {"name": "average_monthly_data_usage", "type": "DECIMAL(10, 2)"},
            {"name": "account_age", "type": "INT"},
            {"name": "demographic_segment", "type": "VARCHAR(50)"},
            {"name": "risk_score", "type": "INT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.phone_number, c.account_creation_date 
FROM customers c 
JOIN churn_risk_factors cr ON c.customer_id = cr.customer_id 
WHERE cr.risk_score > 50 AND cr.average_monthly_data_usage > (SELECT AVG(average_monthly_data_usage) FROM churn_risk_factors WHERE risk_score > 50) 
AND cr.account_age < 60;
------------------
**Analyzing Sales Performance across Different Regions**
Develop a SQL query to compare the sales performance of top-performing regions in the last quarter, considering the total sales, average order value, and customer acquisition costs.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(100)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "average_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customer_acquisition_costs",
        "columns": [
            {"name": "cac_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "acquisition_date", "type": "DATE"},
            {"name": "cost", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  s.region, 
  SUM(s.total_revenue) AS total_sales, 
  AVG(p.average_price * s.quantity) AS avg_order_value, 
  SUM(cac.cost) AS customer_acquisition_costs
FROM 
  sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN customer_acquisition_costs cac ON s.region = cac.region
WHERE 
  s.order_date >= DATE('now', '-3 months')
GROUP BY 
  s.region
ORDER BY 
  total_sales DESC
------------------
**Identifying High-Risk Accounts in the Healthcare Industry**
Develop a SQL query to identify patients with high-risk medical conditions, considering their medical history, medication adherence, and laboratory results.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "date_of_birth", "type": "DATE"}
        ]
    },
    {
        "name": "medical_history",
        "columns": [
            {"name": "history_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "condition", "type": "VARCHAR(100)"},
            {"name": "diagnosis_date", "type": "DATE"}
        ]
    },
    {
        "name": "medication_adherence",
        "columns": [
            {"name": "adherence_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "medication", "type": "VARCHAR(100)"},
            {"name": "adherence_rate", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "lab_results",
        "columns": [
            {"name": "result_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "test_name", "type": "VARCHAR(100)"},
            {"name": "result_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT p.patient_id, p.name 
FROM patients p 
JOIN medical_history mh ON p.patient_id = mh.patient_id 
JOIN medication_adherence ma ON p.patient_id = ma.patient_id 
JOIN lab_results lr ON p.patient_id = lr.patient_id 
WHERE mh.condition IN ('Diabetes', 'Hypertension', 'Heart Disease') 
AND ma.adherence_rate < 0.8 
AND lr.test_name = 'Cholesterol' 
AND lr.result_value > 200;
------------------
**Identify the top-performing sales regions and their corresponding product categories across the United States, considering only regions with at least 10 customers and a total sales revenue of over $1 million in the last quarter.**
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "region_sales",
        "columns": [
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    r.region, 
    p.category, 
    rs.sales_amount
FROM 
    region_sales rs
INNER JOIN 
    products p ON rs.sales_amount = (SELECT SUM(sales_amount) FROM orders o WHERE o.product_id = p.product_id)
INNER JOIN 
    customers c ON c.region = rs.region
GROUP BY 
    r.region, 
    p.category
HAVING 
    COUNT(c.customer_id) >= 10 AND 
    SUM(rs.sales_amount) > 1000000 AND 
    rs.region IN (SELECT region FROM region_sales GROUP BY region HAVING COUNT(customer_id) >= 10);

SELECT 
    p.category, 
    SUM(rs.sales_amount) as sales_amount
FROM 
    region_sales rs
INNER JOIN 
    products p ON rs.sales_amount = (SELECT SUM(sales_amount) FROM orders o WHERE o.product_id = p.product_id)
GROUP BY 
    p.category
HAVING 
    SUM(rs.sales_amount) > 1000000;
------------------
**Analyze the sales performance of products across different sales channels (in-store, online, and mobile app) and customer segments (age, income, and location) in the retail industry, considering only products with at least $100,000 in sales and a sales channel that has at least 100 customers.**
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"},
            {"name": "location", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_channel", "type": "VARCHAR(20)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "description", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_channels",
        "columns": [
            {"name": "sales_channel", "type": "VARCHAR(20)"},
            {"name": "customer_count", "type": "INT"}
        ]
    },
    {
        "name": "customer_segments",
        "columns": [
            {"name": "segment", "type": "VARCHAR(20)"},
            {"name": "customer_count", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    s.sales_channel, 
    cs.segment, 
    p.description, 
    SUM(o.sales_amount) AS sales_amount
FROM 
    orders o
JOIN 
    products p ON o.product_id = p.product_id
JOIN 
    customers c ON o.customer_id = c.customer_id
JOIN 
    customer_segments cs ON c.age BETWEEN cs.min_age AND cs.max_age
JOIN 
    sales_channels s ON o.sales_channel = s.sales_channel
WHERE 
    o.sales_amount >= 100000 AND s.customer_count >= 100
GROUP BY 
    s.sales_channel, cs.segment, p.description
HAVING 
    SUM(o.sales_amount) > 100000;
------------------
**Develop a predictive model to forecast the daily sales of a retail store based on historical sales data, weather conditions, and marketing campaigns, considering only days with sales above $5,000 and taking into account the impact of holidays and special events.**
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"},
            {"name": "holiday", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "weather",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(5, 2)"},
            {"name": "precipitation", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "marketing",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "budget", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "special_events",
        "columns": [
            {"name": "event_name", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    s.date, 
    s.sales_amount, 
    w.temperature, 
    w.precipitation, 
    m.campaign_name, 
    m.budget, 
    se.event_name
FROM 
    sales s
JOIN 
    weather w ON s.date = w.date
JOIN 
    marketing m ON s.date = m.date
LEFT JOIN 
    special_events se ON s.date = se.date AND se.event_name IN ('Event1', 'Event2')
WHERE 
    s.sales_amount > 5000 AND s.holiday = 0
ORDER BY 
    s.date
------------------
**Identify the top 5 countries with the highest average revenue per user (ARPU) in the e-commerce industry, considering only countries with at least 10,000 customers and a total revenue of over $1 billion.**
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "description", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "countries",
        "columns": [
            {"name": "country", "type": "VARCHAR(50)"},
            {"name": "customer_count", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.country, AVG(o.sales_amount) AS arpu
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
JOIN countries co ON c.country = co.country
GROUP BY c.country
HAVING COUNT(c.customer_id) >= 10000 AND SUM(o.sales_amount) > 1000000000
ORDER BY arpu DESC
LIMIT 5;
------------------
**Develop a data warehouse schema to support a business intelligence application for a healthcare organization, including patient demographics, medical claims, and treatment outcomes.**
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "dob", "type": "DATE"},
            {"name": "gender", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "claims",
        "columns": [
            {"name": "claim_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "claim_date", "type": "DATE"},
            {"name": "claim_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "treatments",
        "columns": [
            {"name": "treatment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "claim_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES claims(claim_id)"]},
            {"name": "treatment_name", "type": "VARCHAR(255)"},
            {"name": "treatment_date", "type": "DATE"}
        ]
    },
    {
        "name": "outcomes",
        "columns": [
            {"name": "outcome_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "outcome_date", "type": "DATE"},
            {"name": "outcome_status", "type": "VARCHAR(20)"}
        ]
    }
]
Response:
CREATE TABLE patients (
  patient_id INT PRIMARY KEY,
  name TEXT,
  dob DATE,
  gender TEXT
);

CREATE TABLE claims (
  claim_id INT PRIMARY KEY,
  patient_id INT,
  claim_date DATE,
  claim_amount DECIMAL(10, 2),
  FOREIGN KEY (patient_id) REFERENCES patients(patient_id)
);

CREATE TABLE treatments (
  treatment_id INT PRIMARY KEY,
  claim_id INT,
  treatment_name TEXT,
  treatment_date DATE,
  FOREIGN KEY (claim_id) REFERENCES claims(claim_id)
);

CREATE TABLE outcomes (
  outcome_id INT PRIMARY KEY,
  patient_id INT,
  outcome_date DATE,
  outcome_status TEXT,
  FOREIGN KEY (patient_id) REFERENCES patients(patient_id)
);

CREATE INDEX idx_claims_patient_id ON claims (patient_id);
CREATE INDEX idx_treatments_claim_id ON treatments (claim_id);
CREATE INDEX idx_outcomes_patient_id ON outcomes (patient_id);

SELECT 
  p.patient_id,
  p.name,
  c.claim_id,
  c.claim_date,
  t.treatment_name,
  t.treatment_date,
  o.outcome_id,
  o.outcome_date,
  o.outcome_status
FROM 
  patients p
  LEFT JOIN claims c ON p.patient_id = c.patient_id
  LEFT JOIN treatments t ON c.claim_id = t.claim_id
  LEFT JOIN outcomes o ON p.patient_id = o.patient_id;
------------------
**Develop a data mart schema to support a sales forecasting application for a retail organization, including product sales data, customer purchase history, and store sales performance.**
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "description", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "purchase_history", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
CREATE TABLE sales_forecast_data (
    product_id INT,
    customer_id INT,
    store_id INT,
    sales_amount DECIMAL(10, 2),
    order_date DATE
);

INSERT INTO sales_forecast_data
SELECT 
    o.product_id,
    o.customer_id,
    o.sales_amount,
    o.order_date,
    s.store_id
FROM 
    orders o
JOIN 
    stores s ON o.sales_amount > (SELECT AVG(sales_amount) FROM stores)
WHERE 
    o.order_date BETWEEN '2020-01-01' AND '2020-12-31';

CREATE INDEX idx_sales_forecast_data_product_id ON sales_forecast_data(product_id);
CREATE INDEX idx_sales_forecast_data_customer_id ON sales_forecast_data(customer_id);
CREATE INDEX idx_sales_forecast_data_store_id ON sales_forecast_data(store_id);
CREATE INDEX idx_sales_forecast_data_order_date ON sales_forecast_data(order_date);
------------------
**Develop a data warehouse schema to support a financial reporting application for a banking organization, including account transactions, customer demographics, and loan information.**
Schema:
[
    {
        "name": "accounts",
        "columns": [
            {"name": "account_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "account_type", "type": "VARCHAR(20)"},
            {"name": "balance", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES accounts(account_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "transaction_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "loans",
        "columns": [
            {"name": "loan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "loan_amount", "type": "DECIMAL(10, 2)"},
            {"name": "loan_date", "type": "DATE"}
        ]
    }
]
Response:
CREATE TABLE customers (
    customer_id INT PRIMARY KEY,
    name VARCHAR(255),
    email VARCHAR(255),
    address VARCHAR(255)
);

CREATE TABLE accounts (
    account_id INT PRIMARY KEY,
    customer_id INT,
    account_type VARCHAR(20),
    balance DECIMAL(10, 2),
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE TABLE transactions (
    transaction_id INT PRIMARY KEY,
    account_id INT,
    transaction_date DATE,
    transaction_amount DECIMAL(10, 2),
    FOREIGN KEY (account_id) REFERENCES accounts(account_id)
);

CREATE TABLE loans (
    loan_id INT PRIMARY KEY,
    customer_id INT,
    loan_amount DECIMAL(10, 2),
    loan_date DATE,
    FOREIGN KEY (customer_id) REFERENCES customers(customer_id)
);

CREATE INDEX idx_customer_id ON accounts (customer_id);
CREATE INDEX idx_account_id ON transactions (account_id);
CREATE INDEX idx_customer_id ON loans (customer_id);

CREATE VIEW customer_account_info AS
SELECT c.customer_id, c.name, a.account_id, a.account_type, a.balance
FROM customers c
JOIN accounts a ON c.customer_id = a.customer_id;

CREATE VIEW account_transaction_info AS
SELECT a.account_id, a.account_type, t.transaction_date, t.transaction_amount
FROM accounts a
JOIN transactions t ON a.account_id = t.account_id;

CREATE VIEW customer_loan_info AS
SELECT c.customer_id, c.name, l.loan_amount, l.loan_date
FROM customers c
JOIN loans l ON c.customer_id = l.customer_id;
------------------
**Analyze the sales performance of products across different sales channels (in-store, online, and mobile app) and customer segments (age, income, and location) in the retail industry, considering only products with at least $100,000 in sales and a sales channel that has at least 100 customers.**
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"},
            {"name": "location", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sales_channel", "type": "VARCHAR(20)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "description", "type": "VARCHAR(255)"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_channels",
        "columns": [
            {"name": "sales_channel", "type": "VARCHAR(20)"},
            {"name": "customer_count", "type": "INT"}
        ]
    },
    {
        "name": "customer_segments",
        "columns": [
            {"name": "segment", "type": "VARCHAR(20)"},
            {"name": "customer_count", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  sc.sales_channel, 
  cs.segment, 
  p.description, 
  SUM(o.sales_amount) AS total_sales, 
  COUNT(DISTINCT o.customer_id) AS customer_count
FROM 
  orders o
  INNER JOIN products p ON o.product_id = p.product_id
  INNER JOIN customers c ON o.customer_id = c.customer_id
  INNER JOIN sales_channels sc ON o.sales_channel = sc.sales_channel
  INNER JOIN customer_segments cs ON c.age BETWEEN cs.segment = 'age' AND c.income BETWEEN cs.segment = 'income' AND c.location BETWEEN cs.segment = 'location'
WHERE 
  p.sales_amount >= 100000 
  AND sc.customer_count >= 100
GROUP BY 
  sc.sales_channel, 
  cs.segment, 
  p.description
------------------
**Develop a predictive model to forecast the daily sales of a retail store based on historical sales data, weather conditions, and marketing campaigns, considering only days with sales above $5,000 and taking into account the impact of holidays and special events.**
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"},
            {"name": "holiday", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "weather",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(5, 2)"},
            {"name": "precipitation", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "marketing",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "budget", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "special_events",
        "columns": [
            {"name": "event_name", "type": "VARCHAR(255)"},
            {"name": "date", "type": "DATE"}
        ]
    }
]
Response:
SELECT SUM(s.sales_amount) AS total_sales
FROM sales s
JOIN weather w ON s.date = w.date
JOIN marketing m ON s.date = m.date
JOIN special_events se ON s.date = se.date
WHERE s.sales_amount > 5000
AND s.holiday = 1
AND m.budget > 1000
AND se.event_name IN ('Event A', 'Event B');

-- To include all dates with sales above $5,000, replace the join with subqueries
SELECT SUM(sales_amount) AS total_sales
FROM (
  SELECT s.sales_amount
  FROM sales s
  JOIN weather w ON s.date = w.date
  JOIN marketing m ON s.date = m.date
  JOIN special_events se ON s.date = se.date
  WHERE s.sales_amount > 5000
  AND s.holiday = 1
  AND m.budget > 1000
  AND se.event_name IN ('Event A', 'Event B')
) AS subquery;
------------------
Analyze customer churn in the banking industry.

Develop a SQL query to identify the top 5 branches with the highest customer churn rates, considering customers who have closed their accounts within the last 6 months. The query should also include the average balance of these customers before account closure and the total number of customers who have churned from each branch.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "branch_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES branches(branch_id)"]}
        ]
    },
    {
        "name": "branches",
        "columns": [
            {"name": "branch_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "branch_name", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "account_transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "balance", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "account_closures",
        "columns": [
            {"name": "closure_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "closure_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  b.branch_name, 
  COUNT(c.customer_id) AS total_churned_customers, 
  AVG(at.balance) AS avg_balance_before_closure, 
  COUNT(DISTINCT c.customer_id) AS branch_customers
FROM 
  customers c
  JOIN account_closures ac ON c.customer_id = ac.customer_id
  JOIN account_transactions at ON c.customer_id = at.customer_id AND at.transaction_date < ac.closure_date
  JOIN branches b ON c.branch_id = b.branch_id
WHERE 
  ac.closure_date > DATE('now', '-6 months')
GROUP BY 
  b.branch_name
ORDER BY 
  total_churned_customers DESC
LIMIT 5;
------------------
Identify top-performing sales representatives in the e-commerce industry.

Develop a SQL query to find the sales representatives who have exceeded their target sales amount by more than 10% within the last quarter. The query should also include the sales representative's name, the total sales amount, and the percentage of sales exceeded.
Schema:
[
    {
        "name": "sales_representatives",
        "columns": [
            {"name": "representative_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "representative_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_representatives(representative_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales_targets",
        "columns": [
            {"name": "target_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "representative_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_representatives(representative_id)"]},
            {"name": "target_amount", "type": "DECIMAL(10, 2)"},
            {"name": "target_quarter", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
  s.name, 
  SUM(o.total_amount) AS total_sales, 
  (SUM(o.total_amount) - st.target_amount) * 100 / st.target_amount AS percentage_exceeded
FROM 
  sales_representatives s
  JOIN orders o ON s.representative_id = o.representative_id
  JOIN sales_targets st ON s.representative_id = st.representative_id AND DATE(o.order_date) >= DATE trhun(st.target_quarter)
WHERE 
  o.order_date >= DATE('2022-10-01') AND o.order_date <= DATE('2022-12-31')
  AND (SUM(o.total_amount) - st.target_amount) * 100 / st.target_amount > 10
GROUP BY 
  s.name, st.target_amount, st.target_quarter
HAVING 
  SUM(o.total_amount) - st.target_amount > 0
------------------
Analyze inventory management in the retail industry.

Develop a SQL query to find the top 3 product categories with the highest total inventory value within the last month. The query should also include the category name, the total inventory value, and the average stock level.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES categories(category_id)"]},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "categories",
        "columns": [
            {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.category_name, 
       SUM(i.value) as total_inventory_value, 
       AVG(i.quantity) as average_stock_level
FROM products p
JOIN categories c ON p.category_id = c.category_id
JOIN inventory i ON p.product_id = i.product_id
WHERE i.store_id IN (SELECT store_id FROM stores)
  AND i.inventory_date >= DATE('now', '-1 month')
GROUP BY c.category_name
ORDER BY total_inventory_value DESC
LIMIT 3
------------------
Identify the most profitable marketing campaigns in the technology industry.

Develop a SQL query to find the top 3 marketing campaigns with the highest total revenue within the last year. The query should also include the campaign name, the total revenue, and the return on investment (ROI) percentage.
Schema:
[
    {
        "name": "marketing_campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "campaign_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES marketing_campaigns(campaign_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  mc.campaign_name, 
  SUM(o.total_amount) AS total_revenue, 
  ROUND((SUM(o.total_amount) / mc.budget) * 100, 2) AS roi_percentage
FROM 
  marketing_campaigns mc
  JOIN orders o ON mc.campaign_id = o.campaign_id
WHERE 
  o.order_date BETWEEN DATE('now', '-1 year') AND DATE('now')
GROUP BY 
  mc.campaign_name
ORDER BY 
  total_revenue DESC
LIMIT 3
------------------
Analyze patient outcomes in the healthcare industry.

Develop a SQL query to find the top 3 medical procedures with the highest average cost within the last quarter. The query should also include the procedure name, the average cost, and the total number of procedures.
Schema:
[
    {
        "name": "medical_procedures",
        "columns": [
            {"name": "procedure_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "procedure_name", "type": "VARCHAR(255)"},
            {"name": "procedure_description", "type": "TEXT"}
        ]
    },
    {
        "name": "patient_data",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "date_of_birth", "type": "DATE"}
        ]
    },
    {
        "name": "claims",
        "columns": [
            {"name": "claim_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patient_data(patient_id)"]},
            {"name": "procedure_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES medical_procedures(procedure_id)"]},
            {"name": "claim_date", "type": "DATE"},
            {"name": "cost", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    mp.procedure_name, 
    AVG(c.cost) AS avg_cost, 
    COUNT(c.claim_id) AS total_procedures
FROM 
    claims c
JOIN 
    medical_procedures mp ON c.procedure_id = mp.procedure_id
WHERE 
    c.claim_date BETWEEN (CURRENT_DATE - INTERVAL 3 MONTH) AND CURRENT_DATE
GROUP BY 
    mp.procedure_name
ORDER BY 
    avg_cost DESC
LIMIT 3
------------------
Analyze employee productivity in the education industry.

Develop a SQL query to find the top 5 employees with the highest average rating within the last semester. The query should also include the employee name, the average rating, and the total number of ratings.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "student_ratings",
        "columns": [
            {"name": "rating_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "rating_date", "type": "DATE"},
            {"name": "rating", "type": "INT"}
        ]
    },
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "date_of_birth", "type": "DATE"}
        ]
    }
]
Response:
SELECT e.name, AVG(r.rating) as avg_rating, COUNT(r.rating_id) as total_ratings
FROM employees e
JOIN student_ratings r ON e.employee_id = r.employee_id
WHERE r.rating_date >= DATE('now', '-6 months')
GROUP BY e.employee_id, e.name
ORDER BY avg_rating DESC
LIMIT 5;
------------------
**Analyzing Customer Churn and Predicting Future Behavior**

A retail company wants to identify the most critical factors that contribute to customer churn. They need to analyze customer behavior, purchase history, and demographic information to predict which customers are likely to churn in the next 6 months.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(1)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "returns",
        "columns": [
            {"name": "return_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "return_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "churned_customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "churn_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.age, c.gender, c.country 
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id 
WHERE o.order_date < CURRENT_DATE - INTERVAL 6 MONTH AND o.order_id NOT IN (SELECT r.order_id FROM returns r)
------------------
**Optimizing Inventory Management through Demand Forecasting**

A fashion e-commerce company wants to optimize their inventory management by predicting demand for different products based on historical sales data, seasonality, and external factors such as weather and holidays.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "weather_data",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(10, 2)"},
            {"name": "rainfall", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "holidays",
        "columns": [
            {"name": "holiday_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "demand_forecasts",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "forecast_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_id, p.product_name, p.category, o.order_date, o.quantity, 
       w.temperature, w.rainfall, w.date AS weather_date, h.date AS holiday_date
FROM products p
JOIN orders o ON p.product_id = o.product_id
JOIN weather_data w ON o.order_date = w.date
JOIN holidays h ON o.order_date = h.date
WHERE w.temperature > (SELECT AVG(temperature) FROM weather_data)
AND w.rainfall < (SELECT AVG(rainfall) FROM weather_data)
AND h.description LIKE '%Christmas%'
------------------
**Analyzing Employee Performance and Salary Disparities**

A company wants to analyze employee performance and identify potential salary disparities based on job title, department, and location.
Schema:
[
    {
        "name": "employees",
        "columns": [
            {"name": "employee_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "job_title", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "salaries",
        "columns": [
            {"name": "salary_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "salary", "type": "DECIMAL(10, 2)"},
            {"name": "year", "type": "INT"}
        ]
    },
    {
        "name": "performance_reviews",
        "columns": [
            {"name": "review_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "employee_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES employees(employee_id)"]},
            {"name": "review_date", "type": "DATE"},
            {"name": "rating", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT e.employee_id, e.name, e.job_title, e.department, e.location, s.salary, pr.rating 
FROM employees e 
JOIN salaries s ON e.employee_id = s.employee_id 
JOIN performance_reviews pr ON e.employee_id = pr.employee_id 
WHERE s.year = (SELECT MAX(year) FROM salaries);
------------------
**Identifying High-Value Customers through Purchase History and Demographics**

A retail company wants to identify high-value customers by analyzing their purchase history, demographic information, and loyalty program participation.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(1)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "loyalty_programs",
        "columns": [
            {"name": "program_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "program_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "high_value_customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "total_spent", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, SUM(o.quantity * p.price) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN products p ON o.product_id = p.product_id
WHERE c.age > 18
AND c.gender = 'M'
AND c.country IN ('USA', 'Canada')
AND o.order_date >= DATE('2020-01-01')
AND o.order_date <= DATE('2022-12-31')
GROUP BY c.customer_id
HAVING SUM(o.quantity * p.price) > 1000
ORDER BY total_spent DESC;
------------------
**Analyzing Website Traffic and Conversion Rates**

A company wants to analyze website traffic, bounce rates, and conversion rates to understand user behavior and optimize their website.
Schema:
[
    {
        "name": "website_traffic",
        "columns": [
            {"name": "traffic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "page_views", "type": "INT"},
            {"name": "bounce_rate", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "conversions",
        "columns": [
            {"name": "conversion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "conversion_type", "type": "VARCHAR(255)"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "user_behavior",
        "columns": [
            {"name": "behavior_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "user_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES users(user_id)"]},
            {"name": "behavior_type", "type": "VARCHAR(255)"},
            {"name": "timestamp", "type": "TIMESTAMP"}
        ]
    },
    {
        "name": "users",
        "columns": [
            {"name": "user_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  wt.date, 
  wt.page_views, 
  wt.bounce_rate, 
  c.conversion_type, 
  c.revenue
FROM 
  website_traffic wt
  LEFT JOIN conversions c ON wt.date = c.date
WHERE 
  wt.bounce_rate > 0.4
ORDER BY 
  wt.page_views DESC;
------------------
**Predicting Stock Prices using Historical Data**

A company wants to predict stock prices using historical data, including technical indicators and economic news.
Schema:
[
    {
        "name": "stocks",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "symbol", "type": "VARCHAR(255)"},
            {"name": "name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "historical_data",
        "columns": [
            {"name": "data_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "open", "type": "DECIMAL(10, 2)"},
            {"name": "high", "type": "DECIMAL(10, 2)"},
            {"name": "low", "type": "DECIMAL(10, 2)"},
            {"name": "close", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "technical_indicators",
        "columns": [
            {"name": "indicator_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "stock_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stocks(stock_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "indicator_name", "type": "VARCHAR(255)"},
            {"name": "value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "economic_news",
        "columns": [
            {"name": "news_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "date", "type": "DATE"},
            {"name": "news_text", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    h.stock_id,
    h.date,
    h.open,
    h.close,
    COALESCE(ti.value, 0) AS moving_average,
    en.news_text
FROM 
    historical_data h
LEFT JOIN 
    technical_indicators ti ON h.stock_id = ti.stock_id AND h.date = ti.date AND ti.indicator_name = 'Moving Average'
LEFT JOIN 
    economic_news en ON h.date = en.date
WHERE 
    h.stock_id = 1
ORDER BY 
    h.date DESC
------------------
**Analyze Sales Performance by Region and Product Category**
Develop a SQL query to calculate the total sales revenue for each region and product category, while also identifying the top-performing products in each region. The query should handle missing data and provide a clear understanding of sales performance across different regions and product categories.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(100)"},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(100)"},
            {"name": "region_description", "type": "TEXT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "TEXT"},
            {"name": "product_category", "type": "VARCHAR(100)"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    pc.product_category, 
    SUM(s.sale_amount) AS total_sales, 
    ROW_NUMBER() OVER (PARTITION BY r.region_name ORDER BY SUM(s.sale_amount) DESC) AS rank
FROM 
    sales s
JOIN 
    regions r ON s.region = r.region_name
JOIN 
    products p ON s.product_name = p.product_name
GROUP BY 
    r.region_name, 
    pc.product_category
ORDER BY 
    r.region_name, 
    pc.product_category, 
    rank
------------------
**Identify High-Risk Customers for Churn Prevention**
Develop a SQL query to identify customers who are at high risk of churning based on their purchase history, order frequency, and average order value. The query should use a combination of subqueries, window functions, and conditional logic to provide a clear understanding of customer churn risk.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone_number", "type": "VARCHAR(20)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "TEXT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, 
       (SELECT COUNT(*) 
        FROM orders o 
        WHERE o.customer_id = c.customer_id) AS order_frequency, 
       (SELECT AVG(o.order_amount) 
        FROM orders o 
        WHERE o.customer_id = c.customer_id) AS avg_order_value, 
       (SELECT COUNT(*) 
        FROM orders o 
        WHERE o.customer_id = c.customer_id AND 
              o.order_date < (CURRENT_DATE - 90) AND 
              o.order_amount < (SELECT AVG(o2.order_amount) 
                                  FROM orders o2 
                                  WHERE o2.customer_id = c.customer_id)) AS recent_orders_count, 
       (SELECT COUNT(*) 
        FROM orders o 
        WHERE o.customer_id = c.customer_id AND 
              o.order_date < (CURRENT_DATE - 90) AND 
              o.order_amount < (SELECT AVG(o2.order_amount) 
                                  FROM orders o2 
                                  WHERE o2.customer_id = c.customer_id)) / 
        (SELECT COUNT(*) 
         FROM orders o 
         WHERE o.customer_id = c.customer_id) AS churn_risk_score
FROM customers c;
------------------
**Analyze Time-Series Sales Data with Seasonality**
Develop a SQL query to analyze the sales data for a specific product over a period of 12 months, taking into account the seasonality of sales. The query should use window functions and CTEs to provide insights into sales patterns, peak months, and average sales per month.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "TEXT"}
        ]
    }
]
Response:
WITH sales_cte AS (
  SELECT 
    product_id,
    EXTRACT(YEAR FROM sale_date) AS sale_year,
    EXTRACT(MONTH FROM sale_date) AS sale_month,
    SUM(sale_amount) AS total_sales
  FROM sales
  GROUP BY product_id, EXTRACT(YEAR FROM sale_date), EXTRACT(MONTH FROM sale_date)
),
peak_month_cte AS (
  SELECT 
    product_id,
    sale_month,
    SUM(total_sales) AS total_sales,
    ROW_NUMBER() OVER (PARTITION BY product_id ORDER BY SUM(total_sales) DESC) AS sales_rank
  FROM sales_cte
  GROUP BY product_id, sale_month
),
avg_sales_cte AS (
  SELECT 
    product_id,
    sale_month,
    AVG(total_sales) AS avg_sales
  FROM sales_cte
  GROUP BY product_id, sale_month
)
SELECT 
  p.product_name,
  sm.sale_year,
  sm.sale_month,
  sm.total_sales,
  pm.total_sales AS peak_sales,
  pm.sales_rank AS peak_rank,
  asa.avg_sales
FROM products p
JOIN sales_cte sm ON p.product_id = sm.product_id
JOIN peak_month_cte pm ON p.product_id = pm.product_id AND sm.sale_month = pm.sale_month
JOIN avg_sales_cte asa ON p.product_id = asa.product_id AND sm.sale_month = asa.sale_month;
------------------
**Reconcile Invoicing and Payment Data**
Develop a SQL query to reconcile the invoicing and payment data for a specific customer, ensuring that the total amount invoiced matches the total amount paid. The query should handle missing data, null values, and provide a clear understanding of any discrepancies.
Schema:
[
    {
        "name": "invoices",
        "columns": [
            {"name": "invoice_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "invoice_date", "type": "DATE"},
            {"name": "invoice_amount", "type": "DECIMAL(10,2)"},
            {"name": "invoice_status", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "payment_amount", "type": "DECIMAL(10,2)"},
            {"name": "payment_status", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  SUM(i.invoice_amount) AS total_invoiced, 
  SUM(p.payment_amount) AS total_paid, 
  (SUM(i.invoice_amount) - SUM(p.payment_amount)) AS discrepancy
FROM 
  invoices i
  JOIN customers c ON i.customer_id = c.customer_id
  LEFT JOIN payments p ON i.customer_id = p.customer_id
GROUP BY 
  c.customer_id
HAVING 
  SUM(i.invoice_amount) - SUM(p.payment_amount) != 0;
------------------
**Analyzing Customer Churn and Predicting Future Churn in the Telecommunications Industry**

A telecommunications company wants to understand the reasons behind customer churn and predict which customers are likely to churn in the future. They have provided the following database schema, which includes information about customers, their subscription plans, payment history, and account details.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "plan_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES plans(plan_id)"]}
        ]
    },
    {
        "name": "plans",
        "columns": [
            {"name": "plan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10,2)"},
            {"name": "data_limit", "type": "INT"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10,2)"},
            {"name": "is_on_time", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "account_details",
        "columns": [
            {"name": "account_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "device_type", "type": "VARCHAR(255)"},
            {"name": "device_id", "type": "VARCHAR(255)"},
            {"name": "last_active_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, p.name AS plan_name, COUNT(p.payment_id) AS num_payments, SUM(p.amount) AS total_spent, AVG(p.amount) AS avg_spent, MAX(p.payment_date) AS last_payment_date, a.last_active_date 
FROM customers c 
JOIN payments p ON c.customer_id = p.customer_id 
JOIN account_details a ON c.customer_id = a.customer_id 
JOIN plans pl ON c.plan_id = pl.plan_id 
WHERE c.status = 'active' AND a.last_active_date >= DATE('now', '-1 year') 
GROUP BY c.customer_id, c.name, p.name, p.payment_id, a.last_active_date
------------------
**Identifying High-Risk Patients and Predicting Hospital Readmissions in the Healthcare Industry**

A hospital wants to identify high-risk patients who are likely to be readmitted within 30 days of discharge and predict the likelihood of readmission for each patient. They have provided the following database schema, which includes information about patients, diagnoses, treatments, and hospital stays.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "dob", "type": "DATE"},
            {"name": "insurance_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES insurances(insurance_id)"]}
        ]
    },
    {
        "name": "diagnoses",
        "columns": [
            {"name": "diagnosis_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "diagnosis_code", "type": "VARCHAR(255)"},
            {"name": " diagnosis_date", "type": "DATE"}
        ]
    },
    {
        "name": "treatments",
        "columns": [
            {"name": "treatment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "diagnosis_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES diagnoses(diagnosis_id)"]},
            {"name": "treatment_name", "type": "VARCHAR(255)"},
            {"name": "treatment_date", "type": "DATE"}
        ]
    },
    {
        "name": "hospital_stays",
        "columns": [
            {"name": "stay_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "admission_date", "type": "DATE"},
            {"name": "discharge_date", "type": "DATE"},
            {"name": "readmitted", "type": "BOOLEAN"}
        ]
    },
    {
        "name": "insurances",
        "columns": [
            {"name": "insurance_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "insurance_name", "type": "VARCHAR(255)"},
            {"name": "premium", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT p.patient_id, p.name, p.dob, h.readmitted 
FROM patients p 
JOIN hospital_stays h ON p.patient_id = h.patient_id 
JOIN ( 
  SELECT patient_id, COUNT(*) as num_diagnoses 
  FROM diagnoses 
  GROUP BY patient_id 
  HAVING COUNT(*) > 3 
) d ON p.patient_id = d.patient_id 
WHERE h.discharge_date > DATE('now', '-30 days')
------------------
**Analyze Customer Churn and Predictive Modeling**

Develop a SQL query to identify customers who are at high risk of churning in the next 3 months, based on their historical purchase behavior and demographic information. The query should also provide insights into the top 3 products that contribute to customer churn.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT"},
            {"name": "amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "churn_data",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.age, c.location, o.order_date, p.product_name, ch.churn_date, ch.reason
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN products p ON o.product_id = p.product_id
JOIN churn_data ch ON c.customer_id = ch.customer_id
WHERE o.order_date BETWEEN DATE('now', '-3 months') AND DATE('now')
AND ch.churn_date IS NULL
GROUP BY c.customer_id
HAVING COUNT(DISTINCT o.order_id) <= 2
ORDER BY COUNT(DISTINCT o.order_id) DESC
LIMIT 1000

SELECT p.product_name, COUNT(c.customer_id) as churn_count
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN products p ON o.product_id = p.product_id
JOIN churn_data ch ON c.customer_id = ch.customer_id
WHERE o.order_date BETWEEN DATE('now', '-3 months') AND DATE('now')
AND ch.churn_date IS NULL
GROUP BY p.product_name
ORDER BY churn_count DESC
LIMIT 3
------------------
**Optimize Inventory Management and Supply Chain**

Develop a SQL query to identify the top 5 products with the highest inventory turnover rate, excluding products with a turnover rate of less than 2 times per year. The query should also provide insights into the average lead time and stock levels for these products.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "stock_level", "type": "INT"},
            {"name": "lead_time", "type": "DATE"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, i.stock_level, i.lead_time, 
       (COUNT(o.order_id) + COUNT(s.sale_id)) AS total_sales, 
       (COUNT(o.order_id) + COUNT(s.sale_id)) / 
       (SELECT AVG(lead_time) FROM inventory) AS inventory_turnover_rate
FROM products p
JOIN inventory i ON p.product_id = i.product_id
LEFT JOIN orders o ON p.product_id = o.product_id
LEFT JOIN sales s ON p.product_id = s.product_id
WHERE (COUNT(o.order_id) + COUNT(s.sale_id)) / 
      (SELECT AVG(lead_time) FROM inventory) > 2
GROUP BY p.product_name, i.stock_level, i.lead_time
ORDER BY inventory_turnover_rate DESC
LIMIT 5;
------------------
**Analyze Financial Performance and Identify Areas for Improvement**

Develop a SQL query to calculate the total revenue and net income for each region, as well as the top 5 products contributing to revenue by region. The query should also provide insights into the top 3 customers with the highest revenue contribution.
Schema:
[
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT"},
            {"name": "amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  r.region_name,
  SUM(o.amount) AS total_revenue,
  SUM(o.amount * p.category_code) AS net_income,
  p.product_name,
  SUM(o.amount) AS product_revenue
FROM 
  orders o
  JOIN customers c ON o.customer_id = c.customer_id
  JOIN regions r ON c.region_id = r.region_id
  JOIN products p ON o.product_id = p.product_id
  JOIN (SELECT 
          product_id,
          category,
          ROW_NUMBER() OVER(PARTITION BY category ORDER BY SUM(amount) DESC) AS category_rank
        FROM 
          orders
        GROUP BY 
          product_id, category
        ) p_sub ON p.product_id = p_sub.product_id
WHERE 
  p_sub.category_rank <= 5
GROUP BY 
  r.region_name, p.product_name
ORDER BY 
  r.region_name, p.product_name

SELECT 
  c.name AS customer_name,
  c.revenue,
  c.region_id 
FROM 
  customers c
ORDER BY 
  c.revenue DESC 
LIMIT 3
------------------
**Predict Student Performance and Identify Learning Gaps**

Develop a SQL query to identify students who are at risk of failing a course based on their historical academic performance, as well as the top 3 topics with the lowest performance average. The query should also provide insights into the average score and standard deviation for each student across all courses.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "topic", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "score", "type": "DECIMAL(3,2)"}
        ]
    }
]
Response:
SELECT 
    s.student_id, 
    s.name, 
    AVG(g.score) AS avg_score, 
    STDDEV(g.score) AS std_dev, 
    COUNT(g.score) AS total_courses, 
    CASE 
        WHEN AVG(g.score) < 60 THEN 'At risk' 
        ELSE 'Not at risk' 
    END AS risk_status 
FROM 
    grades g 
JOIN 
    students s ON g.student_id = s.student_id 
GROUP BY 
    s.student_id, s.name 
HAVING 
    AVG(g.score) < 60 

UNION ALL

SELECT 
    'top_3_topics' AS topic, 
    topic AS topic_name, 
    AVG(g.score) AS avg_score 
FROM 
    grades g 
JOIN 
    courses c ON g.course_id = c.course_id 
GROUP BY 
    topic 
ORDER BY 
    avg_score 
LIMIT 3
------------------
**Analyze Sales Performance and Identify Trends**

Develop a SQL query to calculate the total sales revenue and quantity for each product category across different regions, as well as the top 3 products with the highest sales growth rate. The query should also provide insights into the average sales price and discount rate for each product category.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "amount", "type": "DECIMAL(10,2)"},
            {"name": "discount_rate", "type": "DECIMAL(3,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  p.category, 
  r.region_name, 
  SUM(s.amount) AS total_sales, 
  SUM(s.quantity) AS total_quantity, 
  AVG(s.amount) AS avg_sales_price, 
  AVG(s.discount_rate) AS avg_discount_rate
FROM 
  sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN regions r ON s.region_id = r.region_id
GROUP BY 
  p.category, 
  r.region_name
ORDER BY 
  p.category, 
  r.region_name

UNION ALL

SELECT 
  p.category, 
  NULL AS region_name, 
  SUM(s.amount) AS total_sales, 
  SUM(s.quantity) AS total_quantity, 
  AVG(s.amount) AS avg_sales_price, 
  AVG(s.discount_rate) AS avg_discount_rate
FROM 
  sales s
  JOIN products p ON s.product_id = p.product_id
GROUP BY 
  p.category
ORDER BY 
  p.category

UNION ALL

SELECT 
  p.product_name, 
  NULL AS category, 
  NULL AS region_name, 
  NULL AS total_sales, 
  NULL AS total_quantity, 
  NULL AS avg_sales_price, 
  NULL AS avg_discount_rate, 
  (s.amount - s.amount * s.discount_rate / 100) / s.quantity AS sales_growth_rate
FROM 
  sales s
  JOIN products p ON s.product_id = p.product_id
GROUP BY 
  p.product_name
ORDER BY 
  sales_growth_rate DESC
LIMIT 3
------------------
Analyze the sales performance of a retail company by identifying the top-performing products, sales channels, and regions, while considering the impact of promotions and seasonal fluctuations.
Schema:
[
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_name", "type": "VARCHAR(255)"},
      {"name": "category", "type": "VARCHAR(255)"},
      {"name": "price", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "orders",
    "columns": [
      {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "order_date", "type": "DATE"},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
      {"name": "channel", "type": "VARCHAR(255)"},
      {"name": "region", "type": "VARCHAR(255)"},
      {"name": "promotion", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "sales",
    "columns": [
      {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
      {"name": "sale_amount", "type": "DECIMAL(10, 2)"},
      {"name": "sale_date", "type": "DATE"}
    ]
  },
  {
    "name": "promotions",
    "columns": [
      {"name": "promotion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "promotion_name", "type": "VARCHAR(255)"},
      {"name": "start_date", "type": "DATE"},
      {"name": "end_date", "type": "DATE"}
    ]
  }
]
Response:
SELECT 
    p.product_name, 
    o.channel, 
    o.region, 
    SUM(s.sale_amount) AS total_sales, 
    SUM(CASE WHEN o.promotion IS NOT NULL THEN s.sale_amount ELSE 0 END) AS total_promo_sales, 
    SUM(CASE WHEN o.promotion IS NULL THEN s.sale_amount ELSE 0 END) AS total_non_promo_sales
FROM 
    orders o
JOIN 
    sales s ON o.order_id = s.order_id
JOIN 
    products p ON o.product_id = p.product_id
GROUP BY 
    p.product_name, 
    o.channel, 
    o.region
ORDER BY 
    total_sales DESC
------------------
Forecast the demand for a hospital's emergency department by analyzing historical patient arrival data, considering the impact of seasonal fluctuations, day of the week, and hour of the day.
Schema:
[
  {
    "name": "patients",
    "columns": [
      {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "arrival_date", "type": "DATE"},
      {"name": "arrival_time", "type": "TIME"}
    ]
  },
  {
    "name": "departments",
    "columns": [
      {"name": "department_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "department_name", "type": "VARCHAR(255)"},
      {"name": "capacity", "type": "INT"}
    ]
  },
  {
    "name": "arrival_patterns",
    "columns": [
      {"name": "pattern_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "pattern_name", "type": "VARCHAR(255)"},
      {"name": "day_of_week", "type": "VARCHAR(255)"},
      {"name": "hour_of_day", "type": "INT"}
    ]
  },
  {
    "name": "seasonality",
    "columns": [
      {"name": "season_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "season_name", "type": "VARCHAR(255)"},
      {"name": "start_date", "type": "DATE"},
      {"name": "end_date", "type": "DATE"}
    ]
  }
]
Response:
SELECT 
    A.arrival_date,
    A.arrival_time,
    A.departments_id,
    A.seasonality_id,
    A.day_of_week,
    A.hour_of_day,
    SUM(CASE WHEN A.seasonality_id = S.season_id THEN 1 ELSE 0 END) OVER (PARTITION BY A.arrival_date, A.arrival_time, A.departments_id) AS total_arrivals,
    SUM(CASE WHEN A.seasonality_id = S.season_id THEN 1 ELSE 0 END) OVER (PARTITION BY A.day_of_week, A.hour_of_day) AS total_arrivals_by_day_hour,
    AVG(CASE WHEN A.seasonality_id = S.season_id THEN 1 ELSE 0 END) OVER (PARTITION BY A.arrival_date, A.arrival_time, A.departments_id) AS avg_arrivals,
    AVG(CASE WHEN A.seasonality_id = S.season_id THEN 1 ELSE 0 END) OVER (PARTITION BY A.day_of_week, A.hour_of_day) AS avg_arrivals_by_day_hour
FROM 
    (SELECT 
         P.arrival_date,
         P.arrival_time,
         D.department_id AS departments_id,
         S.season_id,
         A.day_of_week,
         A.hour_of_day
     FROM 
         patients P
     JOIN 
         departments D ON P.department_id = D.department_id
     JOIN 
         arrival_patterns A ON P.arrival_time = A.hour_of_day AND P.arrival_date = A.day_of_week
     JOIN 
         seasonality S ON P.arrival_date BETWEEN S.start_date AND S.end_date) A
------------------
Identify the most profitable courses for an online education platform by analyzing enrollment data, considering the impact of course duration, pricing, and instructor experience.
Schema:
[
  {
    "name": "courses",
    "columns": [
      {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "course_name", "type": "VARCHAR(255)"},
      {"name": "duration", "type": "INT"},
      {"name": "price", "type": "DECIMAL(10, 2)"},
      {"name": "instructor_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES instructors(instructor_id)"]}
    ]
  },
  {
    "name": "enrollments",
    "columns": [
      {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
      {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
      {"name": "enrollment_date", "type": "DATE"}
    ]
  },
  {
    "name": "instructors",
    "columns": [
      {"name": "instructor_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "instructor_name", "type": "VARCHAR(255)"},
      {"name": "experience", "type": "INT"}
    ]
  },
  {
    "name": "students",
    "columns": [
      {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "student_name", "type": "VARCHAR(255)"},
      {"name": "completion_rate", "type": "DECIMAL(10, 2)"}
    ]
  }
]
Response:
SELECT c.course_id, c.course_name, c.duration, c.price, i.instructor_name, i.experience, COUNT(e.enrollment_id) as total_enrollments 
FROM courses c 
JOIN instructors i ON c.instructor_id = i.instructor_id 
JOIN enrollments e ON c.course_id = e.course_id 
GROUP BY c.course_id, c.course_name, c.duration, c.price, i.instructor_name, i.experience 
HAVING (c.price * c.duration * i.experience) - COUNT(e.enrollment_id) > 0 
ORDER BY (c.price * c.duration * i.experience) - COUNT(e.enrollment_id) DESC
------------------
Analyze the financial performance of a tech company by identifying the top-performing product lines, sales channels, and regions, while considering the impact of marketing campaigns and seasonal fluctuations.
Schema:
[
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_name", "type": "VARCHAR(255)"},
      {"name": "category", "type": "VARCHAR(255)"},
      {"name": "price", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "orders",
    "columns": [
      {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "order_date", "type": "DATE"},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
      {"name": "channel", "type": "VARCHAR(255)"},
      {"name": "region", "type": "VARCHAR(255)"},
      {"name": "marketing_campaign", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "revenue",
    "columns": [
      {"name": "revenue_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
      {"name": "revenue_amount", "type": "DECIMAL(10, 2)"},
      {"name": "revenue_date", "type": "DATE"}
    ]
  },
  {
    "name": "marketing_campaigns",
    "columns": [
      {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "campaign_name", "type": "VARCHAR(255)"},
      {"name": "start_date", "type": "DATE"},
      {"name": "end_date", "type": "DATE"}
    ]
  }
]
Response:
SELECT 
  p.product_name,
  SUM(CASE WHEN o.channel = 'online' THEN r.revenue_amount ELSE 0 END) AS online_revenue,
  SUM(CASE WHEN o.channel = 'physical' THEN r.revenue_amount ELSE 0 END) AS physical_revenue,
  SUM(CASE WHEN o.region = 'north' THEN r.revenue_amount ELSE 0 END) AS north_revenue,
  SUM(CASE WHEN o.region = 'south' THEN r.revenue_amount ELSE 0 END) AS south_revenue,
  SUM(CASE WHEN o.marketing_campaign = 'campaign1' THEN r.revenue_amount ELSE 0 END) AS campaign1_revenue,
  SUM(CASE WHEN o.marketing_campaign = 'campaign2' THEN r.revenue_amount ELSE 0 END) AS campaign2_revenue
FROM 
  products p
  JOIN orders o ON p.product_id = o.product_id
  JOIN revenue r ON o.order_id = r.order_id
WHERE 
  r.revenue_date BETWEEN '2020-01-01' AND '2020-12-31'
GROUP BY 
  p.product_name
ORDER BY 
  online_revenue DESC;
------------------
Optimize the inventory management system for an e-commerce company by identifying the slow-moving products, analyzing the impact of seasonality and promotions on sales, and recommending inventory replenishment strategies.
Schema:
[
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_name", "type": "VARCHAR(255)"},
      {"name": "category", "type": "VARCHAR(255)"},
      {"name": "price", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "orders",
    "columns": [
      {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "order_date", "type": "DATE"},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
      {"name": "channel", "type": "VARCHAR(255)"},
      {"name": "region", "type": "VARCHAR(255)"},
      {"name": "promotion", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "inventories",
    "columns": [
      {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
      {"name": "quantity", "type": "INT"},
      {"name": "reorder_point", "type": "INT"}
    ]
  },
  {
    "name": "seasonality",
    "columns": [
      {"name": "season_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "season_name", "type": "VARCHAR(255)"},
      {"name": "start_date", "type": "DATE"},
      {"name": "end_date", "type": "DATE"}
    ]
  }
]
Response:
SELECT 
  p.product_name, 
  SUM(CASE WHEN o.order_date BETWEEN s.start_date AND s.end_date THEN o.quantity ELSE 0 END) AS seasonal_sales,
  SUM(CASE WHEN o.promotion IS NOT NULL THEN o.quantity ELSE 0 END) AS promotional_sales,
  i.quantity AS current_inventory,
  i.reorder_point AS reorder_point
FROM 
  products p
  JOIN inventories i ON p.product_id = i.product_id
  JOIN orders o ON p.product_id = o.product_id
  JOIN seasonality s ON o.order_date BETWEEN s.start_date AND s.end_date
GROUP BY 
  p.product_name, i.quantity, i.reorder_point
ORDER BY 
  seasonal_sales DESC
------------------
Predicting Customer Churn in a Telecom Industry

A telecom company wants to identify high-value customers who are likely to churn within the next 30 days. The company has collected data on customer demographics, usage patterns, and billing information. Please write a SQL query that uses machine learning algorithms to predict customer churn and identify high-risk customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "plan_type", "type": "VARCHAR(50)"},
            {"name": "credit_limit", "type": "DECIMAL(10, 2)"},
            {"name": "avg_monthly_bill", "type": "DECIMAL(10, 2)"},
            {"name": "churn_date", "type": "DATE"}
        ]
    },
    {
        "name": "usage_history",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "INT"},
            {"name": "voice_usage", "type": "INT"}
        ]
    },
    {
        "name": "billing_history",
        "columns": [
            {"name": "billing_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "bill_date", "type": "DATE"},
            {"name": "amount_due", "type": "DECIMAL(10, 2)"},
            {"name": "amount_paid", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographics_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"},
            {"name": "employment_status", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.plan_type, 
    c.credit_limit, 
    c.avg_monthly_bill, 
    u.usage_date, 
    u.data_usage, 
    u.voice_usage, 
    b.amount_due, 
    b.amount_paid, 
    d.age, 
    d.income, 
    d.employment_status 
FROM 
    customers c 
JOIN 
    billing_history b ON c.customer_id = b.customer_id 
JOIN 
    demographics d ON c.customer_id = d.customer_id 
JOIN 
    usage_history u ON c.customer_id = u.customer_id 
WHERE 
    c.avg_monthly_bill > (SELECT AVG(avg_monthly_bill) FROM customers) 
    AND c.credit_limit > (SELECT MAX(credit_limit) FROM customers) 
    AND u.data_usage > (SELECT AVG(data_usage) FROM usage_history) 
    AND u.voice_usage > (SELECT AVG(voice_usage) FROM usage_history) 
    AND b.amount_due > (SELECT AVG(amount_due) FROM billing_history) 
    AND b.amount_paid < (SELECT AVG(amount_paid) FROM billing_history) 
    AND c.churn_date IS NULL 
    AND c.churn_date >= DATE('now', '-30 days')
------------------
Analyzing Sales Performance by Region and Product Category

A retail company wants to analyze sales performance by region and product category. The company has collected data on sales transactions, product categorization, and store locations. Please write a SQL query that uses window functions and aggregation to identify top-performing regions and product categories.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "product_category", "type": "VARCHAR(50)"},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity_sold", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
  region, 
  product_category, 
  SUM(revenue) AS total_revenue, 
  RANK() OVER (PARTITION BY region ORDER BY SUM(revenue) DESC) AS region_rank, 
  RANK() OVER (PARTITION BY product_category ORDER BY SUM(revenue) DESC) AS category_rank
FROM sales
JOIN stores ON sales.region = stores.region
JOIN products ON sales.product_id = products.product_id
GROUP BY region, product_category
------------------
Identifying High-Risk Transactions in a Payment Processing System

A payment processing company wants to identify high-risk transactions that may be indicative of fraudulent activity. The company has collected data on transaction histories, customer information, and payment method details. Please write a SQL query that uses machine learning algorithms to predict high-risk transactions and identify suspicious patterns.
Schema:
[
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "payment_method", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "payment_methods",
        "columns": [
            {"name": "payment_method_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "payment_method_name", "type": "VARCHAR(50)"},
            {"name": "payment_method_type", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT t1.transaction_id, t1.customer_id, t1.transaction_date, t1.amount, t1.payment_method 
FROM transactions t1 
JOIN customers t2 ON t1.customer_id = t2.customer_id 
JOIN payment_methods t3 ON t1.payment_method = t3.payment_method_name 
WHERE t1.amount > (SELECT AVG(amount) FROM transactions WHERE transaction_date > (SELECT MAX(transaction_date) - INTERVAL 30 DAY FROM transactions)) 
OR t1.amount > (SELECT AVG(amount) FROM transactions WHERE payment_method = t1.payment_method AND transaction_date BETWEEN (SELECT MAX(transaction_date) - INTERVAL 30 DAY FROM transactions) AND (SELECT MAX(transaction_date) FROM transactions)) 
OR t1.amount > 1000
------------------
Improving Healthcare Outcomes through Data-Driven Insights

A healthcare organization wants to analyze patient outcomes and identify areas for improvement. The organization has collected data on patient demographics, medical history, and treatment outcomes. Please write a SQL query that uses data visualization and machine learning algorithms to identify trends and patterns in patient outcomes.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "medical_history",
        "columns": [
            {"name": "medical_history_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "condition", "type": "VARCHAR(255)"},
            {"name": "treatment_date", "type": "DATE"}
        ]
    },
    {
        "name": "treatment_outcomes",
        "columns": [
            {"name": "treatment_outcome_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "medical_history_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES medical_history(medical_history_id)"]},
            {"name": "outcome_date", "type": "DATE"},
            {"name": "outcome_status", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
    p.name, 
    p.age, 
    p.gender, 
    mh.condition, 
    mh.treatment_date, 
    to.outcome_status, 
    to.outcome_date
FROM 
    patients p
INNER JOIN 
    medical_history mh ON p.patient_id = mh.patient_id
INNER JOIN 
    treatment_outcomes to ON mh.medical_history_id = to.medical_history_id
WHERE 
    to.outcome_date >= (CURRENT_DATE - INTERVAL 1 YEAR)
------------------
Optimizing Supply Chain Operations through Data Analysis

A logistics company wants to optimize supply chain operations by identifying bottlenecks and areas for improvement. The company has collected data on shipment tracking, warehouse inventory, and delivery schedules. Please write a SQL query that uses data visualization and machine learning algorithms to identify trends and patterns in supply chain operations.
Schema:
[
    {
        "name": "shipments",
        "columns": [
            {"name": "shipment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "shipment_date", "type": "DATE"},
            {"name": "origin", "type": "VARCHAR(255)"},
            {"name": "destination", "type": "VARCHAR(255)"},
            {"name": "weight", "type": "DECIMAL(10, 2)"},
            {"name": "volume", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  shipments.shipment_id, 
  shipments.shipment_date, 
  shipments.origin, 
  shipments.destination, 
  shipments.weight, 
  shipments.volume, 
  warehouses.warehouse_name, 
  inventory.quantity 
FROM 
  shipments 
  JOIN inventory ON shipments.shipment_id = inventory.product_id 
  JOIN warehouses ON inventory.warehouse_id = warehouses.warehouse_id 
  GROUP BY 
  shipments.shipment_id 
  ORDER BY 
  shipments.shipment_date
------------------
Identifying Influencers in a Social Network

A social media platform wants to identify influential users who can help promote the platform. The platform has collected data on user interactions, post engagement, and user demographics. Please write a SQL query that uses graph algorithms and machine learning algorithms to identify influencers and rank them based on their influence.
Schema:
[
    {
        "name": "users",
        "columns": [
            {"name": "user_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"}
        ]
    },
    {
        "name": "posts",
        "columns": [
            {"name": "post_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "user_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES users(user_id)"]},
            {"name": "post_date", "type": "DATE"},
            {"name": "engagement", "type": "INT"}
        ]
    },
    {
        "name": "interactions",
        "columns": [
            {"name": "interaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "user_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES users(user_id)"]},
            {"name": "post_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES posts(post_id)"]},
            {"name": "interaction_type", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
WITH graph AS (
  SELECT user_id, COUNT(*) AS degree
  FROM interactions
  GROUP BY user_id
),
ranked_influencers AS (
  SELECT user_id, degree,
         ROW_NUMBER() OVER (ORDER BY degree DESC) AS rank
  FROM graph
)
SELECT u.name, u.email, ri.rank
FROM users u
JOIN ranked_influencers ri ON u.user_id = ri.user_id
WHERE ri.rank <= (SELECT COUNT(*) FROM users) * 0.1;
------------------
Improving Education Outcomes through Data-Driven Insights

An educational institution wants to analyze student outcomes and identify areas for improvement. The institution has collected data on student demographics, academic performance, and course enrollment. Please write a SQL query that uses data visualization and machine learning algorithms to identify trends and patterns in student outcomes.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "course_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT s.name, e.grade, c.course_name 
FROM students s 
JOIN enrollments e ON s.student_id = e.student_id 
JOIN courses c ON e.course_id = c.course_id 
WHERE e.grade = 'A'
------------------
Analyzing Market Trends through Social Media Analysis

A marketing agency wants to analyze market trends and identify areas for improvement. The agency has collected data on social media engagement, customer demographics, and campaign performance. Please write a SQL query that uses data visualization and machine learning algorithms to identify trends and patterns in market trends.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"}
        ]
    },
    {
        "name": "posts",
        "columns": [
            {"name": "post_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "post_date", "type": "DATE"},
            {"name": "engagement", "type": "INT"}
        ]
    },
    {
        "name": "campaigns",
        "columns": [
            {"name": "campaign_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "campaign_name", "type": "VARCHAR(255)"},
            {"name": "campaign_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    p.post_id, 
    p.post_date, 
    p.engagement, 
    ca.campaign_id, 
    ca.campaign_name, 
    ca.campaign_date 
FROM 
    customers c 
JOIN 
    posts p ON c.customer_id = p.customer_id 
JOIN 
    campaigns ca ON c.customer_id = ca.customer_id 
ORDER BY 
    p.post_date DESC, 
    ca.campaign_date DESC
------------------
Predicting Equipment Failure in a Manufacturing Environment

A manufacturing company wants to predict equipment failure and reduce downtime. The company has collected data on equipment maintenance, sensor readings, and production metrics. Please write a SQL query that uses machine learning algorithms to predict equipment failure and identify high-risk equipment.
Schema:
[
    {
        "name": "equipment",
        "columns": [
            {"name": "equipment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "equipment_name", "type": "VARCHAR(255)"},
            {"name": "equipment_type", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "maintenance",
        "columns": [
            {"name": "maintenance_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "equipment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES equipment(equipment_id)"]},
            {"name": "maintenance_date", "type": "DATE"}
        ]
    },
    {
        "name": "sensor_readings",
        "columns": [
            {"name": "sensor_reading_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "equipment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES equipment(equipment_id)"]},
            {"name": "sensor_date", "type": "DATE"},
            {"name": "sensor_reading", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    e.equipment_id, e.equipment_name, e.equipment_type, 
    COUNT(DISTINCT mr.maintenance_id) AS maintenance_count, 
    AVG(sr.sensor_reading) AS avg_sensor_reading, 
    SUM(CASE WHEN sr.sensor_reading < 50 THEN 1 ELSE 0 END) / COUNT(DISTINCT sr.sensor_reading_id) AS failure_ratio
FROM 
    equipment e
JOIN 
    maintenance mr ON e.equipment_id = mr.equipment_id
JOIN 
    sensor_readings sr ON e.equipment_id = sr.equipment_id
GROUP BY 
    e.equipment_id, e.equipment_name, e.equipment_type
ORDER BY 
    failure_ratio DESC;
------------------
Analyzing Student Performance in an Online Learning Environment

An online learning platform wants to analyze student performance and identify areas for improvement. The platform has collected data on student demographics, course enrollment, and academic performance. Please write a SQL query that uses data visualization and machine learning algorithms to identify trends and patterns in student performance.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "course_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "grade", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
    s.student_id, 
    s.name, 
    s.age, 
    s.gender, 
    c.course_name, 
    e.grade, 
    AVG(e.grade) OVER (PARTITION BY c.course_name) AS avg_grade_course
FROM 
    students s
JOIN 
    enrollments e ON s.student_id = e.student_id
JOIN 
    courses c ON e.course_id = c.course_id
ORDER BY 
    c.course_name, 
    e.grade DESC;
------------------
**Analyzing Sales Performance and Identifying Market Trends**

A retail company wants to analyze its sales performance across different regions, product categories, and product types. They need to identify the top-selling products in each region, the total sales revenue generated by each product category, and the sales growth trend over the past two years. The company also wants to compare the sales performance of two specific product categories, Electronics and Home Appliances, in different regions.
Schema:
[
    {
        "name": "sales_data",
        "columns": [
            {"name": "sales_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sales_date", "type": "DATE"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_type", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region", "type": "VARCHAR(255)", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    sd.region, 
    p.product_name, 
    sd.sales_date, 
    sd.sales_amount
FROM 
    sales_data sd
JOIN 
    products p ON sd.product_id = p.product_id
WHERE 
    sd.sales_date BETWEEN '2020-01-01' AND '2022-01-01'
ORDER BY 
    sd.sales_date DESC;

-- Top-selling products in each region
SELECT 
    sd.region, 
    p.product_name, 
    SUM(sd.sales_amount) AS total_sales
FROM 
    sales_data sd
JOIN 
    products p ON sd.product_id = p.product_id
GROUP BY 
    sd.region, 
    p.product_name
ORDER BY 
    total_sales DESC;

-- Total sales revenue generated by each product category
SELECT 
    p.product_category, 
    SUM(sd.sales_amount) AS total_sales
FROM 
    sales_data sd
JOIN 
    products p ON sd.product_id = p.product_id
GROUP BY 
    p.product_category
ORDER BY 
    total_sales DESC;

-- Sales growth trend over the past two years
SELECT 
    EXTRACT(YEAR FROM sd.sales_date) AS sales_year, 
    SUM(sd.sales_amount) AS total_sales
FROM 
    sales_data sd
GROUP BY 
    EXTRACT(YEAR FROM sd.sales_date)
ORDER BY 
    sales_year ASC;

-- Compare the sales performance of Electronics and Home Appliances in different regions
SELECT 
    sd.region, 
    sd.product_category, 
    SUM(sd.sales_amount) AS total_sales
FROM 
    sales_data sd
WHERE 
    sd.product_category IN ('Electronics', 'Home Appliances')
GROUP BY 
    sd.region, 
    sd.product_category
ORDER BY 
    sd.region, 
    total_sales DESC;
------------------
**Identifying High-Value Customers and Predicting Future Sales**

A retail company wants to identify its high-value customers and predict their future sales. They have a large customer database with purchase history and demographics. The company wants to analyze the data to understand which customers are most likely to make large purchases in the next quarter, and what factors contribute to their purchasing behavior.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "income", "type": "FLOAT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_total", "type": "FLOAT"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "FLOAT"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "FLOAT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.age, c.gender, c.income, SUM(o.order_total) AS total_spent
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= DATE('now', '-3 months')
GROUP BY c.customer_id, c.name, c.email, c.age, c.gender, c.income
HAVING SUM(o.order_total) > (SELECT AVG(order_total) FROM orders WHERE order_date >= DATE('now', '-3 months'))
ORDER BY total_spent DESC
------------------
**Analyzing Customer Churn and Identifying Key Factors**

A telecom company wants to analyze customer churn and identify key factors that contribute to it. They have a large customer database with demographic information, usage data, and churn status. The company wants to understand which factors are most strongly correlated with churn, and use this information to develop targeted retention strategies.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "income", "type": "FLOAT"}
        ]
    },
    {
        "name": "usage_data",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "FLOAT"},
            {"name": "voice_minutes", "type": "INT"}
        ]
    },
    {
        "name": "churn_status",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason_for_churn", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  u.data_usage, 
  u.voice_minutes, 
  cs.reason_for_churn, 
  cs.churn_date,
  c.income, 
  c.age, 
  c.gender
FROM 
  customers c
  JOIN churn_status cs ON c.customer_id = cs.customer_id
  JOIN usage_data u ON c.customer_id = u.customer_id
WHERE 
  cs.churn_date IS NOT NULL
------------------
**Optimizing Inventory Levels and Supply Chain Logistics**

A retail company wants to optimize its inventory levels and supply chain logistics. They have a complex inventory management system with multiple warehouses, suppliers, and products. The company wants to analyze the data to understand which products are most likely to be in high demand, and optimize inventory levels accordingly.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "FLOAT"}
        ]
    },
    {
        "name": "warehouses",
        "columns": [
            {"name": "warehouse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory_levels",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "warehouse_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES warehouses(warehouse_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "reorder_point", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(o.quantity) AS total_orders, il.quantity AS current_quantity
FROM products p
JOIN orders o ON p.product_id = o.product_id
JOIN inventory_levels il ON p.product_id = il.product_id
GROUP BY p.product_name, il.quantity
HAVING SUM(o.quantity) > il.reorder_point
------------------
**Predicting Customer Lifetime Value**

A retail company wants to identify its most valuable customers and prioritize them for marketing campaigns. The company has a large dataset containing customer information, purchase history, and demographic data. The goal is to develop a SQL query that calculates the predicted lifetime value (PLV) of each customer based on their past purchases, average order value, and expected future purchases.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_value", "type": "DECIMAL(10, 2)"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "future_purchases",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "next_purchase_date", "type": "DATE"},
            {"name": "expected_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, c.age, c.income, 
       AVG(o.total_value) AS average_order_value, 
       SUM(fp.expected_value) AS total_future_value,
       AVG(o.total_value) * SUM(fp.expected_value) AS predicted_lifetime_value
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN future_purchases fp ON c.customer_id = fp.customer_id
GROUP BY c.customer_id, c.name, c.email, c.age, c.income;
------------------
**Analyzing Sales Performance by Region**

A multinational electronics company wants to analyze the sales performance of its regional offices across different product categories. The company has a dataset containing sales data, product information, and regional office details. The goal is to develop a SQL query that calculates the total sales by region, product category, and year, and also identifies the top-selling product categories in each region.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "total_value", "type": "DECIMAL(10, 2)"},
            {"name": "year", "type": "INT"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    p.category, 
    SUM(s.quantity) AS total_quantity, 
    SUM(s.total_value) AS total_value, 
    YEAR(s.sale_date) AS sale_year
FROM 
    sales s
JOIN 
    regions r ON s.region_id = r.region_id
JOIN 
    products p ON s.product_id = p.product_id
GROUP BY 
    r.region_name, 
    p.category, 
    YEAR(s.sale_date)
ORDER BY 
    r.region_name, 
    p.category, 
    sale_year;
------------------
**Identifying High-Risk Accounts**

A financial institution wants to identify high-risk accounts in its customer database. The institution has a dataset containing customer information, account details, and transaction data. The goal is to develop a SQL query that classifies accounts as high-risk based on their transaction history, account balance, and credit score.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "credit_score", "type": "DECIMAL(3, 2)"}
        ]
    },
    {
        "name": "accounts",
        "columns": [
            {"name": "account_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "account_balance", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES accounts(account_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "transaction_type", "type": "VARCHAR(10)"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id
FROM customers c
JOIN accounts a ON c.customer_id = a.customer_id
JOIN (
  SELECT account_id, 
         SUM(CASE WHEN transaction_type = 'DEBIT' THEN -amount ELSE amount END) AS net_amount
  FROM transactions
  GROUP BY account_id
) t ON a.account_id = t.account_id
WHERE (
  a.account_balance < 0
  OR t.net_amount > 1000
  OR c.credit_score < 500
)
------------------
**Optimizing Inventory Management**

An e-commerce company wants to optimize its inventory management by identifying slow-moving products and overstocked items. The company has a dataset containing product information, inventory levels, and sales data. The goal is to develop a SQL query that identifies products with low sales velocity and high inventory levels, and suggests a reorder point for each product.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "inventory_level", "type": "INT"},
            {"name": "reorder_point", "type": "INT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, i.product_id, i.inventory_level, 
       (SELECT SUM(s.quantity) / COUNT(DISTINCT s.sale_date) 
        FROM sales s 
        WHERE s.product_id = i.product_id) AS sales_velocity,
       CASE 
           WHEN (SELECT SUM(s.quantity) / COUNT(DISTINCT s.sale_date) 
                 FROM sales s 
                 WHERE s.product_id = i.product_id) < 10 
           THEN i.inventory_level - 10 
           ELSE i.inventory_level 
       END AS reorder_point
FROM inventory i
JOIN products p ON i.product_id = p.product_id
WHERE i.inventory_level > (SELECT SUM(s.quantity) / COUNT(DISTINCT s.sale_date) 
                           FROM sales s 
                           WHERE s.product_id = i.product_id) * 3;
------------------
**Analyzing Student Performance**

A university wants to analyze the performance of its students across different departments and semesters. The university has a dataset containing student information, course enrollment data, and grade records. The goal is to develop a SQL query that calculates the average GPA of students by department, semester, and course.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "courses",
        "columns": [
            {"name": "course_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "course_name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES courses(course_id)"]},
            {"name": "semester", "type": "VARCHAR(10)"}
        ]
    },
    {
        "name": "grades",
        "columns": [
            {"name": "grade_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "enrollment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES enrollments(enrollment_id)"]},
            {"name": "grade", "type": "VARCHAR(5)"}
        ]
    }
]
Response:
SELECT 
    s.department, 
    e.semester, 
    c.course_name, 
    AVG(g.grade) AS average_gpa
FROM 
    grades g
JOIN 
    enrollments e ON g.enrollment_id = e.enrollment_id
JOIN 
    courses c ON e.course_id = c.course_id
JOIN 
    students s ON e.student_id = s.student_id
GROUP BY 
    s.department, 
    e.semester, 
    c.course_name
------------------
**Forecasts Sales by Product**

A retail company wants to forecast its sales by product category for the next quarter. The company has a dataset containing sales data, product information, and seasonal trends. The goal is to develop a SQL query that uses a moving average model to forecast sales by product category and quarter.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "seasonal_trends",
        "columns": [
            {"name": "trend_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "season", "type": "VARCHAR(10)"}
        ]
    }
]
Response:
SELECT 
  p.category AS product_category, 
  s.season AS sales_season, 
  AVG(s.quantity) OVER (PARTITION BY p.category, s.season ORDER BY s.sale_date ROWS 12 PRECEDING) AS moving_average
FROM 
  products p 
  JOIN sales s ON p.product_id = s.product_id 
  JOIN seasonal_trends st ON p.product_id = st.product_id 
WHERE 
  s.sale_date >= (SELECT MIN(s.sale_date) FROM sales) + INTERVAL 3 QUARTER;
------------------
**Identifying Data Quality Issues**

A data analyst wants to identify data quality issues in a large dataset containing customer information and transaction records. The dataset has missing values, inconsistent formatting, and duplicate entries. The goal is to develop a SQL query that flags records with missing or inconsistent data and identifies duplicate entries.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "phone", "type": "VARCHAR(20)"},
            {"name": "address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.phone, 
  c.address, 
  t.transaction_id, 
  t.transaction_date, 
  t.amount 
FROM 
  customers c 
  LEFT JOIN transactions t ON c.customer_id = t.customer_id 
WHERE 
  c.customer_id IS NULL 
  OR c.name IS NULL 
  OR c.email IS NULL 
  OR c.phone IS NULL 
  OR c.address IS NULL 
  OR t.transaction_date IS NULL 
  OR t.amount IS NULL 
  OR t.customer_id NOT IN (SELECT customer_id FROM customers) 
  OR t.amount < 0 
  OR t.amount > 1000;

SELECT 
  customer_id, 
  COUNT(*) as num_transactions 
FROM 
  transactions 
GROUP BY 
  customer_id 
HAVING 
  COUNT(*) > 1;

SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.phone, 
  c.address 
FROM 
  customers c 
  LEFT JOIN transactions t ON c.customer_id = t.customer_id 
WHERE 
  t.customer_id IS NULL
------------------
**Analyzing Website Traffic**

A website analytics company wants to analyze the traffic patterns of its clients' websites. The company has a dataset containing website traffic data, user demographics, and browser information. The goal is to develop a SQL query that calculates the average time spent on the website by user demographics and browser type.
Schema:
[
    {
        "name": "traffic",
        "columns": [
            {"name": "traffic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "user_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES users(user_id)"]},
            {"name": "visit_date", "type": "DATE"},
            {"name": "browser", "type": "VARCHAR(50)"},
            {"name": "device", "type": "VARCHAR(50)"},
            {"name": "location", "type": "VARCHAR(50)"},
            {"name": "time_spent", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "users",
        "columns": [
            {"name": "user_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "country", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "browsers",
        "columns": [
            {"name": "browser_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "browser_name", "type": "VARCHAR(50)"},
            {"name": "browser_type", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
    u.age, 
    u.gender, 
    u.country, 
    b.browser_name, 
    AVG(t.time_spent) AS average_time_spent
FROM 
    traffic t
JOIN 
    users u ON t.user_id = u.user_id
JOIN 
    browsers b ON t.browser = b.browser_name
GROUP BY 
    u.age, 
    u.gender, 
    u.country, 
    b.browser_name
------------------
**Optimizing Logistics Operations**

A logistics company wants to optimize its delivery operations by identifying the most efficient routes and schedules for its drivers. The company has a dataset containing driver information, route data, and delivery schedules. The goal is to develop a SQL query that calculates the optimal route and schedule for each driver based on their available time and the delivery requirements.
Schema:
[
    {
        "name": "drivers",
        "columns": [
            {"name": "driver_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "vehicle_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES vehicles(vehicle_id)"]},
            {"name": "available_time", "type": "TIME"}
        ]
    },
    {
        "name": "routes",
        "columns": [
            {"name": "route_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "driver_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES drivers(driver_id)"]},
            {"name": "route_name", "type": "VARCHAR(255)"},
            {"name": "start_location", "type": "VARCHAR(255)"},
            {"name": "end_location", "type": "VARCHAR(255)"},
            {"name": "distance", "type": "DECIMAL(10, 2)"},
            {"name": "travel_time", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "deliveries",
        "columns": [
            {"name": "delivery_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "route_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES routes(route_id)"]},
            {"name": "delivery_date", "type": "DATE"},
            {"name": "delivery_time", "type": "TIME"},
            {"name": "delivery_location", "type": "VARCHAR(255)"},
            {"name": "package_weight", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "vehicles",
        "columns": [
            {"name": "vehicle_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "vehicle_type", "type": "VARCHAR(50)"},
            {"name": "seating_capacity", "type": "INT"},
            {"name": "cargo_capacity", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    d.driver_id, 
    d.name, 
    r.route_name, 
    d.available_time, 
    d.vehicle_id, 
    v.vehicle_type, 
    v.seating_capacity, 
    v.cargo_capacity, 
    r.start_location, 
    r.end_location, 
    r.distance, 
    r.travel_time, 
    d1.delivery_date, 
    d1.delivery_time, 
    d1.delivery_location, 
    d1.package_weight
FROM 
    drivers d
JOIN 
    routes r ON d.driver_id = r.driver_id
JOIN 
    deliveries d1 ON r.route_id = d1.route_id
JOIN 
    vehicles v ON d.vehicle_id = v.vehicle_id
WHERE 
    d.available_time >= d1.delivery_time
ORDER BY 
    d.driver_id, 
    d1.delivery_date
------------------
**Analyzing Customer Feedback**

A company wants to analyze customer feedback from various social media platforms and identify the most common complaints and suggestions. The company has a dataset containing customer feedback data, including sentiment analysis and keyword extraction. The goal is to develop a SQL query that calculates the top 10 keywords and phrases associated with positive and negative sentiment.
Schema:
[
    {
        "name": "feedback",
        "columns": [
            {"name": "feedback_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "platform", "type": "VARCHAR(20)"},
            {"name": "feedback_text", "type": "VARCHAR(255)"},
            {"name": "sentiment", "type": "VARCHAR(10)"},
            {"name": "keyword", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    keyword,
    COUNT(*) AS frequency
FROM 
    feedback
WHERE 
    sentiment IN ('Positive', 'Negative')
GROUP BY 
    keyword
ORDER BY 
    frequency DESC
LIMIT 10
------------------
**Analyze Sales Trends and Customer Segmentation for a Retail Company**

A retail company wants to analyze sales trends and customer segmentation based on purchase history, demographics, and geographic location. The company has a large dataset of customer information, orders, and product sales. The goal is to identify high-value customers, track sales trends over time, and segment customers based on their purchase behavior and demographics.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(10)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales_trends",
        "columns": [
            {"name": "date", "type": "DATE"},
            {"name": "total_sales", "type": "DECIMAL(10, 2)"},
            {"name": "average_order_value", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.location, 
    SUM(oi.quantity * p.price) AS total_spent
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items oi ON o.order_id = oi.order_id
JOIN 
    products p ON oi.product_id = p.product_id
GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.location
ORDER BY 
    total_spent DESC;

SELECT 
    s.date, 
    s.total_sales, 
    s.average_order_value
FROM 
    sales_trends s
ORDER BY 
    s.date DESC
LIMIT 6;

SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.location, 
    AVG(oi.quantity) AS avg_order_quantity, 
    AVG(o.total_amount) AS avg_order_value
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items oi ON o.order_id = oi.order_id
GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.location
HAVING 
    AVG(o.total_amount) > (SELECT 
                                AVG(total_amount) 
                            FROM 
                                orders);

SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.location, 
    COUNT(DISTINCT oi.product_id) AS num_unique_products
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
JOIN 
    order_items oi ON o.order_id = oi.order_id
GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.gender, 
    c.location
ORDER BY 
    num_unique_products DESC
LIMIT 10;
------------------
**Predicting Customer Churn in a Telecommunications Company**

Using historical data on customer interactions, predict which customers are likely to churn within the next 3 months. This involves analyzing factors such as usage patterns, billing information, and recent interactions with customer support. The goal is to identify high-risk customers and develop targeted retention strategies.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"},
            {"name": "last_active_date", "type": "DATE"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "FLOAT"},
            {"name": "voice_minutes", "type": "FLOAT"}
        ]
    },
    {
        "name": "billing",
        "columns": [
            {"name": "billing_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "billing_date", "type": "DATE"},
            {"name": "total_amount", "type": "FLOAT"},
            {"name": "payment_status", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "support_interactions",
        "columns": [
            {"name": "interaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "interaction_date", "type": "DATE"},
            {"name": "interaction_type", "type": "VARCHAR(255)"},
            {"name": "resolution_status", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customer_segments",
        "columns": [
            {"name": "segment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "segment_name", "type": "VARCHAR(255)"},
            {"name": "segment_description", "type": "TEXT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email 
FROM customers c 
JOIN usage u ON c.customer_id = u.customer_id 
JOIN billing b ON c.customer_id = b.customer_id 
JOIN support_interactions si ON c.customer_id = si.customer_id 
WHERE c.last_active_date < DATE('now', '-3 months') 
OR u.data_usage < 50 OR u.voice_minutes < 100 OR b.payment_status = 'Delayed' 
OR si.interaction_date > DATE('now', '-2 months') OR si.resolution_status = 'Unresolved';
------------------
**Identifying High-Risk Accounts in a Financial Institution**

Using historical transaction data and account information, identify high-risk accounts that are likely to be involved in fraudulent activities. This involves analyzing factors such as transaction frequency, total balance, and recent transaction patterns.
Schema:
[
    {
        "name": "accounts",
        "columns": [
            {"name": "account_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "account_type", "type": "VARCHAR(255)"},
            {"name": "balance", "type": "FLOAT"},
            {"name": "opening_date", "type": "DATE"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "account_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES accounts(account_id)"]},
            {"name": "transaction_date", "type": "DATE"},
            {"name": "transaction_amount", "type": "FLOAT"},
            {"name": "transaction_type", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "customer_profile",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "customer_address", "type": "VARCHAR(255)"},
            {"name": "customer_income", "type": "FLOAT"}
        ]
    }
]
Response:
SELECT a.account_id, a.customer_id, a.account_type, a.balance, c.customer_name, c.customer_address, c.customer_income, 
       COUNT(t.transaction_id) AS transaction_frequency, 
       SUM(t.transaction_amount) AS total_balance, 
       MAX(t.transaction_date) AS most_recent_transaction_date
FROM accounts a
JOIN transactions t ON a.account_id = t.account_id
JOIN customer_profile c ON a.customer_id = c.customer_id
GROUP BY a.account_id, a.customer_id, a.account_type, a.balance, c.customer_name, c.customer_address, c.customer_income
HAVING COUNT(t.transaction_id) >= 10  -- assuming 10 transactions is a threshold for high-risk accounts
   OR SUM(t.transaction_amount) > 10000  -- assuming a high balance is a risk indicator
   OR MAX(t.transaction_date) > (CURRENT_DATE - INTERVAL 1 WEEK)  -- assuming recent transactions are a risk indicator
ORDER BY transaction_frequency DESC
------------------
**Analyzing Sales Trends in an E-commerce Platform**

Using historical sales data and product information, analyze sales trends and identify popular products, product categories, and sales channels. This involves aggregating sales data by product category, analyzing sales patterns by season, and identifying top-selling products.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_price", "type": "FLOAT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "FLOAT"},
            {"name": "sale_channel", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales(sale_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_item_quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    p.product_category, 
    SUM(o.order_item_quantity) AS total_quantity, 
    SUM(s.sale_amount) AS total_sales, 
    EXTRACT(YEAR FROM s.sale_date) AS sale_year, 
    EXTRACT(SEASON FROM s.sale_date) AS sale_season
FROM 
    products p
JOIN 
    sales s ON p.product_id = s.product_id
JOIN 
    order_items o ON s.sale_id = o.sale_id
GROUP BY 
    p.product_category, 
    sale_year, 
    sale_season
ORDER BY 
    total_sales DESC;
------------------
**Optimizing Inventory Management in a Retail Store**

Using historical sales data and inventory information, optimize inventory levels and minimize stockouts and overstocking. This involves analyzing sales trends, identifying slow-moving products, and determining optimal reorder quantities.
Schema:
[
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "inventory_level", "type": "INT"},
            {"name": "reorder_point", "type": "INT"},
            {"name": "reorder_quantity", "type": "INT"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "FLOAT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "product_price", "type": "FLOAT"}
        ]
    }
]
Response:
SELECT p.product_name, i.inventory_level, i.reorder_point, i.reorder_quantity 
FROM inventory i 
JOIN products p ON i.product_id = p.product_id 
WHERE i.inventory_level < i.reorder_point OR i.inventory_level + i.reorder_quantity > (SELECT SUM(s.sale_amount) 
FROM sales s 
WHERE s.sale_date >= (SELECT MAX(sale_date) - INTERVAL 3 MONTH 
FROM sales s 
WHERE s.product_id = i.product_id))
------------------
**Predicting Patient Outcomes in a Hospital**

Using historical patient data and clinical information, predict patient outcomes and identify high-risk patients. This involves analyzing factors such as patient demographics, medical history, and treatment outcomes.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_name", "type": "VARCHAR(255)"},
            {"name": "patient_dob", "type": "DATE"},
            {"name": "patient_gender", "type": "VARCHAR(255)"},
            {"name": "patient_email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "visits",
        "columns": [
            {"name": "visit_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "visit_date", "type": "DATE"},
            {"name": "visit_type", "type": "VARCHAR(255)"},
            {"name": "visit_reason", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "medications",
        "columns": [
            {"name": "medication_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "medication_name", "type": "VARCHAR(255)"},
            {"name": "medication_dose", "type": "FLOAT"}
        ]
    },
    {
        "name": "lab_results",
        "columns": [
            {"name": "lab_result_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "lab_test_name", "type": "VARCHAR(255)"},
            {"name": "lab_test_result", "type": "FLOAT"}
        ]
    }
]
Response:
SELECT p.patient_id, p.patient_name, v.visit_date, m.medication_name, l.lab_test_name, l.lab_test_result 
FROM patients p 
INNER JOIN visits v ON p.patient_id = v.patient_id 
INNER JOIN medications m ON p.patient_id = m.patient_id 
INNER JOIN lab_results l ON p.patient_id = l.patient_id 
WHERE p.patient_id IN ( 
    SELECT patient_id FROM (
        SELECT patient_id, 
        ROW_NUMBER() OVER (PARTITION BY patient_id ORDER BY visit_date DESC) as visit_rank 
        FROM visits 
    ) sub 
    WHERE visit_rank = 1 
) AND l.lab_test_result > 1000 AND m.medication_dose > 10;

This query joins the patients, visits, medications, and lab_results tables based on the patient_id column. It filters the results to include only patients who have had at least one visit and have a lab test result greater than 1000 and a medication dose greater than 10. The subquery is used to rank the most recent visit for each patient, and the WHERE clause filters the results to include only the patients with the most recent visit.
------------------
**Analyze Sales Performance by Region and Product Category**
Develop a SQL query to retrieve the total sales amount for each region and product category, along with the average sales amount per customer, for a given time period. The query should also include a ranking of the top 3 regions by total sales amount and the top 3 product categories by average sales amount per customer.
Schema:
[
  {
    "name": "sales",
    "columns": [
      {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "region", "type": "VARCHAR(255)"},
      {"name": "product_category", "type": "VARCHAR(255)"},
      {"name": "sale_date", "type": "DATE"},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"},
      {"name": "region", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "product_categories",
    "columns": [
      {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "category_name", "type": "VARCHAR(255)"},
      {"name": "description", "type": "VARCHAR(255)"}
    ]
  }
]
Response:
SELECT 
  s.region, 
  s.product_category, 
  SUM(s.sale_amount) AS total_sales, 
  AVG(CASE WHEN s.customer_id IS NOT NULL THEN s.sale_amount ELSE 0 END) AS avg_sales_per_customer
FROM 
  sales s
  LEFT JOIN customers c ON s.customer_id = c.customer_id
GROUP BY 
  s.region, 
  s.product_category
ORDER BY 
  total_sales DESC
LIMIT 3

UNION ALL

SELECT 
  'Region' AS type, 
  region AS value, 
  RANK() OVER (ORDER BY total_sales DESC) AS rank
FROM 
  (SELECT 
     s.region, 
     SUM(s.sale_amount) AS total_sales
   FROM 
     sales s
   GROUP BY 
     s.region) t

UNION ALL

SELECT 
  'Product Category' AS type, 
  product_category AS value, 
  RANK() OVER (ORDER BY avg_sales_per_customer DESC) AS rank
FROM 
  (SELECT 
     s.product_category, 
     AVG(CASE WHEN s.customer_id IS NOT NULL THEN s.sale_amount ELSE 0 END) AS avg_sales_per_customer
   FROM 
     sales s
   GROUP BY 
     s.product_category) t
------------------
**Identify High-Risk Customers for Credit Limit Increase**
Develop a SQL query to identify customers who have exceeded their credit limit in the past 6 months, have a high credit utilization ratio, and have a low credit score. The query should also include the customer's credit utilization ratio, average payment amount, and credit score.
Schema:
[
  {
    "name": "customer_transactions",
    "columns": [
      {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "transaction_date", "type": "DATE"},
      {"name": "amount", "type": "DECIMAL(10, 2)"},
      {"name": "credit_limit", "type": "DECIMAL(10, 2)"},
      {"name": "credit_utilization_ratio", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"},
      {"name": "credit_score", "type": "INT"},
      {"name": "average_payment_amount", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "credit_reports",
    "columns": [
      {"name": "report_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "report_date", "type": "DATE"},
      {"name": "credit_score", "type": "INT"}
    ]
  }
]
Response:
SELECT 
  c.customer_id,
  c.name,
  c.email,
  c.credit_score,
  c.average_payment_amount,
 CASE 
  WHEN SUM(ct.amount) - SUM(ct.credit_limit) > 0 THEN 1 ELSE 0 
 END AS credit_exceeded,
 SUM(ct.amount) / SUM(ct.credit_limit) AS credit_utilization_ratio,
 (SELECT AVG(credit_score) FROM credit_reports WHERE report_date >= DATE('now', '-6 months') AND customer_id = c.customer_id) AS recent_credit_score
FROM customers c
JOIN customer_transactions ct ON c.customer_id = ct.customer_id
JOIN credit_reports cr ON c.customer_id = cr.customer_id AND cr.report_date >= DATE('now', '-6 months')
GROUP BY c.customer_id, c.name, c.email, c.credit_score, c.average_payment_amount
HAVING credit_utilization_ratio > 0.5 AND credit_exceeded = 1 AND recent_credit_score < 600
------------------
Identify top-performing sales representatives by region and product category, and calculate their total sales revenue and average order value for the last quarter, taking into account only sales orders that were fulfilled within a 7-day window.
Schema:
[
    {
        "name": "sales_representatives",
        "columns": [
            {"name": "rep_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "product_category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "sales_orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "rep_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_representatives(rep_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_value", "type": "DECIMAL(10, 2)"},
            {"name": "fulfillment_date", "type": "DATE"}
        ]
    },
    {
        "name": "product_info",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "region_info",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(50)"},
            {"name": "region_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    s.region, 
    s.product_category, 
    SUM(so.order_value) AS total_sales_revenue, 
    AVG(so.order_value) AS average_order_value
FROM 
    sales_representatives s
JOIN 
    sales_orders so ON s.rep_id = so.rep_id
WHERE 
    so.fulfillment_date >= DATE('now', '-3 months')
    AND so.fulfillment_date <= DATE('now')
    AND so.fulfillment_date BETWEEN so.order_date AND so.order_date + INTERVAL 7 DAY
GROUP BY 
    s.region, 
    s.product_category
ORDER BY 
    total_sales_revenue DESC
------------------
Develop a data mart for a retail company to analyze sales trends by product category, region, and time of year. The data mart should include sales revenue, unit sales, and customer demographics for each product category. The data should be aggregated at the regional level and include the top 3 product categories by sales revenue for each region.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "product_name", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(50)"},
            {"name": "region_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_revenue", "type": "DECIMAL(10, 2)"},
            {"name": "sale_units", "type": "INT"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "customer_email", "type": "VARCHAR(255)"},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    p.category, 
    SUM(s.sale_revenue) AS total_revenue, 
    SUM(s.sale_units) AS total_units, 
    c.customer_name, 
    c.customer_email
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
JOIN 
    customers c ON s.region_id = c.region_id
JOIN 
    regions r ON c.region_id = r.region_id
GROUP BY 
    r.region_name, 
    p.category, 
    c.customer_name, 
    c.customer_email
ORDER BY 
    r.region_name, 
    p.category, 
    total_revenue DESC
LIMIT 
    3
------------------
**Analyze Sales Performance by Region and Product Category**

Develop a SQL query to retrieve the total sales revenue by region and product category for a retail company with a large number of products and store locations. The query should include the top 5 regions by sales revenue and the top 5 product categories by sales revenue.
Schema:
[
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  s.region, 
  pc.category, 
  SUM(s.sale_amount) AS total_sales
FROM 
  sales s
  LEFT JOIN products p ON s.product_id = p.product_id
  LEFT JOIN stores st ON s.store_id = st.store_id
  LEFT JOIN (
    SELECT 
      category, 
      SUM(sale_amount) AS total_sales
    FROM 
      sales
    GROUP BY 
      category
  ) pc ON p.category = pc.category
GROUP BY 
  s.region, 
  pc.category
ORDER BY 
  total_sales DESC
LIMIT 5;

SELECT 
  s.region, 
  SUM(s.sale_amount) AS total_sales
FROM 
  sales s
  LEFT JOIN stores st ON s.store_id = st.store_id
GROUP BY 
  s.region
ORDER BY 
  total_sales DESC
LIMIT 5;
------------------
**Customer Segmentation and Churn Analysis**

Design a SQL query to segment customers based on their purchase behavior and identify high-value customers who are at risk of churning. The query should include the top 5 customer segments by total spend, the top 5 customers by average order value, and the top 5 products by sales to high-value customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    c.name, c.email, SUM(o.order_amount) as total_spend
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
GROUP BY 
    c.name, c.email
ORDER BY 
    total_spend DESC
LIMIT 5

UNION ALL

SELECT 
    c.name, c.email, AVG(o.order_amount) as avg_order_value
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
GROUP BY 
    c.name, c.email
ORDER BY 
    avg_order_value DESC
LIMIT 5

UNION ALL

SELECT 
    p.product_name, SUM(oi.quantity * o.order_amount) as sales_to_high_value_customers
FROM 
    products p
JOIN 
    order_items oi ON p.product_id = oi.product_id
JOIN 
    orders o ON oi.order_id = o.order_id
JOIN 
    customers c ON o.customer_id = c.customer_id
GROUP BY 
    p.product_name
HAVING 
    AVG(o.order_amount) > (SELECT AVG(o2.order_amount) FROM orders o2)
ORDER BY 
    sales_to_high_value_customers DESC
LIMIT 5
------------------
**Financial Forecasting and Budgeting**

Design a SQL query to analyze historical sales data, forecast future sales, and identify areas for budget optimization for a retail company with multiple store locations and product categories. The query should include the top 5 product categories by sales growth rate, the top 5 store locations by sales revenue, and the top 5 products by predicted future sales.
Schema:
[
    {
        "name": "stores",
        "columns": [
            {"name": "store_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_name", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "budgets",
        "columns": [
            {"name": "budget_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "store_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES stores(store_id)"]},
            {"name": "budget_year", "type": "INT"},
            {"name": "budget_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  p.category, 
  SUM(s.sale_amount) as total_sales, 
  (SUM(s.sale_amount) - b.budget_amount) as variance 
FROM 
  sales s 
  JOIN products p ON s.product_id = p.product_id 
  JOIN budgets b ON s.store_id = b.store_id 
  AND s.sale_date >= b.budget_year 
  AND s.sale_date <= b.budget_year + 1 
GROUP BY 
  p.category 
ORDER BY 
  variance DESC 
LIMIT 5

SELECT 
  s.store_name, 
  SUM(s.sale_amount) as total_sales 
FROM 
  sales s 
  JOIN stores st ON s.store_id = st.store_id 
GROUP BY 
  s.store_name 
ORDER BY 
  total_sales DESC 
LIMIT 5

WITH future_sales AS (
  SELECT 
    s.store_id, 
    p.category, 
    AVG(s.sale_amount) as avg_sales 
  FROM 
    sales s 
    JOIN products p ON s.product_id = p.product_id 
  GROUP BY 
    s.store_id, 
    p.category 
)
SELECT 
  f.category, 
  f.store_id, 
  f.avg_sales * 1.1 as predicted_sales 
FROM 
  future_sales f
------------------
**Analyze Sales Performance by Region and Product Category**

A retail company wants to analyze its sales performance by region and product category. They have sales data for multiple regions and product categories, and they want to see which regions and product categories are performing well, and which ones are underperforming.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sale_amount", "type": "DECIMAL(10,2)"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  r.region, 
  pc.product_category, 
  SUM(s.sale_amount) AS total_sales
FROM 
  sales s
  JOIN customers c ON s.customer_id = c.customer_id
  JOIN regions r ON c.region = r.region
  JOIN product_categories pc ON s.product_category = pc.product_category
GROUP BY 
  r.region, 
  pc.product_category
ORDER BY 
  r.region, 
  pc.product_category, 
  total_sales DESC
------------------
**Track Customer Behavior over Time**

An e-commerce company wants to track the behavior of its customers over time. They have data on customer purchases, browsing history, and demographic information. They want to see which customers are most likely to make repeat purchases, and which ones are likely to churn.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "signup_date", "type": "DATE"}
        ]
    },
    {
        "name": "purchases",
        "columns": [
            {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "browsing_history",
        "columns": [
            {"name": "browse_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "browse_date", "type": "DATE"},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  MAX(p.order_date) AS last_purchase_date, 
  MAX(bh.browse_date) AS last_browse_date, 
  COUNT(p.purchase_id) AS total_purchases, 
  COUNT(bh.browse_id) AS total_browse
FROM 
  customers c
  LEFT JOIN purchases p ON c.customer_id = p.customer_id
  LEFT JOIN browsing_history bh ON c.customer_id = bh.customer_id
GROUP BY 
  c.customer_id, 
  c.name, 
  c.email
ORDER BY 
  total_purchases DESC, 
  last_purchase_date DESC
------------------
**Forecast Demand for Products Based on Historical Sales Data**

A manufacturing company wants to forecast demand for its products based on historical sales data. They have data on sales by product, region, and time period. They want to see which products are in high demand, and which ones are likely to experience a surge in demand.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT p.product_name, SUM(s.sale_amount) AS total_sales, r.region, s.sale_date 

FROM sales s 

INNER JOIN products p ON s.product_id = p.product_id 

INNER JOIN regions r ON s.region = r.region 

GROUP BY p.product_name, r.region, s.sale_date 

ORDER BY p.product_name, r.region, s.sale_date
------------------
**Analyzing Sales Performance Across Regions**

A retail company wants to analyze its sales performance across different regions. They have a large dataset containing sales transactions, product information, and customer demographics. The company wants to generate a report that shows the average sales revenue per region, including the top-selling products and the number of customers who made purchases in each region.
Schema:
[
    {
        "name": "sales_transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT"},
            {"name": "region", "type": "VARCHAR(100)"},
            {"name": "customer_id", "type": "INT"},
            {"name": "sales_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "product_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "customer_email", "type": "VARCHAR(255)"},
            {"name": "customer_address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(100)"},
            {"name": "region_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    AVG(st.sales_amount) as average_sales, 
    p.product_name, 
    COUNT(DISTINCT st.customer_id) as customers
FROM 
    sales_transactions st
JOIN 
    products p ON st.product_id = p.product_id
JOIN 
    regions r ON st.region = r.region_name
GROUP BY 
    r.region_name, p.product_name

UNION

SELECT 
    r.region_name, 
    NULL as average_sales, 
    NULL as product_name, 
    COUNT(DISTINCT st.customer_id) as customers
FROM 
    sales_transactions st
JOIN 
    regions r ON st.region = r.region_name
GROUP BY 
    r.region_name
------------------
**Identifying High-Risk Customers**

A bank wants to identify high-risk customers who are likely to default on their loans. They have a dataset containing customer information, loan details, and credit history. The bank wants to generate a report that shows the top 10 customers with the highest risk of defaulting on their loans, along with their loan amounts and credit scores.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "customer_email", "type": "VARCHAR(255)"},
            {"name": "customer_address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "loans",
        "columns": [
            {"name": "loan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "loan_amount", "type": "DECIMAL(10, 2)"},
            {"name": "loan_status", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "credit_history",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "credit_score", "type": "INT"},
            {"name": "credit_history_date", "type": "DATE"}
        ]
    },
    {
        "name": "credit_bureau",
        "columns": [
            {"name": "credit_bureau_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "credit_bureau_name", "type": "VARCHAR(255)"},
            {"name": "credit_bureau_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT c.customer_name, l.loan_amount, ch.credit_score FROM customers c
JOIN loans l ON c.customer_id = l.customer_id
JOIN credit_history ch ON c.customer_id = ch.customer_id
ORDER BY ch.credit_score DESC
LIMIT 10
------------------
**Predicting Customer Churn**

A telecommunications company wants to predict which customers are likely to churn (cancel their service) in the next 3 months. They have a dataset containing customer information, usage patterns, and billing details. The company wants to generate a report that shows the top 5 factors that contribute to customer churn, along with the predicted probability of churn for each customer.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_name", "type": "VARCHAR(255)"},
            {"name": "customer_email", "type": "VARCHAR(255)"},
            {"name": "customer_address", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "usage_patterns",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_type", "type": "VARCHAR(100)"},
            {"name": "usage_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "billing_details",
        "columns": [
            {"name": "billing_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "billing_amount", "type": "DECIMAL(10, 2)"},
            {"name": "billing_date", "type": "DATE"}
        ]
    },
    {
        "name": "churn_prediction",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_probability", "type": "FLOAT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.customer_name, u.usage_amount, b.billing_amount, ch.churn_probability 
FROM customers c 
JOIN usage_patterns u ON c.customer_id = u.customer_id 
JOIN billing_details b ON c.customer_id = b.customer_id 
JOIN churn_prediction ch ON c.customer_id = ch.customer_id 
WHERE b.billing_date BETWEEN DATE('now', '-3 months') AND DATE('now')
------------------
**Predicting Customer Churn in a Telecommunications Company**
Analyze the historical data to identify the key factors that contribute to customer churn in the company's mobile phone service. Provide insights on the average monthly revenue loss due to churn, customer demographics, and the impact of service plans on churn rates.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "CHAR(1)"},
            {"name": "plan_type", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "service_plan", "type": "VARCHAR(50)"},
            {"name": "monthly_revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "churn",
        "columns": [
            {"name": "churn_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "usage",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "DECIMAL(10,2)"},
            {"name": "voice_usage", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
    AVG(CASE WHEN c.churn_date IS NULL THEN o.monthly_revenue ELSE 0 END) AS avg_monthly_revenue_loss,
    c.age,
    c.gender,
    o.service_plan,
    o.monthly_revenue,
    COUNT(DISTINCT c.customer_id) AS total_customers,
    COUNT(DISTINCT CASE WHEN c.churn_date IS NOT NULL THEN c.customer_id ELSE NULL END) AS churned_customer_count,
    COUNT(DISTINCT CASE WHEN c.churn_date IS NULL THEN c.customer_id ELSE NULL END) AS active_customer_count
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
LEFT JOIN 
    churn ch ON c.customer_id = ch.customer_id
GROUP BY 
    c.age,
    c.gender,
    o.service_plan,
    o.monthly_revenue
------------------
**Analyzing Sales Trends across Different Regions**
Analyze the sales data of a global e-commerce company to identify the top-selling products, regions, and channels. Provide insights on the average order value, sales growth rate, and market share of each region.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "channel", "type": "VARCHAR(50)"},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(50)"},
            {"name": "country", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  r.country, 
  s.channel, 
  AVG(s.order_total) AS average_order_value, 
  SUM(s.order_total) / COUNT(DISTINCT s.order_date) AS sales_growth_rate, 
  SUM(s.order_total) / (SELECT SUM(order_total) FROM sales) AS market_share
FROM 
  sales s
  JOIN regions r ON s.region = r.region_name
GROUP BY 
  r.region_name, 
  r.country, 
  s.channel
ORDER BY 
  market_share DESC
------------------
**Identifying High-Risk Patients in a Healthcare System**
Analyze the medical records of patients in a healthcare system to identify those who are at high risk of developing certain medical conditions. Provide insights on the patient demographics, medical history, and laboratory test results that contribute to the risk assessment.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "CHAR(1)"}
        ]
    },
    {
        "name": "medical_history",
        "columns": [
            {"name": "history_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "medical_condition", "type": "VARCHAR(100)"},
            {"name": "date_of_diagnosis", "type": "DATE"}
        ]
    },
    {
        "name": "lab_results",
        "columns": [
            {"name": "result_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "test_name", "type": "VARCHAR(100)"},
            {"name": "result_value", "type": "DECIMAL(10,2)"},
            {"name": "date_of_test", "type": "DATE"}
        ]
    },
    {
        "name": "risk_factors",
        "columns": [
            {"name": "factor_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "factor_name", "type": "VARCHAR(100)"},
            {"name": "factor_value", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT p.name, p.age, p.gender, 
       COUNT(CASE WHEN m.medical_condition = 'Diabetes' THEN 1 END) AS diabetes_count, 
       COUNT(CASE WHEN l.test_name = 'Cholesterol' AND l.result_value > 200 THEN 1 END) AS high_cholesterol_count, 
       SUM(r.factor_value) AS risk_score
FROM patients p
LEFT JOIN medical_history m ON p.patient_id = m.patient_id
LEFT JOIN lab_results l ON p.patient_id = l.patient_id
LEFT JOIN risk_factors r ON p.patient_id = r.patient_id
GROUP BY p.patient_id, p.name, p.age, p.gender
ORDER BY risk_score DESC
------------------
**Financial Forecasting for E-commerce**

Develop a SQL query to forecast the total revenue for each product category in the next quarter, based on historical sales data, and including a 95% confidence interval for the forecast.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "stock", "type": "INT"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "total_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "price", "type": "DECIMAL(10, 2)"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    p.category, 
    AVG(s.price * s.quantity) AS avg_daily_sales, 
    AVG(s.price * s.quantity) * 90 / 365 AS projected_sales, 
    AVG(s.price * s.quantity) * 1.96 * SQRT(90 * 90 / 365 / 365) AS lower_bound, 
    AVG(s.price * s.quantity) * 1.96 * SQRT(90 * 90 / 365 / 365) + AVG(s.price * s.quantity) * 90 / 365 AS upper_bound
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
WHERE 
    s.sale_date >= DATE('now', '-3 months')
GROUP BY 
    p.category
ORDER BY 
    avg_daily_sales DESC
------------------
**Customer Segmentation for a Retail Chain**

Develop a SQL query to segment customers based on their purchase history, including the average order value, frequency of purchases, and average days between purchases. Group the customers by their age and income, and calculate the percentage of customers in each group.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
    c.age, 
    c.income, 
    AVG(o.total_price) AS avg_order_value, 
    COUNT(o.order_id) AS purchase_frequency, 
    AVG(DATEDIFF(o.order_date, LAG(o.order_date) OVER (PARTITION BY c.customer_id ORDER BY o.order_date))) AS avg_days_between_purchases,
    COUNT(o.order_id) * 100.0 / (SELECT COUNT(*) FROM orders WHERE customer_id = c.customer_id) AS percentage_of_customers
FROM 
    customers c
JOIN 
    orders o ON c.customer_id = o.customer_id
GROUP BY 
    c.age, 
    c.income
------------------
**Time-Series Analysis for a Supply Chain**

Develop a SQL query to analyze the demand for a specific product over the past year, including the average daily demand, peak demand, and the number of days with zero demand. Also, calculate the moving average of demand over a 7-day period.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "demand",
        "columns": [
            {"name": "demand_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT 
  date,
  AVG(quantity) as average_daily_demand,
  MAX(quantity) as peak_demand,
  COUNT(CASE WHEN quantity = 0 THEN demand_id END) as zero_demand_days,
  AVG(quantity) OVER (ORDER BY date ROWS 6 PRECEDING) as moving_average_demand
FROM demand
WHERE date >= DATE('now', '-1 year')
GROUP BY date
------------------
Analyze the sales performance of a retail company across different regions and product categories, considering the impact of seasonal trends and promotions.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10,2)"},
            {"name": "discount", "type": "DECIMAL(5,2)"}
        ]
    },
    {
        "name": "seasonal_trends",
        "columns": [
            {"name": "season", "type": "VARCHAR(255)"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "trend_value", "type": "DECIMAL(5,2)"}
        ]
    },
    {
        "name": "promotions",
        "columns": [
            {"name": "promotion_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "promotion_name", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "discount_percentage", "type": "DECIMAL(5,2)"}
        ]
    },
    {
        "name": "weather_data",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "temperature", "type": "INT"},
            {"name": "humidity", "type": "INT"}
        ]
    },
    {
        "name": "customer_demographics",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "age", "type": "INT"},
            {"name": "income", "type": "DECIMAL(10,2)"},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_category", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    s.region,
    s.product_category,
    s.sale_date,
    s.amount,
    st.trend_value,
    p.discount_percentage
FROM 
    sales s
JOIN 
    seasonal_trends st ON s.region = st.region AND s.product_category = st.product_category AND s.sale_date = st.sale_date
JOIN 
    promotions p ON s.region = p.region AND s.product_category = p.product_category
WHERE 
    s.region IN ('North', 'South', 'East', 'West')
ORDER BY 
    s.region, s.sale_date;
------------------
Develop a data mart for a healthcare organization to track patient outcomes, including the impact of treatment plans and medication adherence on patient recovery. The data mart should consider multiple treatment plans, medication regimens, and patient demographics.
Schema:
[
    {
        "name": "patients",
        "columns": [
            {"name": "patient_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(255)"},
            {"name": "diagnosis", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "treatment_plans",
        "columns": [
            {"name": "treatment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_type", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "medication_regimens",
        "columns": [
            {"name": "regimen_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "treatment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES treatment_plans(treatment_id)"]},
            {"name": "medication_name", "type": "VARCHAR(255)"},
            {"name": "dosage", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "patient_outcomes",
        "columns": [
            {"name": "outcome_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "treatment_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES treatment_plans(treatment_id)"]},
            {"name": "recovery_status", "type": "VARCHAR(255)"},
            {"name": "medication_adherence", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "patient_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES patients(patient_id)"]},
            {"name": "age_group", "type": "VARCHAR(255)"},
            {"name": "income_level", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
CREATE TABLE IF NOT EXISTS data_mart (
    patient_id INT,
    name VARCHAR(255),
    age INT,
    gender VARCHAR(255),
    diagnosis VARCHAR(255),
    treatment_type VARCHAR(255),
    start_date DATE,
    end_date DATE,
    medication_name VARCHAR(255),
    dosage VARCHAR(255),
    recovery_status VARCHAR(255),
    medication_adherence VARCHAR(255),
    age_group VARCHAR(255),
    income_level VARCHAR(255)
);

INSERT INTO data_mart
SELECT p.patient_id, p.name, p.age, p.gender, p.diagnosis,
       tp.treatment_type, tp.start_date, tp.end_date,
       mr.medication_name, mr.dosage,
       po.recovery_status, po.medication_adherence,
       d.age_group, d.income_level
FROM patients p
JOIN treatment_plans tp ON p.patient_id = tp.patient_id
JOIN medication_regimens mr ON tp.treatment_id = mr.treatment_id
JOIN patient_outcomes po ON tp.treatment_id = po.treatment_id
JOIN demographics d ON p.patient_id = d.patient_id;
------------------
Analyze the financial performance of a manufacturing company, considering the impact of product pricing, production costs, and supply chain logistics on profitability. The analysis should cover multiple product categories and suppliers.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "production_costs",
        "columns": [
            {"name": "cost_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "cost_type", "type": "VARCHAR(255)"},
            {"name": "amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "supply_chain",
        "columns": [
            {"name": "supplier_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "supplier_name", "type": "VARCHAR(255)"},
            {"name": "lead_time", "type": "INT"}
        ]
    },
    {
        "name": "financials",
        "columns": [
            {"name": "financial_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "revenue", "type": "DECIMAL(10,2)"},
            {"name": "profit", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
    p.product_name, 
    p.category, 
    p.price, 
    pc.amount, 
    sc.supplier_name, 
    sc.lead_time, 
    f.revenue, 
    f.profit
FROM 
    products p
JOIN 
    production_costs pc ON p.product_id = pc.product_id
JOIN 
    supply_chain sc ON p.product_id = sc.product_id
JOIN 
    financials f ON p.product_id = f.product_id
ORDER BY 
    p.category, 
    p.product_name;
------------------
Develop a data warehouse for a university to track student performance, including the impact of academic advising, course enrollment, and student demographics on graduation rates. The data warehouse should consider multiple degree programs and student cohorts.
Schema:
[
    {
        "name": "students",
        "columns": [
            {"name": "student_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "gender", "type": "VARCHAR(255)"},
            {"name": "degree_program", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "academic_advising",
        "columns": [
            {"name": "advising_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "advising_type", "type": "VARCHAR(255)"},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"}
        ]
    },
    {
        "name": "course_enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "course_id", "type": "INT"},
            {"name": "enrollment_date", "type": "DATE"}
        ]
    },
    {
        "name": "student_demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "age_group", "type": "VARCHAR(255)"},
            {"name": "income_level", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "graduation_rates",
        "columns": [
            {"name": "graduation_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "student_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES students(student_id)"]},
            {"name": "graduation_date", "type": "DATE"},
            {"name": "degree_type", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
WITH student_info AS (
  SELECT s.student_id, s.name, s.age, s.gender, s.degree_program, 
         COUNT(a.advising_id) AS advising_count, 
         COUNT(c.enrollment_id) AS enrollment_count, 
         COUNT(d.demographic_id) AS demographic_count
  FROM students s
  LEFT JOIN academic_advising a ON s.student_id = a.student_id
  LEFT JOIN course_enrollments c ON s.student_id = c.student_id
  LEFT JOIN student_demographics d ON s.student_id = d.student_id
  GROUP BY s.student_id, s.name, s.age, s.gender, s.degree_program
),
graduation_info AS (
  SELECT s.student_id, s.name, s.age, s.gender, s.degree_program, 
         COUNT(g.graduation_id) AS graduation_count
  FROM students s
  LEFT JOIN graduation_rates g ON s.student_id = g.student_id
  GROUP BY s.student_id, s.name, s.age, s.gender, s.degree_program
)
SELECT 
  si.student_id, 
  si.name, 
  si.age, 
  si.gender, 
  si.degree_program, 
  si.advising_count, 
  si.enrollment_count, 
  si.demographic_count, 
  gi.graduation_count
FROM student_info si
JOIN graduation_info gi ON si.student_id = gi.student_id
ORDER BY si.student_id;
------------------
Retrieve the total sales for each product category, including the top-selling product for each category, and the average sales per customer for each product category.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_quantity", "type": "INT"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  p.product_category, 
  SUM(o.order_total) as total_sales, 
  (SELECT product_name 
   FROM orders o 
   JOIN products p ON o.product_id = p.product_id 
   WHERE o.order_total = (SELECT MAX(o2.order_total) 
                            FROM orders o2 
                            JOIN products p2 ON o2.product_id = p2.product_id 
                            WHERE p2.product_category = p.product_category)) as top_selling_product, 
  AVG(o.order_total) / (SELECT COUNT(DISTINCT c.customer_id) 
                          FROM customers c 
                          JOIN orders o ON c.customer_id = o.customer_id 
                          WHERE o.product_id IN (SELECT product_id 
                                                 FROM products 
                                                 WHERE product_category = p.product_category)) as avg_sales_per_customer
FROM 
  orders o 
  JOIN products p ON o.product_id = p.product_id
GROUP BY 
  p.product_category
------------------
Identify the customers who have purchased products from multiple categories, and for each customer, retrieve their purchase history, including the product name, order date, and order total.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_quantity", "type": "INT"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "purchase_history",
        "columns": [
            {"name": "purchase_history_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, c.email, p.product_name, o.order_date, o.order_total 
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id 
JOIN products p ON o.product_id = p.product_id 
WHERE c.customer_id IN (
    SELECT customer_id 
    FROM orders 
    GROUP BY customer_id 
    HAVING COUNT(DISTINCT product_id) > 1
)
------------------
Generate a report on the total sales for each region, including the top-selling product for each region, and the average sales per customer for each region.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(100)"},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_quantity", "type": "INT"},
            {"name": "order_total", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(100)"},
            {"name": "region_code", "type": "VARCHAR(100)"}
        ]
    }
]
Response:
SELECT 
    r.region_name, 
    p.product_name AS top_selling_product,
    SUM(o.order_total) AS total_sales,
    AVG(o.order_total / c.customer_id) AS avg_sales_per_customer
FROM 
    orders o
JOIN 
    customers c ON o.customer_id = c.customer_id
JOIN 
    products p ON o.product_id = p.product_id
JOIN 
    regions r ON c.region = r.region_name
GROUP BY 
    r.region_name, p.product_name
ORDER BY 
    r.region_name;

WITH 
    region_sales AS (
        SELECT 
            r.region_name, 
            SUM(o.order_total) AS total_sales
        FROM 
            orders o
        JOIN 
            customers c ON o.customer_id = c.customer_id
        JOIN 
            regions r ON c.region = r.region_name
        GROUP BY 
            r.region_name
    ),
    top_selling_product AS (
        SELECT 
            r.region_name, 
            p.product_name
        FROM 
            orders o
        JOIN 
            customers c ON o.customer_id = c.customer_id
        JOIN 
            products p ON o.product_id = p.product_id
        JOIN 
            regions r ON c.region = r.region_name
        GROUP BY 
            r.region_name, p.product_name
        ORDER BY 
            r.region_name, SUM(o.order_total) DESC
        LIMIT 1
    )
SELECT 
    r.region_name, 
    tsp.product_name AS top_selling_product,
    rs.total_sales,
    ( SELECT 
        AVG(order_total) / COUNT(DISTINCT customer_id)
      FROM 
        orders
      WHERE 
        region_name = r.region_name
    ) AS avg_sales_per_customer
FROM 
    region_sales rs
JOIN 
    top_selling_product tsp ON rs.region_name = tsp.region_name
ORDER BY 
    r.region_name;
------------------
**Forecasting Sales by Product Category**

A retail company wants to forecast sales for the next quarter based on historical sales data. The company has a large dataset of sales transactions, product information, and customer demographics. The goal is to develop a SQL query that can predict sales for each product category by month, considering factors such as seasonal trends, customer behavior, and product popularity.
Schema:
[
  {
    "name": "sales",
    "columns": [
      {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "product_id", "type": "INT"},
      {"name": "sale_date", "type": "DATE"},
      {"name": "quantity", "type": "INT"},
      {"name": "price", "type": "DECIMAL(10, 2)"}
    ]
  },
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "category_id", "type": "INT"},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "description", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "product_categories",
    "columns": [
      {"name": "category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "description", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"}
    ]
  },
  {
    "name": "orders",
    "columns": [
      {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "order_date", "type": "DATE"},
      {"name": "total_cost", "type": "DECIMAL(10, 2)"}
    ]
  }
]
Response:
SELECT 
    p.category_id,
    pc.name as category_name,
    EXTRACT(YEAR FROM s.sale_date) as year,
    EXTRACT(MONTH FROM s.sale_date) as month,
    SUM(s.quantity * s.price) as total_sales
FROM 
    sales s
JOIN 
    products p ON s.product_id = p.product_id
JOIN 
    product_categories pc ON p.category_id = pc.category_id
GROUP BY 
    p.category_id, pc.name, EXTRACT(YEAR FROM s.sale_date), EXTRACT(MONTH FROM s.sale_date)
ORDER BY 
    p.category_id, EXTRACT(YEAR FROM s.sale_date), EXTRACT(MONTH FROM s.sale_date)
------------------
**Identifying High-Risk Customers**

A financial institution wants to identify high-risk customers who have a high likelihood of defaulting on their loans. The institution has a large dataset of customer information, loan applications, and credit history. The goal is to develop a SQL query that can predict the likelihood of default for each customer based on factors such as credit score, loan amount, and payment history.
Schema:
[
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"},
      {"name": "credit_score", "type": "INT"}
    ]
  },
  {
    "name": "loans",
    "columns": [
      {"name": "loan_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "loan_amount", "type": "DECIMAL(10, 2)"},
      {"name": "loan_date", "type": "DATE"}
    ]
  },
  {
    "name": "payment_history",
    "columns": [
      {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "loan_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES loans(loan_id)"]},
      {"name": "payment_date", "type": "DATE"},
      {"name": "payment_amount", "type": "DECIMAL(10, 2)"}
    ]
  }
]
Response:
SELECT c.customer_id, c.name, c.email, c.credit_score, 
       l.loan_amount, l.loan_date, 
       p.payment_amount, p.payment_date,
       CASE 
           WHEN p.payment_amount > l.loan_amount * 0.8 THEN 'Low Risk'
           WHEN p.payment_amount > l.loan_amount * 0.7 THEN 'Medium Risk'
           ELSE 'High Risk'
       END AS Risk_Level
FROM customers c
JOIN loans l ON c.customer_id = l.customer_id
JOIN payment_history p ON l.loan_id = p.loan_id
WHERE c.credit_score < 600
ORDER BY Risk_Level;
------------------
**Analyzing Customer Segmentation by Demographics**

A retail company wants to analyze customer segmentation based on demographics such as age, gender, and income level. The company has a large dataset of customer information, purchase history, and demographic data. The goal is to develop a SQL query that can segment customers into distinct groups based on their demographics and purchasing behavior.
Schema:
[
  {
    "name": "customers",
    "columns": [
      {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "email", "type": "VARCHAR(255)"},
      {"name": "age", "type": "INT"},
      {"name": "gender", "type": "VARCHAR(10)"},
      {"name": "income_level", "type": "VARCHAR(20)"}
    ]
  },
  {
    "name": "purchases",
    "columns": [
      {"name": "purchase_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
      {"name": "product_id", "type": "INT"},
      {"name": "purchase_date", "type": "DATE"},
      {"name": "quantity", "type": "INT"}
    ]
  },
  {
    "name": "products",
    "columns": [
      {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
      {"name": "name", "type": "VARCHAR(255)"},
      {"name": "description", "type": "VARCHAR(255)"}
    ]
  }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.age, 
  c.gender, 
  c.income_level, 
  COUNT(p.purchase_id) as total_purchases
FROM 
  customers c
  LEFT JOIN purchases p ON c.customer_id = p.customer_id
GROUP BY 
  c.customer_id, 
  c.name, 
  c.email, 
  c.age, 
  c.gender, 
  c.income_level
ORDER BY 
  total_purchases DESC
------------------
**Analyze Sales Performance and Customer Segmentation**

Identify the top 10 customers with the highest average order value (AOV) in the past 6 months, grouped by their location (city). Also, segment the customers into three groups based on their purchase frequency (low, medium, high) and calculate the average AOV for each group.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "location", "type": "VARCHAR(255)"},
            {"name": "purchase_frequency", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT c.location, c.name, AVG(o.total_amount) AS avg_order_value
FROM orders o
JOIN customers c ON o.customer_id = c.customer_id
WHERE o.order_date >= DATE('now', '-6 months')
GROUP BY c.location, c.name
ORDER BY avg_order_value DESC
LIMIT 10;

WITH purchase_frequency AS (
  SELECT customer_id, 
         COUNT(*) AS purchase_count, 
         CASE 
           WHEN COUNT(*) < 10 THEN 'low'
           WHEN COUNT(*) BETWEEN 10 AND 50 THEN 'medium'
           ELSE 'high'
         END AS purchase_frequency
  FROM orders
  WHERE order_date >= DATE('now', '-6 months')
  GROUP BY customer_id
)
SELECT pf.purchase_frequency, AVG(o.total_amount) AS avg_order_value
FROM purchase_frequency pf
JOIN orders o ON pf.customer_id = o.customer_id
WHERE o.order_date >= DATE('now', '-6 months')
GROUP BY pf.purchase_frequency
ORDER BY avg_order_value DESC;
------------------
**Predict Customer Churn and Identify Key Factors**

Design a SQL query to predict customer churn based on their purchase history and demographic information. Use a window function to calculate the average purchase frequency for each customer, and then identify the top 5 customers with the highest churn probability. Also, analyze the impact of different factors (e.g., age, location, purchase history) on customer churn and create a ranking of the most influential factors.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "location", "type": "VARCHAR(255)"},
            {"name": "purchase_history", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
    customer_id,
    name,
    email,
    age,
    location,
    purchase_history,
    avg(order_date) OVER (PARTITION BY customer_id ORDER BY order_date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) AS moving_avg_order_date,
    total_amount
FROM customers
JOIN orders ON customers.customer_id = orders.customer_id
WHERE purchase_history LIKE '%churn%' AND age > 18
ORDER BY moving_avg_order_date DESC
LIMIT 5;

WITH churn_factors AS (
  SELECT 
    customer_id,
    COUNT(*) AS purchase_count,
    SUM(total_amount) AS total_spent,
    AVG(age) AS avg_age,
    AVG(CAST(location AS INT)) AS avg_location
  FROM customers
  JOIN orders ON customers.customer_id = orders.customer_id
  GROUP BY customer_id
),
ranked_factors AS (
  SELECT 
    customer_id,
    purchase_count,
    total_spent,
    avg_age,
    avg_location,
    ROW_NUMBER() OVER (ORDER BY purchase_count DESC) AS rank
  FROM churn_factors
)
SELECT 
  customer_id,
  purchase_count,
  total_spent,
  avg_age,
  avg_location
FROM ranked_factors
WHERE rank <= 5;
------------------
**Optimize Inventory Management and Reduce Stockouts**

Write a SQL query to analyze inventory levels and identify the top 10 products with the highest stockout probability. Use a subquery to calculate the average inventory level for each product, and then join the results with the inventory table to get the actual stock levels. Also, create a ranking of the products based on their stockout probability and suggest a reorder point for each product to minimize stockouts.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "reorder_point", "type": "INT"}
        ]
    },
    {
        "name": "inventory",
        "columns": [
            {"name": "inventory_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "inventory_level", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, p.reorder_point, i.inventory_level, (i.inventory_level - p.reorder_point) / p.reorder_point AS stockout_probability, 
       RANK() OVER (ORDER BY (i.inventory_level - p.reorder_point) / p.reorder_point DESC) AS stockout_rank
FROM products p
JOIN inventory i ON p.product_id = i.product_id
------------------
**Analyze Sales Performance and Identify Key Trends**

Design a SQL query to analyze sales performance by product category and region. Use a window function to calculate the rolling 3-month average sales for each product category and region. Also, identify the top 5 products with the highest sales growth rate and create a ranking of the regions based on their sales performance.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "sale_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  products.product_category, 
  products.region, 
  AVG(sale_amount) AS rolling_avg_sales, 
  RANK() OVER (PARTITION BY products.product_category ORDER BY SUM(sale_amount) DESC) AS product_rank,
  SUM(CASE WHEN sale_date BETWEEN DATE('now', '-3 months') AND DATE('now') THEN sale_amount ELSE 0 END) / 3 AS rolling_3_month_avg_sales,
  RANK() OVER (PARTITION BY products.region ORDER BY SUM(sale_amount) DESC) AS region_rank,
  (SUM(CASE WHEN sale_date BETWEEN DATE('now', '-3 months') AND DATE('now') THEN sale_amount ELSE 0 END) - 
   LAG(SUM(CASE WHEN sale_date BETWEEN DATE('now', '-3 months') AND DATE('now', '-1 month') THEN sale_amount ELSE 0 END), 1, 0) OVER () 
  ) / 
  LAG(SUM(CASE WHEN sale_date BETWEEN DATE('now', '-3 months') AND DATE('now', '-1 month') THEN sale_amount ELSE 0 END), 1, 0) OVER () AS sales_growth_rate
FROM 
  products
JOIN 
  sales ON products.product_id = sales.product_id
GROUP BY 
  products.product_category, products.region
ORDER BY 
  region_rank DESC, product_rank DESC
------------------
**Identify Customer Segments and Analyze Purchase Behavior**

Design a SQL query to identify customer segments based on their purchase behavior and demographic information. Use a clustering algorithm to group customers with similar purchase patterns and demographic characteristics. Also, analyze the purchase behavior of each segment and identify the key drivers of their purchasing decisions.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "age", "type": "INT"},
            {"name": "location", "type": "VARCHAR(255)"},
            {"name": "purchase_history", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
SELECT 
  c.customer_id, 
  c.name, 
  c.email, 
  c.age, 
  c.location, 
  c.purchase_history, 
  GROUPING_ID(DISTINCT o.order_date, o.total_amount) AS group_id
INTO 
  customer_segments
FROM 
  customers c
  JOIN orders o ON c.customer_id = o.customer_id
GROUP BY 
  c.customer_id, 
  c.name, 
  c.email, 
  c.age, 
  c.location, 
  c.purchase_history
ORDER BY 
  group_id;

WITH customer_segments AS (
  SELECT 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.location, 
    c.purchase_history, 
    GROUPING_ID(DISTINCT o.order_date, o.total_amount) AS group_id
  FROM 
    customers c
    JOIN orders o ON c.customer_id = o.customer_id
  GROUP BY 
    c.customer_id, 
    c.name, 
    c.email, 
    c.age, 
    c.location, 
    c.purchase_history
),
segment_purchases AS (
  SELECT 
    group_id, 
    SUM(o.total_amount) AS total_purchases
  FROM 
    customer_segments cs
    JOIN orders o ON cs.customer_id = o.customer_id
  GROUP BY 
    group_id
)
SELECT 
  cs.customer_id, 
  cs.name, 
  cs.email, 
  cs.age, 
  cs.location, 
  cs.purchase_history, 
  sp.total_purchases,
  (SELECT COUNT(*) FROM orders o WHERE o.customer_id = cs.customer_id AND o.total_amount > (SELECT AVG(total_amount) FROM orders)) AS key_drivers
FROM 
  customer_segments cs
  JOIN segment_purchases sp ON cs.group_id = sp.group_id
------------------
**Optimize Supply Chain and Reduce Lead Times**

Write a SQL query to analyze the supply chain and identify the top 10 products with the longest lead times. Use a subquery to calculate the average lead time for each product, and then join the results with the supply chain table to get the actual lead times. Also, create a ranking of the products based on their lead times and suggest a plan to reduce lead times for each product.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "lead_time", "type": "INT"}
        ]
    },
    {
        "name": "supply_chain",
        "columns": [
            {"name": "supply_chain_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "lead_time", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_name, p.lead_time, s.lead_time AS avg_lead_time, 
       (SELECT COUNT(*) 
        FROM supply_chain s2 
        WHERE s2.product_id = s.product_id) AS num_orders, 
       (SELECT AVG(s3.lead_time) 
        FROM supply_chain s3 
        WHERE s3.product_id = s.product_id) AS avg_lead_time_order 
FROM products p 
JOIN supply_chain s ON p.product_id = s.product_id 
ORDER BY avg_lead_time DESC 
LIMIT 10
------------------
Analyze Sales Performance by Product Category and Region
Identify the top 5 product categories in each region with the highest average sales revenue and total sales units over the past year, considering only products with a price above $50.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "price", "type": "DECIMAL(10,2)"},
            {"name": "region", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "revenue", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(50)"},
            {"name": "country", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
SELECT 
    p.category, 
    r.name AS region, 
    AVG(s.revenue) AS avg_sales_revenue, 
    SUM(s.quantity) AS total_sales_units
FROM 
    products p
JOIN 
    sales s ON p.product_id = s.product_id
JOIN 
    regions r ON p.region = r.name
WHERE 
    p.price > 50 AND s.order_date >= DATE('now', '-1 year')
GROUP BY 
    p.category, r.name
ORDER BY 
    avg_sales_revenue DESC
LIMIT 5;
------------------
Predict Customer Churn and Identify High-Risk Customers
Develop a SQL query to predict customer churn based on historical data and identify the top 10 customers with the highest probability of churning within the next 3 months, considering factors such as subscription duration, payment history, and recent activity.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "subscription_date", "type": "DATE"},
            {"name": "last_payment_date", "type": "DATE"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "activity_log",
        "columns": [
            {"name": "log_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "log_date", "type": "DATE"},
            {"name": "activity_type", "type": "VARCHAR(50)"}
        ]
    }
]
Response:
WITH customer_churn AS (
  SELECT 
    c.customer_id,
    c.name,
    c.email,
    c.subscription_date,
    c.last_payment_date,
    AVG(CASE WHEN p.payment_date IS NULL THEN 1 ELSE 0 END) AS avg_null_payments,
    AVG(CASE WHEN a.log_date IS NULL THEN 1 ELSE 0 END) AS avg_null_activity,
    MAX(p.payment_date) AS last_payment,
    MAX(a.log_date) AS last_activity
  FROM 
    customers c
  LEFT JOIN 
    payments p ON c.customer_id = p.customer_id AND p.payment_date >= c.subscription_date
  LEFT JOIN 
    activity_log a ON c.customer_id = a.customer_id AND a.log_date >= c.subscription_date
  GROUP BY 
    c.customer_id, c.name, c.email, c.subscription_date, c.last_payment_date
),
high_risk_customers AS (
  SELECT 
    customer_id,
    name,
    email,
    subscription_date,
    last_payment_date,
    avg_null_payments,
    avg_null_activity,
    last_payment,
    last_activity,
    row_number() OVER (PARTITION BY customer_id ORDER BY avg_null_payments DESC, avg_null_activity DESC) AS churn_rank
  FROM 
    customer_churn
)
SELECT 
  customer_id,
  name,
  email,
  subscription_date,
  last_payment_date,
  avg_null_payments,
  avg_null_activity,
  last_payment,
  last_activity
FROM 
  high_risk_customers
WHERE 
  churn_rank = 1
ORDER BY 
  avg_null_payments DESC, avg_null_activity DESC
LIMIT 10;
------------------
Optimize Inventory Management and Reduce Stockouts
Write a SQL query to identify the top 5 products with the highest probability of stockouts over the next quarter, considering factors such as lead time, demand history, and safety stock levels.
Schema:
[
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(50)"},
            {"name": "lead_time", "type": "INT"},
            {"name": "safety_stock", "type": "INT"}
        ]
    },
    {
        "name": "demand_history",
        "columns": [
            {"name": "demand_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    },
    {
        "name": "stock_levels",
        "columns": [
            {"name": "stock_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "date", "type": "DATE"},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT p.product_id, p.name 
FROM products p 
JOIN (
  SELECT product_id, 
         AVG(CASE WHEN date <= DATE('2023-12-31') - INTERVAL 1 QUARTER THEN quantity ELSE 0 END) / (
           SELECT AVG(quantity) 
           FROM demand_history dh 
           JOIN products p ON dh.product_id = p.product_id 
           WHERE date <= DATE('2023-12-31') - INTERVAL 1 QUARTER
           ) AS stockout_prob 
  FROM demand_history 
  GROUP BY product_id
) dh ON p.product_id = dh.product_id 
ORDER BY stockout_prob DESC 
LIMIT 5
------------------
Analyze the sales performance of a retail company across different regions and product categories, and identify the top-performing regions and products. 
The task requires a SQL query to generate a report that includes the total sales amount, average order value, and number of orders for each region and product category, along with the top 3 regions and top 3 product categories with the highest total sales.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_sales", "type": "DECIMAL(10,2)"},
            {"name": "avg_order_value", "type": "DECIMAL(10,2)"},
            {"name": "num_orders", "type": "INT"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  pc.product_category_name, 
  SUM(s.total_sales) AS total_sales, 
  AVG(s.avg_order_value) AS avg_order_value, 
  COUNT(s.order_date) AS num_orders
FROM 
  sales s
  JOIN regions r ON s.region_id = r.region_id
  JOIN product_categories pc ON s.product_category_id = pc.product_category_id
GROUP BY 
  r.region_name, 
  pc.product_category_name
ORDER BY 
  total_sales DESC
LIMIT 3;

SELECT 
  r(region_name)
FROM 
  (
  SELECT 
    r.region_name, 
    SUM(s.total_sales) AS total_sales
  FROM 
    sales s
    JOIN regions r ON s.region_id = r.region_id
  GROUP BY 
    r.region_name
  ) AS subquery
ORDER BY 
  total_sales DESC
LIMIT 3;

SELECT 
  pc.product_category_name
FROM 
  (
  SELECT 
    pc.product_category_name, 
    SUM(s.total_sales) AS total_sales
  FROM 
    sales s
    JOIN product_categories pc ON s.product_category_id = pc.product_category_id
  GROUP BY 
    pc.product_category_name
  ) AS subquery
ORDER BY 
  total_sales DESC
LIMIT 3;
------------------
Identify the most frequent customers across different product categories, along with their purchase frequency and total sales amount. 
The task requires a SQL query to generate a report that includes the top 5 customers with the highest purchase frequency and total sales amount for each product category, along with the product category name and the total sales amount.
Schema:
[
    {
        "name": "customer_orders",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_sales", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT pc.product_category_name, c.name, COUNT(co.customer_id) as purchase_frequency, SUM(co.total_sales) as total_sales
FROM customer_orders co
JOIN customers c ON co.customer_id = c.customer_id
JOIN product_categories pc ON co.product_category_id = pc.product_category_id
GROUP BY pc.product_category_name, c.name
ORDER BY purchase_frequency DESC, total_sales DESC
LIMIT 5
------------------
Generate a report that shows the average daily sales for each product category over the past 30 days, along with the total sales amount for each category. 
The task requires a SQL query to generate a report that includes the product category name, average daily sales, and total sales amount for each category over the past 30 days.
Schema:
[
    {
        "name": "sales_history",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES product_categories(product_category_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "total_sales", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "product_categories",
        "columns": [
            {"name": "product_category_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_category_name", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  pc.product_category_name, 
  AVG(sh.total_sales) / 30 AS average_daily_sales, 
  SUM(sh.total_sales) AS total_sales_amount
FROM 
  sales_history sh
  JOIN product_categories pc ON sh.product_category_id = pc.product_category_id
WHERE 
  sh.sale_date >= DATE('now', '-30 days')
GROUP BY 
  pc.product_category_name
------------------
Analyze the sales performance of a retail company by identifying the top-selling products across different regions, along with their sales amount and market share. 
The task requires a SQL query to generate a report that includes the product name, sales amount, and market share for each region, along with the top 3 products with the highest sales amount for each region.
Schema:
[
    {
        "name": "product_sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales(sale_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "sales_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES regions(region_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "total_sales", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "regions",
        "columns": [
            {"name": "region_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region_name", "type": "VARCHAR(255)"},
            {"name": "country", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "product_description", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
  r.region_name, 
  p.product_name, 
  SUM(s.sales_amount) AS sales_amount, 
  ROUND(SUM(s.sales_amount) * 100 / ( SELECT SUM(t.sales_amount) FROM product_sales t GROUP BY t.region_id ), 2) AS market_share
FROM 
  product_sales s
  JOIN regions r ON s.region_id = r.region_id
  JOIN products p ON s.product_id = p.product_id
GROUP BY 
  r.region_name, p.product_name
ORDER BY 
  r.region_name, SUM(s.sales_amount) DESC
LIMIT 3

UNION ALL

SELECT 
  r.region_name, 
  p.product_name, 
  0 AS sales_amount, 
  0 AS market_share
FROM 
  ( SELECT DISTINCT region_id FROM product_sales ) r
  JOIN regions r2 ON r.region_id = r2.region_id
  JOIN products p ON ( SELECT product_id FROM product_sales GROUP BY product_id ORDER BY SUM(sales_amount) DESC LIMIT 1 ) = p.product_id
WHERE 
  NOT EXISTS ( SELECT 1 FROM product_sales s WHERE s.product_id = p.product_id AND s.region_id = r.region_id )
------------------
**Identifying High-Value Customers and their Purchase Patterns**

A retail company wants to identify its high-value customers and analyze their purchase patterns. They have a database with customer information, order history, and product details. The goal is to generate a report that shows the top 10 high-value customers, their total spending, and the most frequently purchased products by these customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "created_at", "type": "DATE"},
            {"name": "updated_at", "type": "DATE"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_cost", "type": "DECIMAL(10, 2)"},
            {"name": "status", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"},
            {"name": "unit_price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(100)"},
            {"name": "brand", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "order_item_quantities",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES order_items(order_item_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, SUM(o.total_cost) AS total_spending, 
       (SELECT p.product_name 
        FROM products p 
        JOIN order_items oi ON p.product_id = oi.product_id 
        JOIN order_item_quantities oiq ON oi.order_item_id = oiq.order_item_id 
        WHERE c.customer_id = oi.customer_id 
        GROUP BY p.product_name 
        ORDER BY SUM(oiq.quantity) DESC 
        LIMIT 1) AS most_purchased_product
FROM customers c 
JOIN orders o ON c.customer_id = o.customer_id 
GROUP BY c.customer_id, c.name 
ORDER BY total_spending DESC 
LIMIT 10
------------------
**Analyzing Customer Retention and Churn Rate**

A telecom company wants to analyze its customer retention and churn rate. They have a database with customer information, subscription history, and payment details. The goal is to identify the top 5 reasons for customer churn, the average revenue per user (ARPU) for retained customers, and the top 10 products that are most associated with these customers.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "created_at", "type": "DATE"},
            {"name": "updated_at", "type": "DATE"}
        ]
    },
    {
        "name": "subscriptions",
        "columns": [
            {"name": "subscription_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "start_date", "type": "DATE"},
            {"name": "end_date", "type": "DATE"},
            {"name": "status", "type": "VARCHAR(50)"}
        ]
    },
    {
        "name": "payments",
        "columns": [
            {"name": "payment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "subscription_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES subscriptions(subscription_id)"]},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "payment_date", "type": "DATE"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(100)"},
            {"name": "brand", "type": "VARCHAR(100)"}
        ]
    },
    {
        "name": "customer_product_associations",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "association_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT 
    p.product_name, 
    COUNT(DISTINCT c.customer_id) AS customer_count
FROM 
    customer_product_associations cpa
JOIN 
    customers c ON cpa.customer_id = c.customer_id
JOIN 
    products p ON cpa.product_id = p.product_id
GROUP BY 
    p.product_name
ORDER BY 
    customer_count DESC
LIMIT 10;

WITH customer_retention AS (
    SELECT 
        c.customer_id,
        c.name,
        c.email,
        c.created_at,
        c.updated_at,
        ROW_NUMBER() OVER (PARTITION BY c.customer_id ORDER BY s.name) AS subscription_num
    FROM 
        customers c
    JOIN 
        subscriptions s ON c.customer_id = s.customer_id
    WHERE 
        s.status = 'active'
),
churned_customers AS (
    SELECT 
        c.customer_id,
        c.name,
        c.email,
        c.created_at,
        c.updated_at,
        ROW_NUMBER() OVER (PARTITION BY c.customer_id ORDER BY s.name) AS subscription_num
    FROM 
        customers c
    JOIN 
        subscriptions s ON c.customer_id = s.customer_id
    WHERE 
        s.status = 'cancelled'
),
reasons_for_churn AS (
    SELECT 
        s.status AS reason,
        COUNT(DISTINCT c.customer_id) AS customer_count
    FROM 
        churned_customers c
    JOIN 
        subscriptions s ON c.customer_id = s.customer_id
    GROUP BY 
        s.status
    ORDER BY 
        customer_count DESC
),
arpu AS (
    SELECT 
        AVG(p.amount) AS arpu
    FROM 
        payments p
    JOIN 
        subscriptions s ON p.subscription_id = s.subscription_id
    WHERE 
        s.status = 'active'
)
SELECT 
    reason,
    customer_count,
    (SELECT arpu FROM arpu) AS average_revenue_per_user
FROM 
    reasons_for_churn;
------------------
**Forecasting Sales based on Seasonal Patterns and Weather Data**

A retail company wants to forecast sales based on seasonal patterns and weather data. They have a database with sales history, weather data, and product information. The goal is to generate a report that shows the top 10 products that are most affected by seasonal patterns, the average sales increase during holiday seasons, and the top 5 weather conditions that are most associated with sales decreases.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "quantity", "type": "INT"},
            {"name": "total_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "weather_data",
        "columns": [
            {"name": "weather_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "sale_date", "type": "DATE"},
            {"name": "temperature", "type": "DECIMAL(5, 2)"},
            {"name": "humidity", "type": "DECIMAL(5, 2)"},
            {"name": "wind_speed", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(100)"},
            {"name": "brand", "type": "VARCHAR(100)"}
        ]
    }
]
Response:
SELECT 
  DISTINCT p.product_id,
  p.product_name,
  AVG(CASE 
  WHEN EXTRACT(MONTH FROM s.sale_date) IN (12, 1, 2) THEN s.total_revenue
  ELSE 0 END) - 
  AVG(CASE 
  WHEN EXTRACT(MONTH FROM s.sale_date) NOT IN (12, 1, 2) THEN s.total_revenue
  ELSE 0 END) AS average_sales_increase
FROM 
  sales s
  JOIN products p ON s.product_id = p.product_id
  JOIN weather_data w ON s.sale_date = w.sale_date
WHERE 
  EXTRACT(MONTH FROM s.sale_date) IN (12, 1, 2)
GROUP BY 
  p.product_id, p.product_name
ORDER BY 
  average_sales_increase DESC
LIMIT 10

SELECT 
  w.weather_id,
  AVG(s.total_revenue) AS average_sales
FROM 
  sales s
  JOIN weather_data w ON s.sale_date = w.sale_date
GROUP BY 
  w.weather_id
ORDER BY 
  ABS(AVG(s.total_revenue)) DESC
LIMIT 5
------------------
**Identify Top-Performing Sales Representatives in a Retail Company**

Analyze sales data to determine which sales representatives have generated the highest revenue in each region, considering only the top 20% of representatives.
Schema:
[
    {
        "name": "sales_representatives",
        "columns": [
            {"name": "representative_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(50)"},
            {"name": "commission_rate", "type": "DECIMAL(5, 2)"}
        ]
    },
    {
        "name": "sales_orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "representative_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_representatives(representative_id)"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "total_revenue", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "price", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "order_items",
        "columns": [
            {"name": "order_item_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES sales_orders(order_id)"]},
            {"name": "product_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES products(product_id)"]},
            {"name": "quantity", "type": "INT"}
        ]
    }
]
Response:
SELECT sr.name, sr.region, SUM(so.total_revenue) AS total_revenue
FROM sales_representatives sr
JOIN sales_orders so ON sr.representative_id = so.representative_id
GROUP BY sr.name, sr.region
HAVING SUM(so.total_revenue) >= (SELECT 0.2 * SUM(so2.total_revenue) FROM sales_orders so2 GROUP BY so2.representative_id);
------------------
**Analyze Customer Churn in a Telecommunications Company**

Identify the top 5 customer segments that are most likely to churn, considering factors such as tenure, usage, and billing information.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "phone_number", "type": "VARCHAR(20)"},
            {"name": "tenure", "type": "INT"}
        ]
    },
    {
        "name": "usage_data",
        "columns": [
            {"name": "usage_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "usage_date", "type": "DATE"},
            {"name": "data_usage", "type": "INT"}
        ]
    },
    {
        "name": "billing_info",
        "columns": [
            {"name": "billing_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "billing_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    }
]
Response:
WITH customer_segments AS (
  SELECT 
    c.customer_id,
    c.name,
    c.phone_number,
    c.tenure,
    SUM.ud.data_usage,
    SUM.bi.amount,
    ROW_NUMBER() OVER (PARTITION BY c.customer_id ORDER BY c.tenure DESC, SUM.ud.data_usage DESC, SUM.bi.amount DESC) AS segment_rank
  FROM 
    customers c
  LEFT JOIN 
    usage_data ud ON c.customer_id = ud.customer_id
  LEFT JOIN 
    billing_info bi ON c.customer_id = bi.customer_id
  GROUP BY 
    c.customer_id, c.name, c.phone_number, c.tenure
)
SELECT 
  *
FROM 
  customer_segments
WHERE 
  segment_rank <= 5;
------------------
**Analyzing Sales Performance of Regional Managers**

As a sales manager at a large retail corporation, you want to analyze the sales performance of regional managers across different regions. You have a dataset that includes sales data, product information, and manager assignments. Your task is to write a SQL query that retrieves the top 3 regions with the highest total sales, along with the names of the regional managers responsible for those regions.
Schema:
[
    {
        "name": "sales",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "region", "type": "VARCHAR(255)"},
            {"name": "product_id", "type": "INT"},
            {"name": "sale_date", "type": "DATE"},
            {"name": "amount", "type": "DECIMAL(10, 2)"}
        ]
    },
    {
        "name": "products",
        "columns": [
            {"name": "product_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "product_name", "type": "VARCHAR(255)"},
            {"name": "category", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "managers",
        "columns": [
            {"name": "manager_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "region", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "sales_regions",
        "columns": [
            {"name": "sale_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "manager_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES managers(manager_id)"]},
            {"name": "region", "type": "VARCHAR(255)", "constraints": ["FOREIGN KEY", "REFERENCES managers(region)"]}
        ]
    }
]
Response:
SELECT T1.region, T2.name, SUM(T3.amount) AS total_sales FROM managers AS T1 INNER JOIN sales_regions AS T2 ON T1.region = T2.region INNER JOIN sales AS T3 ON T2.sale_id = T3.sale_id GROUP BY T1.region ORDER BY total_sales DESC LIMIT 3
------------------
**Identifying High-Risk Customers**

As a risk analyst at a financial institution, you want to identify high-risk customers based on their transaction history. You have a dataset that includes customer information, transaction data, and risk assessment scores. Your task is to write a SQL query that retrieves the top 5 customers with the highest risk assessment scores, along with their customer IDs, names, and average transaction amounts.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "transactions",
        "columns": [
            {"name": "transaction_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "amount", "type": "DECIMAL(10, 2)"},
            {"name": "transaction_date", "type": "DATE"}
        ]
    },
    {
        "name": "risk_assessments",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "risk_score", "type": "INT"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, AVG(t.amount) AS avg_transaction_amount
FROM customers c
JOIN transactions t ON c.customer_id = t.customer_id
JOIN risk_assessments ra ON c.customer_id = ra.customer_id
ORDER BY ra.risk_score DESC
LIMIT 5
------------------
**Forecasting Student Enrollment**

As a data analyst at a university, you want to forecast student enrollment based on historical data. You have a dataset that includes enrollment data, demographic information, and academic program details. Your task is to write a SQL query that retrieves the top 3 academic programs with the highest projected enrollment for the next academic year, along with the projected enrollment numbers and the corresponding demographic information.
Schema:
[
    {
        "name": "enrollments",
        "columns": [
            {"name": "enrollment_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "academic_year", "type": "INT"},
            {"name": "program_id", "type": "INT"},
            {"name": "enrollment_number", "type": "INT"}
        ]
    },
    {
        "name": "programs",
        "columns": [
            {"name": "program_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "program_name", "type": "VARCHAR(255)"},
            {"name": "department", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "demographics",
        "columns": [
            {"name": "demographic_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "program_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES programs(program_id)"]},
            {"name": "age_group", "type": "VARCHAR(255)"},
            {"name": "gender", "type": "VARCHAR(255)"}
        ]
    }
]
Response:
SELECT 
    p.program_name, 
    p.department, 
    d.age_group, 
    d.gender, 
    (SELECT COUNT(e.enrollment_id) FROM enrollments e WHERE e.program_id = p.program_id AND e.academic_year = 2024) AS projected_enrollment
FROM 
    programs p
JOIN 
    demographics d ON p.program_id = d.program_id
ORDER BY 
    projected_enrollment DESC
LIMIT 
    3
------------------
**Identifying High-Value Customers for Targeted Marketing**

A retail company wants to identify its most valuable customers to target with marketing campaigns. They want to analyze the customers who have made the most purchases in the last quarter, have the highest average order value, and have not shown any negative behavior (e.g., returns, cancellations). The company wants to know the customer IDs, names, and the total revenue generated by each customer in the last quarter.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "orders",
        "columns": [
            {"name": "order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_date", "type": "DATE"},
            {"name": "customer_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "total_amount", "type": "DECIMAL(10,2)"}
        ]
    },
    {
        "name": "returns",
        "columns": [
            {"name": "return_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "return_date", "type": "DATE"}
        ]
    },
    {
        "name": "cancelled_orders",
        "columns": [
            {"name": "cancelled_order_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "order_id", "type": "INT", "constraints": ["FOREIGN KEY", "REFERENCES orders(order_id)"]},
            {"name": "cancelled_date", "type": "DATE"}
        ]
    }
]
Response:
SELECT c.customer_id, c.name, COALESCE(SUM(o.total_amount), 0) AS total_revenue
FROM customers c
LEFT JOIN orders o ON c.customer_id = o.customer_id
WHERE o.order_date >= DATE('now', '-3 months')
AND o.order_id NOT IN (
  SELECT r.order_id
  FROM returns r
)
AND o.order_id NOT IN (
  SELECT co.order_id
  FROM cancelled_orders co
)
GROUP BY c.customer_id, c.name
ORDER BY SUM(o.total_amount) DESC
------------------
Analyze customer churn for a telecom company and identify the most significant factors that contribute to churn, including the type of service plan, average monthly spend, and time since last bill payment.
Schema:
[
    {
        "name": "customers",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY"]},
            {"name": "name", "type": "VARCHAR(255)"},
            {"name": "email", "type": "VARCHAR(255)"},
            {"name": "service_plan", "type": "VARCHAR(50)"},
            {"name": "average_monthly_spend", "type": "DECIMAL(10,2)"},
            {"name": "time_since_last_bill_payment", "type": "INT"}
        ]
    },
    {
        "name": "churn_data",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY", "FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "churn_date", "type": "DATE"},
            {"name": "reason_for_churn", "type": "VARCHAR(255)"}
        ]
    },
    {
        "name": "payment_history",
        "columns": [
            {"name": "customer_id", "type": "INT", "constraints": ["PRIMARY KEY", "FOREIGN KEY", "REFERENCES customers(customer_id)"]},
            {"name": "payment_date", "type": "DATE"},
            {"name": "payment_amount", "type": "DECIMAL(10,2)"}
        ]
    }
]
Response:
SELECT 
  C.service_plan, 
  AVG(PH.payment_amount) AS avg_monthly_spend, 
  C.time_since_last_bill_payment, 
  COUNT(CD.churn_date) AS churn_count
FROM 
  customers C
  LEFT JOIN payment_history PH ON C.customer_id = PH.customer_id
  LEFT JOIN churn_data CD ON C.customer_id = CD.customer_id
GROUP BY 
  C.service_plan, 
  C.time_since_last_bill_payment
HAVING 
  COUNT(CD.churn_date) > 0
------------------
